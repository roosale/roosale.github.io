import ARKit
import AVFAudio
import AVFoundation
import Accessibility
import AudioToolbox
import Combine
import CoreAudio
import CoreFoundation
import CoreGraphics
import CoreMedia
import CoreMotion
import CoreText
import CoreVideo
import Foundation
import Metal
import Metal.MTLDevice
import OSLog
import QuartzCore
import Spatial
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
import simd

/// Returns a predicate which evaluates to `true` if `operand` evaluates to `false`.
@available(macOS 12.0, iOS 15.0, *)
prefix public func ! <Value>(operand: QueryPredicate<Value>) -> QueryPredicate<Value>

/// Returns a predicate which evaluates to `true` if `left` AND `right` evaluate to `true`.
@available(macOS 12.0, iOS 15.0, *)
public func && <Value>(left: QueryPredicate<Value>, right: QueryPredicate<Value>) -> QueryPredicate<Value>

/// A component that stores accessibility information for an entity.
///
/// Add an `AccessibilityComponent` to entities to provide accessibility information
/// to the system, such as the entity's name which VoiceOver says aloud
/// when it describes the entity.
///
/// See <doc:improving-the-accessibility-of-realitykit-apps> for more information.
@available(macOS 14.0, iOS 17.0, *)
public struct AccessibilityComponent : Component {

    /// A CustomContent struct contains the accessibility strings for the labels you apply to your accessibility content.
    public struct CustomContent : Equatable {

        /// A localized string key that identifies the label for this content.
        public var label: LocalizedStringResource

        /// A localized string key that provides a value for the label.
        public var value: LocalizedStringResource

        /// Determines when to output custom accessibility content.
        public var importance: AXCustomContent.Importance

        /// Creates a new CustomContent with the given label, value, and importance.
        public init(label: LocalizedStringResource, value: LocalizedStringResource, importance: AXCustomContent.Importance)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AccessibilityComponent.CustomContent, b: AccessibilityComponent.CustomContent) -> Bool
    }

    /// A custom action that can be invoked on an entity in response to specific user cues.
    public struct SupportedActions : OptionSet {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int

        /// Tells the entity to activate itself.
        public static let activate: AccessibilityComponent.SupportedActions

        /// Tells the entity to increment the value of its content.
        public static let increment: AccessibilityComponent.SupportedActions

        /// Tells the entity to decrement the value of its content.
        public static let decrement: AccessibilityComponent.SupportedActions

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: Int)

        /// The type of the elements of an array literal.
        @available(iOS 17.0, macOS 14.0, *)
        public typealias ArrayLiteralElement = AccessibilityComponent.SupportedActions

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 17.0, macOS 14.0, *)
        public typealias Element = AccessibilityComponent.SupportedActions

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 17.0, macOS 14.0, *)
        public typealias RawValue = Int
    }

    /// A Boolean value indicating whether the receiver is an accessibility entity that an assistive application can access.
    public var isAccessibilityElement: Bool

    /// A succinct label that identifies the entity, in a localized string key.
    public var label: LocalizedStringResource?

    /// A localized string key that represents the current value of the entity.
    public var value: LocalizedStringResource?

    /// An array of custom content objects that deliver accessibility information.
    ///
    /// Use the Custom Content API to leverage assistive technologies to deliver complex data sets to users in measured portions when they need it.
    public var customContent: [AccessibilityComponent.CustomContent]

    /// The set of supported accessibility actions.
    public var systemActions: AccessibilityComponent.SupportedActions

    /// An array of custom actions supported by the entity, identified by their localized string key.
    public var customActions: [LocalizedStringResource]

    /// Creates a new accessibility component with default values.
    public init()
}

/// Defines an an action animation.
///
/// The definition is used to generate an action animation based `AnimationResource` that can then be played
/// by calling ``Entity/playAnimation(_:transitionDuration:blendLayerOffset:separateAnimatedValue:startsPaused:clock:handoffType:)``
///
/// Action animations can be used to perform operations in lock-step with playback. 
///
/// Actions can be grouped or sequenced with pre-existing animation resources or be stand alone.
/// For example an action that triggers sound can be grouped with a sampled animation to trigger sound
/// effects at the appropriate times during playback. See: ``AnimationResource/group(with:)``
///
/// Stand alone action animations can animate target values using RealityKit's animation engine with
/// cross fade, and additive compositing support.
///
/// (See: ``AnimationStateProtocol``)
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ActionAnimation<ActionType> : AnimationDefinition where ActionType : EntityAction {

    public typealias EventDefinitionType = ActionEventDefinition<ActionType>

    public typealias EventParameterType = ActionType.EventParameterType

    /// A textual name for the animation.
    public var name: String

    /// ``AnimationDefinition/blendLayer`` is not used.
    public var blendLayer: Int32

    /// ``AnimationDefinition/bindTarget`` is not used.
    public var bindTarget: BindTarget

    /// An option that determines which data displays outside of the normal
    /// duration.
    ///
    /// This property determines what to display when the framework samples the
    /// animation outside of the range defined by its underlying duration. The
    /// animation applies this property when:
    ///
    /// - Playback progresses toward, but hasn't yet reached, a nonzero
    /// ``AnimationDefinition/offset``. - A range determined by
    /// ``AnimationDefinition/trimStart``, ``AnimationDefinition/trimEnd``, or
    /// ``AnimationDefinition/trimDuration`` exceeds the animation's underlying
    /// duration.
    public var fillMode: AnimationFillMode

    /// The optional time, in seconds, at which the animation plays.
    ///
    /// This property is `nil` by default, which plays the animation with `time`
    /// = `0`. If you set a value, the animation edits the duration according to
    /// the specified beginning time.
    ///
    /// If you set a negative value for this property, the duration increases
    /// and the additional animation data fills in based on the
    /// ``AnimationView/fillMode`` you choose.
    public var trimStart: TimeInterval?

    /// The optional time, in seconds, at which the animation stops.
    ///
    /// This property is `nil` by default, which plays the animation until
    /// `time` = ``AnimationGroup/duration``. If you set a value, the animation
    /// edits the duration according to the specified ending time.
    public var trimEnd: TimeInterval?

    /// An optional duration that overrides the calculated duration.
    ///
    /// The framework calculates ``AnimationAction/duration``, but you can set
    /// this property to override it. This property is `nil` by default, which
    /// indicates that the animation stops after one play that spans
    /// ``AnimationAction/duration``.
    ///
    /// If you set a value for this property and both
    /// ``AnimationAction/trimStart`` and ``AnimationAction/trimEnd`` are `nil`,
    /// the animation observes this property as an edited duration.
    ///
    /// A value greater than ``AnimationAction/duration`` causes the animation to
    /// repeat, applying the characteristics defined by
    /// ``AnimationAction/repeatMode``. Assign this property
    /// <doc://com.apple.documentation/documentation/swift/double/1849607-greatestfinitemagnitude>
    /// to repeat indefinitely.
    public var trimDuration: TimeInterval?

    /// The time, in seconds, at which the animation begins within the duration.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no offset. Setting a value for this property moves the animation data
    /// along the timeline and doesn't change timing. If you set a
    /// ``AnimationAction/fillMode`` other than ``AnimationFillMode/none``, the
    /// animation fills the vacant area created by the offset according to the
    /// characteristics of the specified fill mode.
    public var offset: TimeInterval

    /// An amount of time that lapses before the animation plays.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no delay. If you set a value for this property, the animation plays from
    /// its start time after the specified delay lapses.
    ///
    /// During the delayed time, the animation doesn't update. However, to fill
    /// the delayed time with some portion of animation, set a negative
    /// ``AnimationAction/trimStart`` instead and choose a
    /// ``AnimationAction/fillMode`` that displays the desired portion of
    /// animation.
    public var delay: TimeInterval

    /// A factor that changes the animation’s rate of playback.
    ///
    /// The default value is `1.0`, which doesn’t alter the animation’s
    /// duration. A value of `2.0` indicates that the duration is half the
    /// normal rate. A value of `0.5` indicates that the duration is twice the
    /// normal rate. Negative values play the animation in reverse.
    ///
    /// This property doesn’t affect the animation’s
    /// ``FromToByAnimation/delay``.
    public var speed: Float

    /// An option that determines how the animation repeats.
    ///
    /// If you call ``AnimationAction/trimmed(start:end:duration:)`` with a
    /// `start` or `end` that lies outside of the timeline defined by
    /// ``AnimationAction/duration``, the animation fills the additional playback
    /// by applying this property.
    public var repeatMode: AnimationRepeatMode

    /// The elapsed time for one complete rotation.
    ///
    /// The framework sets a value for this property depending on the underlying
    /// animation data and the specified ``AnimationAction/speed``.
    ///
    /// You can override the default duration by defining
    /// ``AnimationAction/trimStart``, ``AnimationAction/trimEnd``, or
    /// ``AnimationAction/trimDuration``.
    public var duration: TimeInterval { get }

    /// Constructs an action animation that generates events at user defined times.
    ///
    /// - Parameters:
    ///   - action: The user action.
    ///
    ///   - events: An array of event definitions defining when each action event occurs.
    ///
    ///   - name: The name of the animation.
    ///
    ///   - bindTarget: A textual name that identifies the particular property
    ///          that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation
    ///          into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - trimStart: The optional time, in seconds, at which the animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that lapses before the animation plays.
    ///
    ///   - speed: A factor that changes the animation’s rate of playback.
    public init(for action: ActionType, events: [ActionAnimation<ActionType>.EventDefinitionType], name: String = "", bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)

    /// The action for which an animation is being defined.
    public var action: ActionType?

    /// The event interval definitions, and their associated parameter data.
    public var eventDefinitions: [ActionEventDefinition<ActionType>]
}

/// Options available to determine the resolution method for a target entity in an action.
///
/// Use this to resolve the entity an action should target. For example, ``ImpulseAction``
/// structure accepts this enumeration as an initializer argument to resolve the entity.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public enum ActionEntityResolution : Codable, Equatable {

    /// An option that resolves an entity by specifying a bind path relative to the entity playing the action.
    ///
    /// Use this to resolve a ``BindTarget.EntityPath`` from the entity playing the action.
    /// The targeted entity will have the action applied to it.
    case entityPath(BindTarget.EntityPath)

    /// An option that resolves an entity from the specified name within the scene of the entity playing the action.
    ///
    /// - Note: Consider unique entity names when resolving with this option.
    case entityNamed(String)

    /// Resolves to the source entity that is playing the action.
    public static var sourceEntity: ActionEntityResolution { get }

    /// Indicates whether two action entity resolutions are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first action entity resolution to compare.
    ///
    ///   - rhs: The second action entity resolution to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the action entity resolutions are
    /// equal.
    public static func == (lhs: ActionEntityResolution, rhs: ActionEntityResolution) -> Bool

    /// Creates a new instance from a decoder.
    ///
    /// Throws an error if reading from `decoder` fails, or if the data is
    /// corrupted or otherwise invalid.
    ///
    /// - Parameters:
    ///   - decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Writes the action entity resolution data into an encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container. This function throws an
    /// <doc://com.apple.documentation/documentation/swift/error> if any values
    /// are invalid for the given encoder’s format.
    ///
    /// - Parameters:
    ///   - encoder:  The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

/// The structure returned to all action event handlers.
///
/// Actions perform their function within one or more custom event handlers
/// associated with an action type.
///
/// The event structure contains useful information for an action to perform its function when
/// an action event is raised.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ActionEvent<ActionType> where ActionType : EntityAction {

    /// The animation playback controller that manages the animation executing the action.
    public let playbackController: AnimationPlaybackController

    /// The action parameter data that remains constant across one or more events intervals
    /// defined for the action animation.
    public let action: ActionType

    /// The event parameter data that can vary for each event.
    public let parameter: ActionType.EventParameterType?

    /// The animation state for the action. 
    ///
    /// Used to procedurally animate a target value with cross-fading, and additive blending support.
    ///
    /// The animation state is available when a bind target along with its type is defined for the action.
    /// (See ``AnimationStateProtocol``)
    ///
    /// The following example returns an animated value to the animation system
    /// for the current frame by storing its value within the returned animation state.
    ///
    /// ```swift
    /// MyCustomAction.subscribe(.updated) { event in
    ///     // The returned state will be nil
    ///     // if the action animation's bind target, and type is not defined.
    ///     guard let animationState = event.animationState else {
    ///        return
    ///     }
    ///     animationState.storeAnimatedValue(myAnimatedResult)
    /// }
    /// ```
    public var animationState: (any AnimationStateProtocol)? { get }

    /// The entity the bind target references.
    ///
    /// For example, if a bind target references an entity's transform (i.e. `.transform`), this value is set to that entity.
    ///
    /// This may differ from the entity property in the playback controller if the bind target references an entity
    /// other than the entity that the animation was played on.
    public let targetEntity: Entity?

    /// A Boolean value that indicates reverse playback when true.
    public let reversed: Bool

    /// The start time of the current event.
    public let startTime: TimeInterval

    /// The duration of the the event.
    public let duration: TimeInterval
}

/// Defines an action event interval, and any associated parameters.
///
/// Start, update, end, and skipped events are raised based on one or more event intervals
/// defined by the action animation.
///
/// Also see: ``ActionEventType``
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ActionEventDefinition<ActionType> where ActionType : EntityAction {

    public typealias EventParameterType = ActionType.EventParameterType

    /// Constructs an event definition.
    ///  - Parameters:
    ///    - startTime: The time when the event becomes active.
    ///    - duration: The duration of the event.
    ///    - parameter: The event parameter to return to the event handler when the event occurs.
    public init(startTime: TimeInterval, duration: TimeInterval, parameter: ActionEventDefinition<ActionType>.EventParameterType? = nil)

    /// The time at which the event interval starts.
    public var startTime: TimeInterval

    /// The event interval's duration.
    public var duration: TimeInterval

    /// Optional parameter data available to the event handler at the time of the event.
    public var parameter: ActionEventDefinition<ActionType>.EventParameterType?
}

/// A set of events that an action responds to.
///
/// Actions can respond to specific events with one or more custom event handlers that
/// you associate with each event type.
///
/// RealityKit calls the event handlers when the animation time enters,
/// exits, or continues within a time interval for an
/// ``ActionEventDefinition``.
///
/// A time interval for an event begins at its starting time and spans up to,
/// but doesn't include, the event's starting time plus its duration.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ActionEventType : OptionSet, Hashable {

    /// An event that takes place when a new action event begins.
    public static var started: ActionEventType { get }

    /// An event that takes place after an action event starts and is within its time interval.
    public static var updated: ActionEventType { get }

    /// An event that takes place when the action event exits its time interval.
    ///
    /// End is also raised when the animation terminates before the action event completes.
    public static var ended: ActionEventType { get }

    /// An event that takes place when the system misses an action event's time interval.
    ///
    /// RealityKit generates a skip event under the following conditions:
    /// - The current time is greater than or equal to the event's ending time.
    /// - The previous frame's time is less than the event's starting time.
    public static var skipped: ActionEventType { get }

    /// An event that takes place when the animation pauses.
    public static var paused: ActionEventType { get }

    /// An event that takes place when the animation resumes after a pause.
    public static var resumed: ActionEventType { get }

    /// An event that takes place when the animation ends.
    public static var terminated: ActionEventType { get }

    /// Creates an action event type from a raw value.
    /// - Parameters:
    ///   - rawValue: The backing data value for force effect inputs.
    public init(rawValue: UInt)

    /// The backing storage for action event types.
    public let rawValue: UInt

    /// The type of the elements of an array literal.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias ArrayLiteralElement = ActionEventType

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = ActionEventType

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias RawValue = UInt
}

/// The base protocol for action handlers.
///
/// One of two approaches can be taken when subscribing to, and responding to action events. Which approach is taken
/// is dictated by complexity of the action, and user preference.
///
/// The simplest approach is to process action events using an external closure. This saves having to define
/// a formal handler for the action. For example:
///
/// ```swift
/// struct MyAction: EntityAction {
///     ...
/// }
/// MyAction.subscribe(to: .started) { event in
///     let action = event.action
///     // Do something with the action.
/// }
/// ```
///
/// The other approach is to use a formal handler. This requires defining a structure for the handler
/// that conforms to the `ActionHandlerProtocol` and registering the handler so it can be instantiated
/// when the action animation is played. It is only necessary to define the event functions for the event types
/// that one wishes to respond to.
///
/// For example:
///
/// ```swift
/// struct MyAction: EntityAction { }
///
/// struct MyActionHandler: ActionHandlerProtocol {
///
///    typealias ActionType = MyAction
///
///    // Application data can be stored within the handler.
///    var applicationData: ApplicationData
///
///    // Customizable init
///    init(action: MyAction, player: Entity, currentLevel: Int) { ... }
///
///    // Process start events
///    mutating func actionStarted(event: EventType) { }
/// }
///
/// MyActionHandler.register { event in
///     // Create the handler.
///     return MyActionHandler(applicationData: appData)
/// }
/// ```
///
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public protocol ActionHandlerProtocol {

    /// The action type associated that is associated with the handler.
    associatedtype ActionType : EntityAction

    /// The event type returned to each event function in the handler.
    typealias EventType = ActionEvent<Self.ActionType>

    /// The function used to respond to action started events.
    ///
    /// A start event is raised when the animation time first falls within an event's
    /// defined time interval.
    mutating func actionStarted(event: Self.EventType)

    /// The function used to respond to action updated events.
    ///
    /// An update event is raised after a start event, and the the animation time remains within the
    /// an action's event interval.
    mutating func actionUpdated(event: Self.EventType)

    /// The function used to respond to action ended events.
    ///
    /// Action ended is raised after a 'started' event has taken place, and the animation time exits
    /// the event interval, or when the animation is terminated before completion.
    mutating func actionEnded(event: Self.EventType)

    /// The function used to respond to action skipped events.
    ///
    /// The animation system can skip over an event interval due to scrubbing or choppy frame rate.
    mutating func actionSkipped(event: Self.EventType)

    /// The function used to respond to action paused events.
    ///
    /// Action paused is raised when the animation is paused.
    mutating func actionPaused(event: Self.EventType)

    /// The function used to respond to action resumed events.
    ///
    /// Action resumed is raised when animation playback is resumed after being paused.
    mutating func actionResumed(event: Self.EventType)

    /// The function used to respond to action terminated events.
    ///
    /// Action terminated is raised when playback is terminated and the animation is removed
    /// from the animation system. This can occur before the animation has a chance to complete
    /// if the user manually stops the animation by calling ``AnimationPlaybackController/stop()``.
    mutating func actionTerminated(event: Self.EventType)

    /// Registers a handler that responds to raised action events for a particular action type.
    ///
    /// - Parameters:
    ///   - creationHandler: The closure that instantiates the handler.
    static func register(_ creationHandler: @escaping (Self.EventType) -> (any ActionHandlerProtocol)?)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ActionHandlerProtocol {

    /// The function used to respond to action started events.
    ///
    /// A start event is raised when the animation time first falls within an event's
    /// defined time interval.
    public mutating func actionStarted(event: Self.EventType)

    /// The function used to respond to action updated events.
    ///
    /// An update event is raised after a start event, and the the animation time remains within the
    /// an action's event interval.
    public mutating func actionUpdated(event: Self.EventType)

    /// The function used to respond to action ended events.
    ///
    /// Action ended is raised after a 'started' event has taken place, and the animation time exits
    /// the event interval, or when the animation is terminated before completion.
    public mutating func actionEnded(event: Self.EventType)

    /// The function used to respond to action skipped events.
    ///
    /// An event interval can be skipped due to scrubbing or a
    /// choppy frame rate. Necessary for stateful actions to maintain consistent state.
    public mutating func actionSkipped(event: Self.EventType)

    /// The function used to respond to action paused events.
    ///
    /// Action paused is raised when the animation is paused.
    public mutating func actionPaused(event: Self.EventType)

    /// The function used to respond to action resumed events.
    /// Action resumed is raised when animation playback is resumed after being paused.
    public mutating func actionResumed(event: Self.EventType)

    /// The function used to respond to action terminated events.
    ///
    /// Action terminated is raised when playback is terminated.
    public mutating func actionTerminated(event: Self.EventType)

    /// Registers a handler that creates an action handler, and subscribes to one or more events.
    /// 
    /// - Parameters:
    ///   - creationHandler: The closure that instantiates the handler.
    public static func register(_ creationHandler: @escaping (Self.EventType) -> (any ActionHandlerProtocol)?)
}

/// See ``ActionHandlerProtocol``
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ActionHandlerProtocol where Self.ActionType : Decodable, Self.ActionType : Encodable, Self.ActionType.EventParameterType : Decodable, Self.ActionType.EventParameterType : Encodable {

    /// Registers a handler that responds to raised action events for a particular action type.
    ///
    /// - Parameters:
    ///   - creationHandler: The closure that instantiates the handler.
    public static func register(_ creationHandler: @escaping (Self.EventType) -> (any ActionHandlerProtocol)?)
}

/// Allows an entity to change the resolution of the resources it uses according
/// to its relevance to the user.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct AdaptiveResolutionComponent : Component {

    public init()

    public var pixelsPerMeter: Float { get }
}

/// A component that configures the ambient rendering of sounds from an entity.
///
/// Ambient audio sources emit each channel of an audio resource from an angle projected from the entity, without reverberation. Ambient
/// audio sources take into account the relative orientation of the source and the listener. Position is not taken into account; the channels
/// do not get louder as the user moves toward them.
///
/// The audio resource's front channels (e.g., mono, center) are projected into the entity's -Z direction, with the rear channels projected
/// into +Z. The left channels are laid out in -X and the right channels are laid out in +X.
///
/// ```swift
/// let entity = Entity()
/// let resource = try AudioFileResource.load(named: "MyAudioFile")
/// entity.ambientAudio = AmbientAudioComponent()
/// entity.playAudio(resource)
/// ```
///
/// The `AmbientAudioComponent` allows you to set the overall level of all sounds played from the entity with the `gain` property,
/// in relative Decibels, in the range `-.infinity ... .zero` where `-infinity` is silent and `.zero` is nominal.
///
/// ```swift
/// entity.ambientAudio?.gain = -10
/// ```
///
/// Ambient audio sources are well suited to play back multichannel content which captures the acoustics of its originating environment in
/// the recording process (e.g., multichannel field recordings of outdoor environments).
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct AmbientAudioComponent {

    /// The overall level for all sounds emitted from an entity.
    ///
    /// In relative Decibels, in the range  `-.infinity ... .zero` where
    /// `.zero` is the default.
    public var gain: Audio.Decibel

    /// Configure the behavior of an ambient audio source.
    ///
    /// - Parameter gain: The overall level for all sounds emitted from an entity.
    public init(gain: Audio.Decibel = .zero)
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AmbientAudioComponent : Component {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AmbientAudioComponent : Equatable, Hashable, Codable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AmbientAudioComponent, b: AmbientAudioComponent) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// See <doc:selecting-an-anchor-for-a-reality-composer-scene> for more
/// information about the different types of anchors available when using Reality Composer.
///
/// ![Diagram showing the components present in the anchor entity. It contains
/// three boxes labeled Transform component, Synchronization component, and
/// Anchoring component.](AnchorEntity-1)
///
/// Add anchor entities directly to your scene's ``Scene/anchors`` collection,
/// or anywhere else in the scene hierarchy by adding them to the
/// ``Entity/children`` collection of another entity in your scene. Because
/// `AnchorEntity` is a subclass of ``Entity``, you can make an anchor entity
/// a child of any other entity. RealityKit might move anchor entities as the
/// scene updates, so the location and rotation of the anchor entity can change
/// relative to its parent, even if your code never modifies its
/// ``Entity/transform`` property.
///
/// Some anchor entities might not show up in your scene at all if RealityKit
/// fails to detect an appropriate place for them. For example, an anchor entity
/// with an `image` target won't show up in the scene until RealityKit detects
/// the specified image in the real world.
///
/// ![Block diagram showing how anchor entities attach to a scene, and how they
/// support entity hierarchies. The root box of the hierarchy diagram represents
/// the ARView. It has one child representing the ARView’s scene, and that scene
/// has two children, both of which are anchor entities. Each of the anchor
/// entities have a hierarchy of child entities beneath them, most of which are
/// labeled Entity, but one of the entities in the hierarchy is another anchor
/// entity.](AnchorEntity-2)
///
/// You can have multiple anchors in a RealityKit scene. For example, one anchor
/// can place a toy car on a horizontal surface, like a table, and another
/// can tie an informative text bubbles to an image in the same scene.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class AnchorEntity : Entity, HasAnchoring {

    /// Creates a new anchor entity.
    @MainActor @preconcurrency required public init()

    /// Creates an anchor entity targeting a particular kind of anchor.
    ///
    /// - Parameters:
    ///   - target: The real world object the anchor should target.
    @available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
    @MainActor @preconcurrency public init(_ target: AnchoringComponent.Target)

    /// Creates an anchor entity with a target fixed at the given position in
    /// the scene.
    ///
    /// - Parameters:
    ///   - position: The position with which to initialize the world target.
    @MainActor @preconcurrency public convenience init(world position: SIMD3<Float>)

    /// Creates an anchor entity with a target fixed at the given position in
    /// the scene.
    ///
    /// - Parameters:
    ///   - transform: The transform with which to initialize the world target.
    @MainActor @preconcurrency public convenience init(world transform: float4x4)

    /// Creates an anchor entity that targets a plane with the given
    /// characteristics.
    ///
    /// - Parameters:
    ///   - alignment: The alignment of the plane to target, like
    ///  ``AnchoringComponent/Target-swift.enum/Alignment/horizontal`` or
    ///  ``AnchoringComponent/Target-swift.enum/Alignment/vertical``.
    ///
    ///   - classification: The classification of the target plane to look for,
    ///  like ``AnchoringComponent/Target-swift.enum/Classification/floor`` or
    ///  ``AnchoringComponent/Target-swift.enum/Classification/ceiling``.
    ///
    ///   - minimumBounds: The minimum size of the target plane.
    @available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
    @MainActor @preconcurrency public convenience init(plane alignment: AnchoringComponent.Target.Alignment, classification: AnchoringComponent.Target.Classification = .any, minimumBounds: SIMD2<Float> = [0, 0])
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AnchorEntity {

    @MainActor @preconcurrency public convenience init(_ target: AnchoringComponent.Target, trackingMode: AnchoringComponent.TrackingMode)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension AnchorEntity {

    @MainActor @preconcurrency public convenience init(_ target: AnchoringComponent.Target, trackingMode: AnchoringComponent.TrackingMode, physicsSimulation: AnchoringComponent.PhysicsSimulation = .isolated)
}

/// A component that anchors virtual content to a real world target.
///
/// This component is essential for getting AR features into RealityKit.
/// Use `AnchoringComponent` to anchor virtual content to a real world target by attaching the component to any ``Entity`` in your RealityKit scene.
///
/// To create an `AnchoringComponent`, you need to specify a ``AnchoringComponent/Target-swift.enum``. You can also specify the ``AnchoringComponent/TrackingMode-swift.struct`` and the ``AnchoringComponent/PhysicsSimulation-swift.enum`` to control how the entity tracks the anchor and how the physics simulates with the entity.
///
/// For example, here's how to create an entity that targets the left hand's wrist with predicted tracking mode:
///
/// ```swift
/// let target = AnchoringComponent.Target.hand(.left, location: .wrist)
/// let anchoringComponent = AnchoringComponent(target, trackingMode: .predicted)
/// let entity = Entity()
/// entity.components.set(anchoringComponent)
/// ```
///
/// The entity with `AnchoringComponent` is inactive when created.
/// RealityKit anchors and activates the entity when it finds an anchor that meets the target requirements.
/// You can check the entity's anchored status using ``Entity/isAnchored``, or you can subscribe to ``SceneEvents/AnchoredStateChanged`` events to receive scene events.
///
/// Similarly, RealityKit unanchors the entity if the target disappears or no longer meets the target requirements.
///
/// For more information about anchors, see <doc://com.apple.documentation/documentation/arkit>.
///
@available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
public struct AnchoringComponent : Component, Equatable {

    /// Defines the kinds of real world objects to which an anchor entity can be tethered.
    public enum Target : Hashable {

        /// Defines the alignment of real-world surfaces to seek as targets.
        public struct Alignment : OptionSet {

            /// Horizontal surfaces.
            public static let horizontal: AnchoringComponent.Target.Alignment

            /// Vertical surfaces.
            public static let vertical: AnchoringComponent.Target.Alignment

            /// Surfaces of any alignment.
            public static let any: AnchoringComponent.Target.Alignment

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public let rawValue: UInt8

            /// Creates a new option set from the given raw value.
            ///
            /// This initializer always succeeds, even if the value passed as `rawValue`
            /// exceeds the static properties declared as part of the option set. This
            /// example creates an instance of `ShippingOptions` with a raw value beyond
            /// the highest element, with a bit mask that effectively contains all the
            /// declared static members.
            ///
            ///     let extraOptions = ShippingOptions(rawValue: 255)
            ///     print(extraOptions.isStrictSuperset(of: .all))
            ///     // Prints "true"
            ///
            /// - Parameter rawValue: The raw value of the option set to create. Each bit
            ///   of `rawValue` potentially represents an element of the option set,
            ///   though raw values may include bits that are not defined as distinct
            ///   values of the `OptionSet` type.
            public init(rawValue: UInt8)

            /// The type of the elements of an array literal.
            @available(iOS 13.0, macOS 10.15, macCatalyst 14.0, *)
            public typealias ArrayLiteralElement = AnchoringComponent.Target.Alignment

            /// The element type of the option set.
            ///
            /// To inherit all the default implementations from the `OptionSet` protocol,
            /// the `Element` type must be `Self`, the default.
            @available(iOS 13.0, macOS 10.15, macCatalyst 14.0, *)
            public typealias Element = AnchoringComponent.Target.Alignment

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 13.0, macOS 10.15, macCatalyst 14.0, *)
            public typealias RawValue = UInt8
        }

        /// Defines types of real-world surfaces to seek as targets.
        public struct Classification : OptionSet {

            /// Look for walls.
            public static let wall: AnchoringComponent.Target.Classification

            /// Look for floors.
            public static let floor: AnchoringComponent.Target.Classification

            /// Look for ceilings.
            public static let ceiling: AnchoringComponent.Target.Classification

            /// Look for tables.
            public static let table: AnchoringComponent.Target.Classification

            /// Look for seats.
            public static let seat: AnchoringComponent.Target.Classification

            /// Look for any kind of surface.
            public static let any: AnchoringComponent.Target.Classification

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public let rawValue: UInt64

            /// Creates a new option set from the given raw value.
            ///
            /// This initializer always succeeds, even if the value passed as `rawValue`
            /// exceeds the static properties declared as part of the option set. This
            /// example creates an instance of `ShippingOptions` with a raw value beyond
            /// the highest element, with a bit mask that effectively contains all the
            /// declared static members.
            ///
            ///     let extraOptions = ShippingOptions(rawValue: 255)
            ///     print(extraOptions.isStrictSuperset(of: .all))
            ///     // Prints "true"
            ///
            /// - Parameter rawValue: The raw value of the option set to create. Each bit
            ///   of `rawValue` potentially represents an element of the option set,
            ///   though raw values may include bits that are not defined as distinct
            ///   values of the `OptionSet` type.
            public init(rawValue: UInt64)

            /// The type of the elements of an array literal.
            @available(iOS 13.0, macOS 10.15, macCatalyst 14.0, *)
            public typealias ArrayLiteralElement = AnchoringComponent.Target.Classification

            /// The element type of the option set.
            ///
            /// To inherit all the default implementations from the `OptionSet` protocol,
            /// the `Element` type must be `Self`, the default.
            @available(iOS 13.0, macOS 10.15, macCatalyst 14.0, *)
            public typealias Element = AnchoringComponent.Target.Classification

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 13.0, macOS 10.15, macCatalyst 14.0, *)
            public typealias RawValue = UInt64
        }

        /// Defines the chirality of tracked hands to look for.
        @available(visionOS 1.0, *)
        @available(macOS, unavailable)
        @available(iOS, unavailable)
        public enum Chirality : Hashable {

            case right

            case left

            case either

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: AnchoringComponent.Target.Chirality, b: AnchoringComponent.Target.Chirality) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Defines the locations of tracked hands to look for.
        @available(visionOS 1.0, *)
        @available(macOS, unavailable)
        @available(iOS, unavailable)
        public struct HandLocation : Hashable {

            /// An anchor location at the center of the wrist on the back of the hand.
            ///
            /// Content anchored this way has its positive y-axis
            /// pointing out of the back of the hand and its positive z-axis pointing
            /// towards the side where the thumb is.
            public static let wrist: AnchoringComponent.Target.HandLocation

            /// An anchor location at the center of the palm.
            ///
            /// Content anchored this way has its positive y-axis pointing out of the palm
            /// and its negative z-axis pointing towards the side where the thumb is.
            public static let palm: AnchoringComponent.Target.HandLocation

            /// An anchor location at the tip of the index finger.
            ///
            /// Content anchored this way has its positive y-axis in the direction
            /// of the fingernail's normal and its positive z-axis pointing towards
            /// the side where the thumb is.
            public static let indexFingerTip: AnchoringComponent.Target.HandLocation

            /// An anchor location at the tip of the thumb.
            ///
            /// Content anchored this way has its positive y-axis in the direction of
            /// the fingernail's normal and its negative z-axis pointing towards
            /// the side where the index finger is.
            public static let thumbTip: AnchoringComponent.Target.HandLocation

            /// An anchor location above the center of the palm in the
            /// world space, regardless how the hand is rotated.
            ///
            /// Content anchored this way has its positive y-axis pointing at the user's head and
            /// its positive z-axis pointing towards the ground.
            public static let aboveHand: AnchoringComponent.Target.HandLocation

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: AnchoringComponent.Target.HandLocation, b: AnchoringComponent.Target.HandLocation) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// An anchor point attached to a fixed position in the scene.
        case world(transform: float4x4)

        /// An anchor point attached to a real world surface.
        case plane(AnchoringComponent.Target.Alignment, classification: AnchoringComponent.Target.Classification, minimumBounds: SIMD2<Float>)

        /// An anchor point attached to the image specified by a group and a name in AR Resources.
        case image(group: String, name: String)

        /// An anchor point attached to the image specified by an image anchoring source.
        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        case referenceImage(from: AnchoringComponent.ImageAnchoringSource)

        /// An anchor point attached to the object specified by an object anchoring source.
        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        case referenceObject(from: AnchoringComponent.ObjectAnchoringSource)

        /// An anchor point attached to a specific location on the user's hand.
        @available(visionOS 1.0, *)
        @available(macOS, unavailable)
        @available(iOS, unavailable)
        @available(tvOS, unavailable)
        case hand(AnchoringComponent.Target.Chirality, location: AnchoringComponent.Target.HandLocation)

        /// An anchor point attached to the user's head.
        @available(visionOS 1.0, *)
        @available(macOS, unavailable)
        @available(iOS, unavailable)
        @available(tvOS, unavailable)
        case head

        /// Indicates whether two targets are equal.
        ///
        /// - Parameters:
        ///   - lhs: The first target to compare.
        ///
        ///   - rhs: The second target to compare.
        ///
        /// - Returns: A Boolean value set to `true` if the two targets are
        /// equal.
        public static func == (lhs: AnchoringComponent.Target, rhs: AnchoringComponent.Target) -> Bool

        /// Hashes the essential components of the target by feeding them into
        /// the given hash function.
        ///
        /// - Parameters:
        ///   - hasher: The hash function to use when combining the components of
        ///     the target.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The real world anchor target to attach the entity to.
    public let target: AnchoringComponent.Target

    /// Creates an anchoring component for a given target.
    ///
    /// - Parameters:
    ///   - target: The kind of real world object to target.
    public init(_ target: AnchoringComponent.Target)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AnchoringComponent, b: AnchoringComponent) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AnchoringComponent {

    /// Decides how the tntity tracks its target anchor.
    public struct TrackingMode : Hashable {

        /// Anchors the entity to the target on the first frame the target is found.
        ///
        /// `once` means the `Entity` transform is evaluated only once when the target anchor presents and the `Entity` is anchored.
        ///
        /// If the target anchor moves or disappears later, the `Entity` stays in place.
        public static let once: AnchoringComponent.TrackingMode

        /// Continuously anchors the entity to its target based on the target's realtime location
        /// and hides the entity when the target is no longer in frame.
        ///
        /// `continuous` means the `Entity` will track the target anchor continuously.
        ///
        /// The `Entity` moves with the anchor and is unanchored if the target anchor disappears or no longer meets the target requirement.
        public static let continuous: AnchoringComponent.TrackingMode

        /// Continuously anchors the entity to its target based on the target's predicted location
        /// and hides the entity when the target is no longer in frame.
        ///
        /// `predicted` means the `Entity` will be updated whenever the corresponding anchor is updated
        /// but its transformation will be `ARKit` prediction.
        ///
        /// If the target does not support prediction, `predicted` behaves the same as `continuous`.
        @available(visionOS 2.0, *)
        public static let predicted: AnchoringComponent.TrackingMode

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AnchoringComponent.TrackingMode, b: AnchoringComponent.TrackingMode) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Defines how the `Entity` tracks its target anchor.
    public var trackingMode: AnchoringComponent.TrackingMode

    public init(_ target: AnchoringComponent.Target, trackingMode: AnchoringComponent.TrackingMode)
}

extension AnchoringComponent {

    /// Defines the source of object anchoring target based on how it is created.
    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    public struct ObjectAnchoringSource : Equatable, Hashable {

        /// Creates the object anchoring source by reference object file URL.
        ///
        /// - Parameters:
        ///    - url: The reference object file URL.
        @available(visionOS 2.0, *)
        @available(macOS, unavailable)
        @available(iOS, unavailable)
        @available(tvOS, unavailable)
        public init(_ url: URL)

        /// Creates the object anchoring source by reference object file asset with provided name and bundle.
        ///
        /// - Parameters:
        ///    - name: The name of the reference object in the bundle.
        ///    - bundle: The bundle to load from.
        @available(visionOS 2.0, *)
        @available(macOS, unavailable)
        @available(iOS, unavailable)
        @available(tvOS, unavailable)
        public init(name: String, in bundle: Bundle = .main)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AnchoringComponent.ObjectAnchoringSource, b: AnchoringComponent.ObjectAnchoringSource) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Defines the source of object anchoring target based on how it is created.
    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    public struct ImageAnchoringSource : Equatable, Hashable {

        /// Creates the image anchoring source from image file URL.
        ///
        /// - Parameters:
        ///    - url: The image file URL.
        ///    - physicalSize: The physical size of tracking image
        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public init(_ url: URL, physicalSize: SIMD2<Float>)

        /// Creates the image anchoring source by group and name in AR Resources.
        ///
        /// - Parameters:
        ///    - group: The group name of the image in AR Resources.
        ///    - name: The name of the image in AR Resources.
        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public init(group: String, name: String)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AnchoringComponent.ImageAnchoringSource, b: AnchoringComponent.ImageAnchoringSource) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension AnchoringComponent {

    /// Describes the physics simulation space of the entity and its descendants.
    ///
    /// This allows developers to fine-tune which entities with an `AnchoringComponent` interact with each other physically, as opposed to not interacting at all.
    public enum PhysicsSimulation : Hashable {

        /// Opts out the entity and its descendants from having their own physics space.
        ///
        /// `none` implies the anchor entity does not have its own physics simulation.
        ///
        /// It will use the regular rules to determine which physics simulation the entity is a part of.
        /// For more about the rules, please check ``PhysicsSimulationComponent``.
        case none

        /// Simulates the entity and its descendants in the entity's own physics space.
        ///
        /// This behavior is similar to using a ``PhysicsSimulationComponent``.
        case isolated

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AnchoringComponent.PhysicsSimulation, b: AnchoringComponent.PhysicsSimulation) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates an anchoring component for a given target, tracking mode and physics simulation.
    /// - Parameters:
    ///   - target: The kind of real world object to target.
    ///   - trackingMode: The tracking mode of the entity.
    ///   - physicsSimulation: The physics simulation space the entity will be in.
    public init(_ target: AnchoringComponent.Target, trackingMode: AnchoringComponent.TrackingMode, physicsSimulation: AnchoringComponent.PhysicsSimulation = .isolated)

    /// Specifies the physics simulation spece that the entity and its descendants are in.
    public var physicsSimulation: AnchoringComponent.PhysicsSimulation
}

/// A type that describes the location on hand, such as the wrist or the thumb tip.
///
/// This is required by ``AnchoringComponent/Target-swift.enum/hand(_:location:)``.
extension AnchoringComponent.Target.HandLocation {

    /// Describes all the hand joints.
    ///
    /// For more information about the joints, refer <doc://com.developer.apple/documentation/arkit/handskeleton>
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(tvOS, unavailable)
    public struct HandJoint : Hashable {

        /// An anchor location at the center of the wrist on the back
        /// of the hand.
        ///
        /// Content anchored this way has its positive y-axis
        /// pointing out of the back of the hand and its positive z-axis pointing
        /// towards the side where the thumb is.
        public static let wrist: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the tip of the thumb.
        ///
        /// Content anchored this way has its positive y-axis in the direction of
        /// the fingernail's normal and its negative z-axis pointing towards
        /// the side where the index finger is.
        public static let thumbTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the tip of the index finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction
        /// of the fingernail's normal and its positive z-axis pointing towards
        /// the side where the thumb is.
        public static let indexFingerTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the knuckle of the thumb.
        ///
        /// Content anchored this way has its positive y-axis in the direction
        /// of the fingernail's normal and its negative z-axis pointing towards
        /// the side where the index finger is.
        public static let thumbKnuckle: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate base of the thumb.
        ///
        /// Content anchored this way has its positive y-axis in the
        /// direction of the fingernail's normal and its negative z-axis pointing
        /// towards the side where the index finger is.
        public static let thumbIntermediateBase: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate tip of the thumb.
        ///
        /// Content anchored this way has its positive y-axis in the
        /// direction of the fingernail's normal and its negative z-axis pointing
        /// towards the side where the index finger is.
        public static let thumbIntermediateTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the metacarpal of the index finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of
        /// the fingernail's normal and its positive z-axis pointing towards the
        /// side where the thumb is.
        public static let indexFingerMetacarpal: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the knuckle of the index finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of
        /// the fingernail's normal and its positive z-axis pointing towards the
        /// side where the thumb is.
        public static let indexFingerKnuckle: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate base of the index finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let indexFingerIntermediateBase: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate tip of the index finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let indexFingerIntermediateTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the metacarpal of the middle finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let middleFingerMetacarpal: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the knuckle of the middle finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let middleFingerKnuckle: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate base of the middle finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let middleFingerIntermediateBase: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate tip of the middle finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let middleFingerIntermediateTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the tip of the middle finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let middleFingerTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the metacarpal of the ring finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let ringFingerMetacarpal: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the knuckle of the ring finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let ringFingerKnuckle: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate base of the ring finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let ringFingerIntermediateBase: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate tip of the ring finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let ringFingerIntermediateTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the tip of the ring finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let ringFingerTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the metacarpal of the little finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let littleFingerMetacarpal: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the knuckle  of the little finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let littleFingerKnuckle: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate base of the little finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let littleFingerIntermediateBase: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the intermediate tip of the little finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let littleFingerIntermediateTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the tip of the little finger.
        ///
        /// Content anchored this way has its positive y-axis in the direction of the
        /// fingernail's normal and its positive z-axis pointing towards the side where
        /// the thumb is.
        public static let littleFingerTip: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the wrist end of forearm on the back of the hand.
        ///
        /// Content anchored this way has its positive y-axis pointing in normal
        /// direction of the dorsum of hand and its negative z-axis towards the
        /// side where the thumb is.
        public static let forearmWrist: AnchoringComponent.Target.HandLocation.HandJoint

        /// An anchor location at the elbow end of forearm on the back of hand.
        ///
        /// Content anchored this way has its positive y-axis in the direction of
        /// the dorsum of hand and its negative z-axis towards the side where
        /// the thumb is.
        public static let forearmArm: AnchoringComponent.Target.HandLocation.HandJoint

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AnchoringComponent.Target.HandLocation.HandJoint, b: AnchoringComponent.Target.HandLocation.HandJoint) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The function that returns the `HandLocation` based on `HandJoint`.
    /// - Parameter joint: The joint to be targeted.
    /// - Returns: The `HandLocation` represents the hand joint.
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(tvOS, unavailable)
    public static func joint(for joint: AnchoringComponent.Target.HandLocation.HandJoint) -> AnchoringComponent.Target.HandLocation
}

/// A functionality specification that animatable data types adopt.
///
/// The templated animation objects, for example ``BlendTreeAnimation``
/// `<Value>`, determine that the type you specify for `Value` adopts this
/// protocol. The types that the framework accepts are: ``JointTransforms``,
/// ``Transform``, <doc://com.apple.documentation/documentation/swift/float>,
/// <doc://com.apple.documentation/documentation/swift/double>,
/// <doc://com.apple.documentation/documentation/swift/simd2>,
/// <doc://com.apple.documentation/documentation/swift/simd3>,
/// <doc://com.apple.documentation/documentation/swift/simd4>, and
/// <doc://com.apple.documentation/documentation/accelerate/simd_quatf>.
@available(macOS 12.0, iOS 15.0, *)
public protocol AnimatableData {
}

/// The configuration, including target object, timeframe, and visual semantics,
/// of an animation.
///
/// The framework adopts this protocol for several concrete animation objects,
/// such as ``FromToByAnimation``, ``SampledAnimation``, ``OrbitAnimation``,
/// ``BlendTreeAnimation``, ``AnimationView``, and ``AnimationGroup``.
@available(macOS 12.0, iOS 15.0, *)
public protocol AnimationDefinition {

    /// A textual name for the animation.
    var name: String { get set }

    /// The order in which the framework composites the animation.
    ///
    /// The framework applies multiple animations on the same target in
    /// ascending order of this property’s value. Animations in a lower layer
    /// run before animations in a higher layer. Animations that share the same
    /// value apply in the order that they execute.
    var blendLayer: Int32 { get set }

    /// An option that determines which data displays outside of the normal
    /// duration.
    ///
    /// This property determines what to display when the framework samples the
    /// animation outside of the range defined by its underlying duration. The
    /// animation applies this property when:
    ///
    /// - Playback progresses toward, but hasn't yet reached, a nonzero
    /// ``AnimationDefinition/offset``. - A range determined by
    /// ``AnimationDefinition/trimStart``, ``AnimationDefinition/trimEnd``, or
    /// ``AnimationDefinition/trimDuration`` exceeds the animation's underlying
    /// duration.
    var fillMode: AnimationFillMode { get set }

    /// A textual name that identifies the particular property that animates.
    var bindTarget: BindTarget { get set }

    /// The time, in seconds, at which the animation plays.
    ///
    /// This property is `nil` by default, which plays the animation with `time`
    /// = `0`. If you set a value, the animation edits the duration according to
    /// the specified beginning time.
    ///
    /// If you set a negative value for this property, the duration increases
    /// and the additional animation data fills in based on the
    /// ``AnimationView/fillMode`` you choose.
    var trimStart: TimeInterval? { get set }

    /// The time, in seconds, at which the source animation stops.
    ///
    /// This property is `nil` by default, which plays the animation until
    /// `time` = ``AnimationDefinition/duration``. If you set a value, the
    /// animation edits the duration according to the specified ending time.
    var trimEnd: TimeInterval? { get set }

    /// An optional duration that overrides the source animation’s duration.
    ///
    /// The framework calculates ``FromToByAnimation/duration``, but you can set
    /// this property to override it. This property is `nil` by default, which
    /// indicates that the animation stops after one play that spans
    /// ``AnimationDefinition/duration``.
    ///
    /// If you set a value for this property and both
    /// ``AnimationDefinition/trimStart`` and ``AnimationDefinition/trimEnd``
    /// are `nil`, the animation observes this property as an edited duration.
    ///
    /// A value greater than ``AnimationDefinition/duration`` causes the
    /// animation to repeat, applying the characteristics defined by
    /// ``AnimationDefinition/repeatMode``. Assign this property
    /// <doc://com.apple.documentation/documentation/swift/double/1849607-greatestfinitemagnitude>
    /// to repeat indefinitely.
    var trimDuration: TimeInterval? { get set }

    /// The time, in seconds, at which the animation begins within the duration.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no offset. Setting a value for this property moves the animation data
    /// along the timeline and doesn't change timing. If you set a
    /// ``SampledAnimation/fillMode`` other than ``AnimationFillMode/none``, the
    /// animation fills the vacant area created by the offset according to the
    /// characteristics of the specified fill mode.
    var offset: TimeInterval { get set }

    /// An amount of time that elapses before the animation plays.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no delay. If you set a value for this property, the animation plays from
    /// its start time after the specified delay lapses.
    ///
    /// During the delayed time, the animation doesn't update. However, to fill
    /// the delayed time with some portion of animation, set a negative
    /// ``AnimationDefinition/trimStart`` instead and choose a
    /// ``AnimationDefinition/fillMode`` that displays the desired portion of
    /// animation.
    var delay: TimeInterval { get set }

    /// A factor that increases or decreases the animation’s rate of playback.
    ///
    /// The default value is `1.0`, which doesn’t alter the animation’s
    /// duration. A value of `2.0` indicates that the duration is half the
    /// normal rate. A value of `0.5` indicates that the duration is twice the
    /// normal rate. Negative values play the animation in reverse.
    ///
    /// This property doesn’t affect the animation’s
    /// ``AnimationDefinition/delay``.
    var speed: Float { get set }

    /// An option that determines how the animation repeats.
    ///
    /// If you call ``AnimationDefinition/trimmed(start:end:duration:)`` with a
    /// `start` or `end` that lies outside of the timeline defined by
    /// ``AnimationDefinition/duration``, the animation fills the additional
    /// playback by applying this property.
    var repeatMode: AnimationRepeatMode { get set }

    /// The total playback time of the animation.
    ///
    /// The framework sets a value for this property depending on the underlying
    /// animation data and the specified ``AnimationDefinition/speed``.
    ///
    /// You can override the default duration by defining
    /// ``AnimationDefinition/trimStart``, ``AnimationDefinition/trimEnd``, or
    /// ``AnimationDefinition/trimDuration``.
    var duration: TimeInterval { get }
}

@available(macOS 12.0, iOS 15.0, *)
extension AnimationDefinition {

    /// Edits the animation duration according to the specified time.
    ///
    /// If an argument property lies outside the underlying
    /// ``AnimationDefinition/duration``, the animation plays back according to
    /// the characteristics of its ``AnimationDefinition/repeatMode``.
    ///
    /// - Parameters:
    ///   - start: The time within the underlying duration to begin playback.
    ///
    ///   - end: The time within the underlying duration to end playback.
    ///
    ///   - duration: The amount of time that overrides the underlying duration.
    ///
    /// - Returns: A version of the animation shortened or lengthened according
    /// to the specified times.
    public func trimmed(start: TimeInterval? = nil, end: TimeInterval? = nil, duration: TimeInterval? = nil) -> Self

    /// Repeats an animation the number of times specified by an irrational
    /// number.
    ///
    /// - Parameters:
    ///   - count: The number of times the animation repeats before stopping.
    ///
    /// - Returns: A version of the calling animation repeated the given number
    /// of times.
    public func repeated(count: TimeInterval) -> Self

    /// Repeats an animation the number of times specified by a whole number.
    ///
    /// - Parameters:
    ///   - count: The number of times the animation repeats before stopping.
    ///
    /// - Returns: A version of the calling animation repeated the given number
    /// of times.
    public func repeated(count: Int) -> Self

    /// Repeats the animation infinitely.
    ///
    /// - Returns: A version of the calling animation that will repeat infinitely.
    public func repeatingForever() -> Self
}

/// Notable milestones that the framework signals during animation playback.
///
/// This enumeration defines the playback states that an animated entity can
/// indicate to an app. To receive notification of a particular event, create a
/// completion handler:
///
/// ```swift
/// private func onAnimationCompleted(_ event:
///     AnimationEvents.PlaybackCompleted) {
///         // Define code that runs when the animation completes.
/// }
/// ```
///
/// Then, subscribe the handler on the entity for the state of interest:
///
/// ```swift
/// // Get an animation.
/// let animationName =
/// entity.availableAnimations.first!.name!
///
/// // Pass the animation to an entity and get a controller.
/// entity.playAnimation(named: animationName, transitionDuration: 0.0)
///
/// entitySubscription = view.scene.publisher(for:
///     AnimationEvents.PlaybackCompleted.self, on: entity)
///         .sink(receiveValue: onAnimationCompleted)
/// ```
@available(macOS 10.15, iOS 13.0, *)
public enum AnimationEvents {

    /// The event raised when an animation reaches the end of its duration.
    ///
    /// This event isn’t triggered if you call the
    /// ``AnimationPlaybackController/stop()`` method on a playback controller.
    public struct PlaybackCompleted : Event {

        /// The animation playback controller managing the animation that
        /// triggered the event.
        public let playbackController: AnimationPlaybackController
    }

    /// The event raised when an animation loops.
    ///
    /// You loop animation playback by creating an ``AnimationResource``
    /// instance from an existing one with either the
    /// ``AnimationResource/repeat(count:)`` or the
    /// ``AnimationResource/repeat(duration:)`` method.
    public struct PlaybackLooped : Event {

        /// The animation playback controller managing the animation that
        /// triggered the event.
        public let playbackController: AnimationPlaybackController
    }

    /// The event raised when an animation has been terminated, regardless of
    /// whether it ran to completion.
    public struct PlaybackTerminated : Event {

        /// The animation playback controller managing the animation that
        /// triggered the event.
        public let playbackController: AnimationPlaybackController
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AnimationEvents {

    /// The event raised when an animation has been started.
    public struct PlaybackStarted : Event {

        /// The animation playback controller managing the animation that
        /// triggered the event.
        public let playbackController: AnimationPlaybackController
    }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension AnimationEvents {

    /// Raised immediately after the SkeletalPoseSystem has been updated.
    public struct SkeletalPoseUpdateComplete : Event {

        /// The elapsed time since the last update.
        public let deltaTime: Float
    }
}

/// Options that determine which animation frames display outside of the normal
/// duration.
///
/// This structure enables you to lock an animation at its starting frame for a
/// period of time before beginning. You can also lock an animation to its
/// ending frame for a specified amount of time after it finishes, or both.
///
/// An animation applies the fill mode you choose when a range determined by
/// ``AnimationView/trimStart``, ``AnimationView/trimEnd``, or
/// ``AnimationView/trimDuration`` exceeds the animation's underlying duration,
/// which the framework calculates as the frame count (see
/// ``SampledAnimation/frames-2j4nj``) multiplied by the
/// ``SampledAnimation/frameInterval``, multiplied by
/// ``AnimationDefinition/speed``.
///
/// For example, if you set the ``AnimationDefinition/trimStart`` property for
/// an animation of a hand waving to `-1.0` and ``SampledAnimation/fillMode`` to
/// ``AnimationFillMode/backwards`` or ``AnimationFillMode/both``, the hand
/// displays immediately, freezes at the first animation frame for one second,
/// and then begins to wave.
@available(macOS 12.0, iOS 15.0, *)
public struct AnimationFillMode : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: Int8

    /// An option that indicates an animation doesn't display frame data outside
    /// of its normal duration.
    ///
    /// For example, if you rewind an animation of a hand waving for one second
    /// by setting ``SampledAnimation/trimStart`` to `-1.0`, a
    /// ``SampledAnimation/fillMode`` of `none` determines that the hand is
    /// invisible for one second before appearing and waving.
    public static let none: AnimationFillMode

    /// An option that freezes the last frame of the animation until it stops.
    ///
    /// For example, if you increase a hand-waving animation’s duration one
    /// second by setting ``SampledAnimation/trimEnd`` to
    /// ``SampledAnimation/duration`` + `1.0`, a ``SampledAnimation/fillMode``
    /// of `forwards` determines that the hand waves and then freezes on its
    /// final animation frame for one second before disappearing.
    public static let forwards: AnimationFillMode

    /// An option that shows the first animation frame while playback progresses
    /// to the beginning position.
    ///
    /// For example, if you wind a hand-waving animation’s duration back one
    /// second by setting ``SampledAnimation/trimStart`` to `-1.0`, a
    /// ``SampledAnimation/fillMode`` of `backwards` determines that the hand
    /// holds its initial appearance for one second before waving.
    public static let backwards: AnimationFillMode

    /// An option that displays the animation's initial frame or final frame
    /// when playback occurs outside of the normal duration.
    ///
    /// For example, if you extend a hand-waving animation’s duration by one
    /// second in both directions by setting ``SampledAnimation/trimStart`` to
    /// `-1.0`, and ``SampledAnimation/trimEnd`` to
    /// ``SampledAnimation/duration`` + `1.0`, a ``SampledAnimation/fillMode``
    /// of `both` determines that the hand holds its initial appearance for one
    /// second before continuing to wave. Then, the animation freezes on its
    /// final hand-waving frame for one second before disappearing.
    public static let both: AnimationFillMode

    /// Creates a fill mode from its backing data type.
    ///
    /// Use this initializer to unarchive a fill mode from data:
    ///
    /// ```swift
    /// let rawValue = unarchiveNextInt8(from: data) // Pseudo code.
    /// let fillMode = AnimationFillMode(rawValue: rawValue)
    /// ```
    ///
    /// - Parameters:
    ///   - rawValue: The backing data value for the fill mode.
    public init(rawValue: Int8)

    /// The type of the elements of an array literal.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias ArrayLiteralElement = AnimationFillMode

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias Element = AnimationFillMode

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias RawValue = Int8
}

/// A collection of animations that play simultaneously.
///
/// This structure concurrently starts the animations it contains. Use a group
/// to:
///
/// - Animate more than one property at once.
/// - Animate the same property at different times.
///
/// ### Animate multiple properties concurrently
///
/// For each animatable property your animation needs to control, create a group
/// and add an animation to the array argument of the initializer. The following
/// listing begins coding an animation group that colorizes 3D numbers that
/// count down over a 4-second duration.
///
/// ```swift
/// let frames: [Float] = [3.0, 2.0, 1.0, 0.0]
/// let duration = TimeInterval(frames.count)
/// let anim1 = FromToByAnimation<Float>(name: "colorize", from: 0.0, to: 1.0,
///     duration: duration, bindTarget: .parameter("foo"))
/// let anim2 = SampledAnimation<Float>(frames: frames, name: "count down",
///     frameInterval: duration / frames.count, bindTarget: .parameter("bar"))
/// let group = AnimationGroup(group: [anim1, anim2], name: "group")
/// ```
///
/// ### Create a sequence for the same animation
///
/// You can play the same animation at different times by grouping multiple
/// ``AnimationDefinition`` objects that refer to the same animated property. To
/// disperse their playback at runtime, give each definition a unique
/// ``AnimationDefinition/delay``.
///
/// - Important: The framework processes animations with a lower
/// ``AnimationGroup/blendLayer`` first, and if the
/// ``AnimationGroup/blendLayer`` matches, in the order in which they appear in
/// the groups array. If two animations on the same property overlap durations
/// at runtime, the one that the framework processes second overwrites the
/// first.
@available(macOS 12.0, iOS 15.0, *)
public struct AnimationGroup : AnimationDefinition {

    /// A collection of animations to run.
    public var group: [any AnimationDefinition]

    /// A textual name for the group.
    public var name: String

    /// The order in which the framework composites the animation.
    ///
    /// The framework applies multiple animations on the same target in
    /// ascending order of this property’s value. Animations in a lower layer
    /// run before animations in a higher layer. Animations that share the same
    /// value apply in the order they execute.
    public var blendLayer: Int32

    /// A textual name that refers to a property on which to run the grouped
    /// animations.
    public var bindTarget: BindTarget

    /// An option that determines which data displays outside of the normal
    /// duration.
    ///
    /// This property determines what to display when the framework samples the
    /// animation outside of the range defined by its underlying duration. The
    /// animation applies this property when:
    ///
    /// - Playback progresses toward, but hasn't yet reached, a nonzero
    /// ``AnimationDefinition/offset``. - A range determined by
    /// ``AnimationDefinition/trimStart``, ``AnimationDefinition/trimEnd``, or
    /// ``AnimationDefinition/trimDuration`` exceeds the animation's underlying
    /// duration.
    public var fillMode: AnimationFillMode

    /// A Boolean value that indicates whether the animation builds on the
    /// current state of the target entity or resets the state before running.
    public var additive: Bool

    /// The time, in seconds, at which the animations play.
    ///
    /// This property is `nil` by default, which plays the animation with `time`
    /// = `0`. If you set a value, the animation edits the duration according to
    /// the specified beginning time.
    ///
    /// If you set a negative value for this property, the duration increases
    /// and the additional animation data fills in based on the
    /// ``AnimationView/fillMode`` you choose.
    public var trimStart: TimeInterval?

    /// The time, in seconds, at which the animations stop.
    ///
    /// This property is `nil` by default, which plays the animation until
    /// `time` = ``AnimationGroup/duration``. If you set a value, the animation
    /// edits the duration according to the specified ending time.
    public var trimEnd: TimeInterval?

    /// An optional duration that overrides the calculated duration.
    ///
    /// The framework calculates ``FromToByAnimation/duration``, but you can set
    /// this property to override it. This property is `nil` by default, which
    /// indicates that the animation stops after one play that spans
    /// ``AnimationGroup/duration``.
    ///
    /// If you set a value for this property and both
    /// ``AnimationGroup/trimStart`` and ``AnimationGroup/trimEnd`` are `nil`,
    /// the animation observes this property as an edited duration.
    ///
    /// A value greater than ``AnimationGroup/duration`` causes the animation to
    /// repeat, applying the characteristics defined by
    /// ``AnimationGroup/repeatMode``. Assign this property
    /// <doc://com.apple.documentation/documentation/swift/double/1849607-greatestfinitemagnitude>
    /// to repeat indefinitely.
    public var trimDuration: TimeInterval?

    /// The time, in seconds, at which the animations begin within the duration.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no offset. Setting a value for this property moves the animation data
    /// along the timeline and doesn't change timing. If you set a
    /// ``AnimationGroup/fillMode`` other than ``AnimationFillMode/none``, the
    /// animation fills the vacant area created by the offset according to the
    /// characteristics of the specified fill mode.
    public var offset: TimeInterval

    /// An amount of time that lapses before the animation plays.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no delay. If you set a value for this property, the animation plays from
    /// its start time after the specified delay lapses.
    ///
    /// During the delayed time, the animation doesn't update. However, to fill
    /// the delayed time with some portion of animation, set a negative
    /// ``AnimationGroup/trimStart`` instead and choose a
    /// ``OrbitAnimation/fillMode`` that displays the desired portion of
    /// animation.
    public var delay: TimeInterval

    /// A factor that increases or decreases the animation's rate of playback.
    ///
    /// The default value is `1.0`, which doesn’t alter the animation’s
    /// duration. A value of `2.0` indicates that the duration is half the
    /// normal rate. A value of `0.5` indicates that the duration is twice the
    /// normal rate. Negative values play the animation in reverse.
    ///
    /// This property doesn’t affect the animation’s
    /// ``FromToByAnimation/delay``.
    public var speed: Float

    /// An option that determines how the animations repeat.
    ///
    /// If you call ``FromToByAnimation/trimmed(start:end:duration:)`` with a
    /// `start` or `end` that lies outside of the timeline defined by
    /// ``AnimationGroup/duration``, the animation fills the additional playback
    /// by applying this property.
    public var repeatMode: AnimationRepeatMode

    /// The total playback time of the animation.
    ///
    /// The framework sets a value for this property depending on the underlying
    /// animation data and the specified ``AnimationGroup/speed``.
    ///
    /// You can override the default duration by defining
    /// ``AnimationGroup/trimStart``, ``AnimationGroup/trimEnd``, or
    /// ``AnimationGroup/trimDuration``.
    public var duration: TimeInterval { get }

    /// Creates a collection of animations that play simultaneously.
    ///
    /// - Parameters:
    ///   - group: A collection of animations to run.
    ///
    ///   - name: A textual name for the group.
    ///
    ///   - repeatMode: An option that determines how the animations repeat.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - trimStart: The time, in seconds, at which the animations play.
    ///
    ///   - trimEnd: The time, in seconds, at which the animations stop.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that lapses before the animation plays.
    ///
    ///   - speed: A factor that increases or decreases the animation’s rate of playback.
    public init(group: [any AnimationDefinition], name: String = "", repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)

    /// An optional collection of animations to run.
    ///
    /// Don't use this property. Use ``AnimationGroup/group`` instead.
    @available(*, deprecated, renamed: "group")
    public var group_: [any AnimationDefinition]?
}

/// The type of handoff the play animation method performs between a current animation and a new animation.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct AnimationHandoffType : Equatable {

    /// Stops the current animation and uses the current value of that animation as the blend value for the transition to the new animation.
    ///
    /// If `applyToAllLayers` is `false`, the handoff only replaces current animations that have the same `layerId` as the `blendLayerOffset` parameter in the ``playAnimation()`` call.
    ///
    /// If `applyToAllLayers` is `true`, the handoff replaces all animations regardless of the layer.
    public static func snapshotAndReplace(applyToAllLayers: Bool = true) -> AnimationHandoffType

    /// Keeps playing the current animation during the transition time and uses the value from that
    /// animation as the blend value for the transition to the new animation.
    ///
    /// If `applyToAllLayers` is `false`, the handoff only replaces current animations that have the same `layerId` as the `blendLayerOffset` parameter in the `playAnimation()` call.
    ///
    /// If `applyToAllLayers` is `true`, the handoff replaces all animations regardless of the layer.
    public static func replace(applyToAllLayers: Bool = true) -> AnimationHandoffType

    /// Adds the new animation to existing animations, and immediately starts the new animation.
    ///
    /// Use this handoff for additive animations.
    /// If the new animation isn't additive, then `compose` adds the new animation and removes the existing animation.
    public static var compose: AnimationHandoffType { get }

    /// Stops the specified animation.
    public static var stop: AnimationHandoffType { get }

    /// Provides the default behavior.
    ///
    /// If the `layerId` in the `playAnimation()` call is a non-zero value, the default behavior is a ``compose`` handoff .
    /// If the `layerId` is `0,` then the default behavior is a `snapshotAndReplace(applyToAllLayers: true)` handoff.
    public static var `default`: AnimationHandoffType { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AnimationHandoffType, b: AnimationHandoffType) -> Bool
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension AnimationHandoffType : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A component that represents a collection of animations that an entity can play.
///
/// You use an `AnimationLibraryComponent` to access an entity's animation resources.
/// You can store animations with an entity by packaging them together into a `.reality` file.
/// You can do this with Reality Composer Pro or by building a custom tool.
///
/// ### Create an animation library with Reality Composer Pro
///
/// Follow these steps to create an animation library for an entity:
/// 1. In the hierarchy view, select the entity you want to add animations to.
/// 2. In the inspector, click Add Component and select Animation Library from the list of components.
/// 3. Click the Add button (+) and select the USD files with animations.
///
/// @Image(
///     source: realitycomposerpro-animationlibrary,
///     alt: "A screenshot of Reality Composer Pro showing the Animation Library in the Inspector. It contains two elements representing animations that have been added to the animation library. The animations are named walk and idle."
/// )
///
/// - Tip: See <doc://com.apple.documentation/documentation/visionos/designing-realitykit-content-with-reality-composer-pro>  for more details on working with components in Reality Composer Pro.
///
/// At runtime, your app can access and play the animations that the entity stores.
///
///```swift
/// // Load the entity you want to animate.
/// let robot = try await Entity(named: "robot")
///
/// // Access the animation library associated with the entity.
/// let animationLibrary = robot.components[AnimationLibraryComponent.self]
///
/// // Play the walk animation.
/// if let walkAnimation = animationLibrary.animations["walk"] {
///     robot.playAnimation(walkAnimation)
/// }
/// ```
///
/// ### Create an animation library by building your own tool
///
/// If you need to build a custom tool to create `.reality` files, you can use RealityKit to programmatically
/// create an animation library by following these steps:
/// 1. Load an animation entity with ``Entity/init(named:in:)``.
/// 2. Retrieve the entity's animation resources from its ``Entity/availableAnimations`` property.
/// 3. Add the animations to an animation library.
///
/// The following example shows how you can set up an animation library:
///
/// ```swift
/// // Create an empty animation library component.
/// var animationLibrary = AnimationLibraryComponent()
///
/// // Load the entities containing the animations.
/// let entityIdleAnimation = try await Entity(named: "idle")
/// let entityWalkAnimation = try await Entity(named: "walk")
///
/// // Assign the animations to the library by name.
/// animationLibrary.animations["idle"] = entityIdleAnimation.availableAnimations.first
/// animationLibrary.animations["walk"] = entityWalkAnimation.availableAnimations.first
/// ```
///
/// After you configure the animation library, you can assign it to an entity and serialize the entity to a file.
/// RealityKit packages the animations for that entity when you save it to a `.reality` file.
///
/// ```swift
/// // Load the entity you want to animate.
/// let robot = try! await Entity(named: "robot")
///
/// // Assign the animation library to the entity.
/// robot.components.set(animationLibrary)
///
/// // Write the entity with its animations to a file.
/// robot.write(to: fileURL)
/// ```
///
/// To play one of the animations in your app, create an entity
/// from the `.reality` file and then call its ``Entity/playAnimation(_:transitionDuration:startsPaused:)`` method.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct AnimationLibraryComponent : Component, ExpressibleByDictionaryLiteral {

    /// Creates an animation library from a variadic list of key-value pairs.
    ///
    /// - Parameter elements: A list of key-value pairs that make up the dictionary.
    ///   Each key is a unique animation name, and each value is an animation resource.
    ///
    /// Use the
    /// <doc://com.apple.documentation/documentation/swift/expressiblebydictionaryliteral>
    /// initializer by directly assigning the library to a dictionary literal.
    ///
    /// ```swift
    /// let animationLibrary: AnimationLibraryComponent = [
    ///     "idle": idleAnimation,
    ///     "walk": walkAnimation
    /// ]
    /// ```
    public init(dictionaryLiteral elements: (String, AnimationResource)...)

    /// Creates an animation library from a dictionary that associates an animation’s data with its name.
    ///
    /// - Parameter animations: A dictionary of animation resources that you key by name.
    public init(animations: [String : AnimationResource])

    /// Creates an empty animation library.
    public init()

    /// The default animation resource. 
    ///
    /// The component looks up the resource by key if ``AnimationLibraryComponent/defaultKey``
    /// is non-`nil` and the library contains an animation that the key identifies.
    /// Otherwise, the component returns the first entry in the library.
    public var defaultAnimation: AnimationResource? { get }

    /// The name of the default animation resource. 
    ///
    /// Returns `nil` if you don't set a default animation, or if the component can't find it.
    public var defaultKey: String?

    /// Removes all the component's references to an animation resource.
    ///
    /// - Parameter resource: An animation resource with references that the component removes.
    public mutating func removeAll(resource: AnimationResource)

    /// The library's animation resources that don't have a queryable name.
    ///
    /// - Returns: An array of the animation resources that don't have a key; otherwise, `nil`.
    public var unkeyedResources: [AnimationResource]? { get }

    /// The collection of animations an entity can play.
    public var animations: AnimationLibraryComponent.AnimationCollection

    /// A collection of animations an entity can play.
    ///
    /// You use `AnimationCollection` to access animations in an
    /// ``AnimationLibraryComponent``.
    ///
    /// The initializers for ``AnimationLibraryComponent`` create an `AnimationCollection`,
    /// so you don't need to create one directly. You can access the collection with the
    /// ``AnimationLibraryComponent/animations`` property.
    public struct AnimationCollection : Collection {

        /// A key-value pair from the collection consisting of the name of an animation and the animation itself.
        public typealias Element = (key: String, value: AnimationResource)

        /// A sequence that represents a contiguous subrange of animations in the collection.
        public typealias SubSequence = Slice<AnimationLibraryComponent.AnimationCollection>

        /// Creates an animation collection from a dictionary literal.
        public init(dictionaryLiteral elements: (String, AnimationResource)...)

        /// The number of animations in the collection.
        public var count: Int { get }

        /// A Boolean value that indicates whether the collection is empty.
        public var isEmpty: Bool { get }

        /// An index to the first animation in the collection.
        public var startIndex: AnimationLibraryComponent.AnimationCollection.Index { get }

        /// An index to the last animation in the collection.
        public var endIndex: AnimationLibraryComponent.AnimationCollection.Index { get }

        /// Returns an iterator over the animations in the collection.
        public func makeIterator() -> AnimationLibraryComponent.AnimationCollection.Iterator

        /// Accesses a single animation in the collection with a key.
        /// - Parameter key: A name for the animation to look up.
        /// - Returns: An animation resource, or `nil` if the component can't find one that maps
        ///     to the `key`.
        public subscript(key: String) -> AnimationResource?

        /// Accesses animations in the collection within an index range.
        /// - Parameter bounds: A range of indices to look up.
        /// - Returns: A subsequence of animation resources in the range of `bounds`.
        public subscript(bounds: Range<AnimationLibraryComponent.AnimationCollection.Index>) -> AnimationLibraryComponent.AnimationCollection.SubSequence { get }

        /// Returns the position in the collection that follows an index.
        /// - Parameter i: A valid index of the collection. `i` must be less than `endIndex`.
        public func index(after i: AnimationLibraryComponent.AnimationCollection.Index) -> AnimationLibraryComponent.AnimationCollection.Index

        /// Replaces the index with its successor.
        public func formIndex(after i: inout AnimationLibraryComponent.AnimationCollection.Index)

        /// Accesses a single animation in the collection at an index.
        /// - Parameter position: An index into the collection's dictionary.
        /// - Returns: The animation at the dictionary index.
        public subscript(position: AnimationLibraryComponent.AnimationCollection.Index) -> AnimationLibraryComponent.AnimationCollection.Element { get }

        /// An object to iterate over all animations in the collection.
        public struct Iterator : IteratorProtocol {

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> AnimationLibraryComponent.AnimationCollection.Element?

            /// The type of element traversed by the iterator.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias Element = AnimationLibraryComponent.AnimationCollection.Element
        }

        /// An object that represents a position in the collection.
        public struct Index : Comparable, Hashable, Sendable {

            /// Returns a Boolean value indicating whether the first argument represents a position
            /// before the second argument.
            public static func < (lhs: AnimationLibraryComponent.AnimationCollection.Index, rhs: AnimationLibraryComponent.AnimationCollection.Index) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: AnimationLibraryComponent.AnimationCollection.Index, b: AnimationLibraryComponent.AnimationCollection.Index) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Indices = DefaultIndices<AnimationLibraryComponent.AnimationCollection>
    }

    /// The key type of a dictionary literal.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Key = String

    /// The value type of a dictionary literal.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Value = AnimationResource
}

/// A controller that manages animation playback.
///
/// This class controls the playback of an entity animation by providing its pause, resume, or stop functions.
/// 
/// The animation starts immediately after you call ``Entity/playAnimation(_:transitionDuration:startsPaused:)``, or ``Entity/move(to:relativeTo:duration:timingFunction:)-905k``, which both return an instance of this class.
///
/// A controller invalidates after its associated animation completes or stops. To play another animation, perform an action that generates another controller.
///
/// While an animation plays, you can receive notification of particular playback states by subscribing to an event. For more information, see ``AnimationEvents``.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class AnimationPlaybackController : Hashable {

    /// The entity to which the animation applies.
    @MainActor @preconcurrency weak public var entity: Entity? { get }

    /// A Boolean that indicates whether the animation is paused.
    @MainActor @preconcurrency public var isPaused: Bool { get }

    /// A Boolean that indicates whether the animation has finished running.
    ///
    /// After an animation completes, the playback controller becomes invalid.
    /// To play the animation again, create a new controller with the same
    /// resource.
    @MainActor @preconcurrency public var isComplete: Bool { get }

    /// Indicates whether two animation playback controllers are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first controller to compare.
    ///
    ///   - rhs: The second controller to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two controllers are
    /// equal.
    @MainActor @preconcurrency public static func == (lhs: AnimationPlaybackController, rhs: AnimationPlaybackController) -> Bool

    /// Hashes the essential components of the controller by feeding them into
    /// the given hash function.
    ///
    /// - Parameters:
    ///   - hasher: The hash function to use when combining the components of the controller.
    @MainActor @preconcurrency public func hash(into hasher: inout Hasher)

    /// Pauses the animation.
    ///
    /// Resume a paused animation by calling the
    /// ``AnimationPlaybackController/resume()`` method.
    ///
    /// This method has no effect if the animation is already paused or
    /// complete.
    @MainActor @preconcurrency public func pause()

    /// Resumes a paused animation.
    ///
    /// Call this method to resume an animation that you paused with the
    /// ``AnimationPlaybackController/pause()`` method. You can’t resume an
    /// animation that has finished naturally, or that you stopped by calling
    /// the ``AnimationPlaybackController/stop()`` method.
    ///
    /// This method has no effect on an animation that isn’t paused.
    @MainActor @preconcurrency public func resume()

    /// Stops an animation.
    ///
    /// This method has no effect if the animation is complete. After you stop
    /// the animation, the playback controller becomes invalid. Create a new one
    /// with the same resource to play the animation again.
    @MainActor @preconcurrency public func stop()

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    nonisolated public var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, *)
extension AnimationPlaybackController {

    /// A Boolean value that indicates whether the animation controller is
    /// functional.
    ///
    /// This function returns `false` for stopped animations.
    @MainActor @preconcurrency public var isValid: Bool { get }

    /// A Boolean value that indicates whether the animation plays.
    @MainActor @preconcurrency public var isPlaying: Bool { get }

    /// A Boolean value that indicates whether the animation stopped.
    ///
    /// This function returns `true` for stopped animations.
    @MainActor @preconcurrency public var isStopped: Bool { get }

    /// The animation's rate of playback.
    ///
    /// The animation applies the value of this property as an irrational factor
    /// of the unaltered speed. For example, a value of `2` plays the animation
    /// twice as fast, a value of `0.5` plays the animation at half speed, and a
    /// value of `1` plays the animation at the unaltered rate.
    @MainActor @preconcurrency public var speed: Float

    /// The animation's location within the timeline.
    @MainActor @preconcurrency public var time: TimeInterval

    /// The level of influence the controller gives to its animation.
    ///
    /// You can run multiple animations on the same property, for example,
    /// walking and jumping animations that affect the same joint transforms.
    /// When multiple animations adjust the same property at runtime, the
    /// framework applies this blend factor on the animations' respective
    /// controllers to calculate a middle ground value that displays at runtime.
    @MainActor @preconcurrency public var blendFactor: Float

    /// The length of time the animation spans, in seconds.
    @MainActor @preconcurrency public var duration: TimeInterval { get }

    /// A reference clock to synchronize the animation with other events.
    @MainActor @preconcurrency public var clock: CMClockOrTimebase
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AnimationPlaybackController {

    /// Stops an animation with a fade-out time.
    ///
    /// - Parameters:
    ///   - blendOutDuration: Time (in seconds) to fade out the animation before it stops.
    ///
    /// This method has no effect if the animation is complete. After you stop
    /// the animation, the playback controller becomes invalid. Create a new one
    /// with the same resource to play the animation again.
    @MainActor @preconcurrency public func stop(blendOutDuration: TimeInterval)
}

@available(macOS 10.15, iOS 13.0, *)
extension AnimationPlaybackController : Sendable {
}

/// Options that determine whether an animation replays after completion.
///
/// Adopters of ``AnimationDefinition``, such as ``SampledAnimation``, offer
/// repeat options of this type through the ``SampledAnimation/repeatMode``
/// property.
///
/// To select a behavior, set the repeat mode as you configure your animation,
/// as in the following example:
///
/// ```swift
/// let clip = FromToByAnimation<Transform>()
/// clip.repeatMode = .repeat
/// ```
@available(macOS 12.0, iOS 15.0, *)
public enum AnimationRepeatMode {

    /// An option that determines the animation doesn't repeat.
    case none

    /// A mode that restarts the animation after it completes.
    ///
    /// This mode restores the animated property to its initial value each time
    /// it restarts. For example, a ``FromToByAnimation`` with
    /// ``FromToByAnimation/fromValue-umpp`` `=` `1.0`,
    /// ``FromToByAnimation/toValue-4m4pm`` `=` `2.0` and
    /// ``FromToByAnimation/repeatMode`` set to this property repeats as, `1.0`,
    /// `2.0`, `1.0`, `2.0`, `1.0`, `2.0` and so on.
    case `repeat`

    /// A mode that repeats indefinitely and begins each repetition by setting
    /// the animated property to the ending value of the previous repetition.
    ///
    /// A ``FromToByAnimation`` with a ``FromToByAnimation/fromValue-umpp`` of
    /// `1.0` and an ``FromToByAnimation/toValue-4m4pm`` of `2.0` and
    /// ``FromToByAnimation/repeatMode`` set to this property repeats as, `1.0`,
    /// `2.0`, 3`.0`, 4`.0`, `5.0`, and so on.
    case cumulative

    /// A mode that reverses the animation after reaching the end or the
    /// beginning.
    case autoReverse

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AnimationRepeatMode, b: AnimationRepeatMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, *)
extension AnimationRepeatMode : Equatable {
}

@available(macOS 12.0, iOS 15.0, *)
extension AnimationRepeatMode : Hashable {
}

/// An animation for the properties of scenes or entities.
///
/// You find animation resources in an entity’s ``Entity/availableAnimations`` array.
/// Animation resources come bundled with an entity when you load the
/// entity from a file. They describe an animation that’s specific to the entity
/// to which they are attached.
///
/// Use the entity’s ``Entity/playAnimation(_:transitionDuration:startsPaused:)``
/// method to play a particular item in its animation resource array, or the
/// `playAnimation(named:transitionDuration:startsPaused:)` method to play all
/// of the animations with a given name. From both methods, you receive an
/// ``AnimationPlaybackController`` instance that lets you manage playback of
/// the resource.
///
/// If you want to loop an animation, call the resource’s
/// ``AnimationResource/repeat(count:)`` method to create a new resource that
/// plays a given number of times in a row, or call the
/// ``AnimationResource/repeat(duration:)`` method to create a new resource that
/// loops for the given duration. The latter loops indefinitely if you omit the
/// duration parameter. You use the new animation resource that these methods
/// return just as you would any other.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class AnimationResource : Resource {

    /// The name of the animation resource.
    ///
    /// You can get an ``AnimationPlaybackController`` instance ready to play a
    /// particular resource that you reference by its name using the
    /// `playAnimation(named:transitionDuration:startsPaused:)` method.
    @MainActor @preconcurrency final public let name: String?
}

@available(macOS 10.15, iOS 13.0, *)
extension AnimationResource {

    /// Repeats an animation for the specified amount of time.
    ///
    /// - Parameters:
    ///   - duration: The amount of time that the animation should play. If you
    ///     omit this parameter, the animation loops indefinitely.
    ///
    /// - Returns: A new animation resource that you play on an entity by
    ///     calling the entity’s
    ///     ``Entity/playAnimation(_:transitionDuration:startsPaused:)`` method.
    @MainActor @preconcurrency public func `repeat`(duration: TimeInterval = .infinity) -> AnimationResource

    /// Creates an animation that repeats the specified number of times.
    ///
    /// - Parameters:
    ///   - count: The number of animation repetitions.
    ///
    /// - Returns: A repeating copy of the calling animation resource.
    @MainActor @preconcurrency public func `repeat`(count: Int) -> AnimationResource
}

@available(macOS 12.0, iOS 15.0, *)
extension AnimationResource {

    /// Creates an animation resource that simultaneously plays back a
    /// collection of animations.
    ///
    /// - Parameters:
    ///   - resources: The collection of animation resources to play back.
    ///
    /// - Returns: An animation resource that simultaneously plays back the
    /// argument collection of animations.
    @MainActor @preconcurrency public static func group(with resources: [AnimationResource]) throws -> AnimationResource

    /// Creates an animation resource that plays a collection of animations in a
    /// specified sequence.
    ///
    /// - Parameters:
    ///   - resources: The collection of animation resources to play.
    ///
    /// - Returns: An animation resource that plays the given array of
    /// animations.
    @MainActor @preconcurrency public static func sequence(with resources: [AnimationResource]) throws -> AnimationResource

    /// Creates an animation resource from a definition.
    ///
    /// - Parameters:
    ///   - definition: The configuration of a timeframe and visual semantics from
    ///     which to generate an animation resource.
    ///
    /// - Returns: An animation resource that shares the configuration of the definition.
    @MainActor @preconcurrency public static func generate(with definition: any AnimationDefinition) throws -> AnimationResource

    /// Adds the animation to an entity without playing it.
    ///
    /// - Parameters:
    ///   - in: The entity to which to attach the animation.
    @MainActor @preconcurrency public func store(in: Entity)

    /// The timeframe, target object, and visual semantics of the animation.
    @MainActor @preconcurrency public var definition: any AnimationDefinition { get }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension AnimationResource {

    /// Creates an action animation containing a single event definition from an action.
    ///
    /// - Parameters:
    ///   - action: The user action.
    ///   - duration: The event interval's duration.
    ///   - name: A textual name for the animation.
    ///   - bindTarget: A textual name that identifies the particular property that animates.
    ///   - blendLayer: An integer that specifies the order in which to apply animations when more than one animation is playing.
    ///   - repeatMode: An option that determines how the animation repeats.
    ///   - fillMode: An option that determines how the animation repeats.
    ///   - trimStart: The optional time, in seconds, at which the animation plays.
    ///   - trimEnd: The optional time, in seconds, at which the animation stops.
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///   - delay: An amount of time that lapses before the animation plays.
    ///   - speed: A factor that changes the animation’s rate of playback.
    /// - Returns: An animation resource to play the given action.
    ///
    /// - Note: Duration is clamped to a positive, small non zero value, if duration is zero or less.
    @MainActor @preconcurrency public static func makeActionAnimation<T>(for action: T, duration: TimeInterval = 1.0, name: String = "", bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0) throws -> AnimationResource where T : EntityAction
}

/// The concretely typed animation state structure.
///
/// Access the animation state structure from the event structure returned to  the action's `.updated`
/// event handler. Define a valid bind target and matching animation type for the action
/// animation to make the state structure available and non-nil.
///
/// (See: ``AnimationStateProtocol``)
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct AnimationState<Value> : AnimationStateProtocol where Value : AnimatableData {

    /// See: ``AnimationStateProtocol/defaultSource``
    public var defaultSource: Value? { get }

    /// See: ``AnimationStateProtocol/defaultTarget``
    public var defaultTarget: Value? { get }

    /// See: ``AnimationStateProtocol/storeAnimatedValue(_:)``
    @discardableResult
    public func storeAnimatedValue<ValueType>(_ value: ValueType) -> Bool

    /// See: ``AnimationStateProtocol/deltaTime``
    public let deltaTime: TimeInterval

    /// See ``AnimationStateProtocol/evaluationTime``
    public let evaluationTime: TimeInterval

    /// See ``AnimationStateProtocol/normalizedTime``
    public let normalizedTime: TimeInterval

    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias ValueType = Value
}

/// Animation state specialization for skeletal animation.
///
/// See: ``AnimationStateProtocol``
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension AnimationState where Value == JointTransforms {

    /// Returns the  joint transforms representing the default source value.
    ///
    /// See  ``AnimationStateProtocol/defaultSource`` for  more about the default source value.
    public var defaultSource: JointTransforms? { get }

    /// Retrieves a subset of default source joints, and stores them in the output transform array.
    ///
    /// See ``AnimationStateProtocol/defaultSource`` for more about the default source value.
    public func defaultSourceJoints(index: Int, count: Int, transforms: inout [Transform]) -> Bool

    /// Returns the joint transforms representing the default target value.
    ///
    /// See: ``AnimationStateProtocol/defaultTarget``
    public var defaultTarget: JointTransforms? { get }

    /// Retrieves a subset of default target joints, and stores them in the output transform array.
    ///
    /// See ``AnimationStateProtocol/defaultTarget`` for more about the default target value.
    public func defaultTargetJoints(index: Int, count: Int, transforms: inout [Transform]) -> Bool

    /// Stores a subset of animated joints.
    ///
    /// See ``AnimationStateProtocol/storeAnimatedValue(_:)`` for more about returning an animation result to the animation system.
    @discardableResult
    public func storeAnimatedJoints(transforms: [Transform], jointIndex: Int) -> Bool
}

/// The protocol representing the current animation state of an action animation.
///
/// The animation state allows actions to animate a target value using RealityKit's animation engine.
///
/// Animating values with the animation engine allows for cross-fading and additive compositing
/// with other RealityKit animations targeting the same value.
///
/// Access the animation state structure from the event structure returned
/// to `.updated` event handlers. Define a valid bind target and matching animation type
/// to make the state structure available and non nil.
///
/// - Note: Custom actions don't support animating ``BlendShapeWeights``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public protocol AnimationStateProtocol {

    associatedtype ValueType : AnimatableData

    /// The previous blend stage value.
    ///
    /// The default source is the value output from the
    /// previous blend stage, and initialized with ``AnimationStateProtocol/defaultTarget``
    /// for the first stage.
    var defaultSource: Self.ValueType? { get }

    /// The default unanimated value of the target.
    ///
    /// The default target is the snapshot value of the animation target at the time
    /// the animation first plays. The system takes a snapshot of the animation target's value
    /// before starting the new animation. This is controlled by setting different
    /// handoff behaviors when the animation is played.
    ///
    /// If no snapshot was taken, `defaultTarget` will be the unanimated value
    /// when playback uses `separateAnimatedValue: true`. 
    ///
    /// Setting `separatedAnimatedValue: true`
    /// directs the animation system to maintain the unanimated value.
    /// 
    /// Otherwise, if there is no snapshot, and the unanimated value is not maintained,
    /// `defaultTarget` will be 0 or identity depending on the target's type.
    var defaultTarget: Self.ValueType? { get }

    /// The time that has elapsed since the most recent evaluation,
    /// or 0 if animation is paused.
    var deltaTime: TimeInterval { get }

    /// The time at which the animation result should be evaluated.
    var evaluationTime: TimeInterval { get }

    /// The normalized time ranges from 0 to 1, and is the time at which the animation
    /// result should be evaluated.
    var normalizedTime: TimeInterval { get }

    /// Stores the action's animated value, which the animation manager uses
    /// to produce a final animated result.
    /// Returns true on success, otherwise false.
    @discardableResult
    func storeAnimatedValue<ValueType>(_ value: ValueType) -> Bool
}

/// The pacing of an animation transition.
///
/// Use an animation timing function to control the pace of an animation
/// transition when you call one of an entity’s animated move methods, like
/// ``Entity/move(to:relativeTo:duration:timingFunction:)-905k``. If you omit a
/// timing function from the call, the method uses the
/// ``AnimationTimingFunction/default`` timing function.
@available(macOS 10.15, iOS 13.0, *)
public struct AnimationTimingFunction : Hashable {

    /// A timing function that produces the default curve for the transition.
    public static var `default`: AnimationTimingFunction { get }

    /// A timing function that produces a linear transition.
    public static var linear: AnimationTimingFunction { get }

    /// A timing function that produces a gradual starting transition.
    public static var easeIn: AnimationTimingFunction { get }

    /// A timing function that produces a gradual ending transition.
    public static var easeOut: AnimationTimingFunction { get }

    /// A timing function that produces a gradual starting and ending
    /// transition.
    public static var easeInOut: AnimationTimingFunction { get }

    /// Creates a timing function that accelerates and then decelerates towards
    /// the target value with the cubic bezier shape specified by two control
    /// points.
    ///
    /// - Parameters:
    ///   - controlPoint1: The first control point for the cubic bezier function.
    ///
    ///   - controlPoint2: The second control point for the cubic bezier function.
    ///
    /// - Returns: The cubic bezier timing function.
    public static func cubicBezier(controlPoint1: SIMD2<Float>, controlPoint2: SIMD2<Float>) -> AnimationTimingFunction

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AnimationTimingFunction, b: AnimationTimingFunction) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension AnimationTimingFunction : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

/// An animation that represents a variation of another animation.
///
/// This structure creates a variation of an existing animation by overriding
/// its configuration. The term _view_ in the name signifies that the variation
/// represents a new visual perspective of the existing animation.
///
/// ### Create a clip of an animation
///
/// By supplying a new beginning time (``AnimationView/trimStart``) and ending
/// time (``AnimationView/trimEnd``), the following code creates a shorter clip
/// of an existing animation. With ``AnimationView/trimStart`` set to `1.0` and
/// ``AnimationView/trimEnd`` at `2.0`, the clip spans a one-second duration.
///
/// ```swift
/// // Create or access an existing animation.
/// let anim1 = FromToByAnimation<Float>(name: "Anim1",
///     from: 100.0, to: 200.0, duration: 10.0)
///
/// // Use a view to create a clip of the original animation.
/// let view = AnimationView(source: anim1,
///     name: "clip",
///     bindTarget: nil,
///     blendLayer: 0,
///     repeatMode: .autoReverse,
///     fillMode: [],
///     trimStart: 1.0,
///     trimEnd: 2.0,
///     trimDuration: nil,
///     offset: 0,
///     delay: 0,
///     speed: 1.0)
///
/// // Create an animation resource from the clip.
/// clipResource = try? AnimationResource.generate(with: view)
///
/// // Play the clip.
/// myModelEntity.playAnimation(clipResource)
/// ```
///
/// ### Define a view in relation to the animation source
///
/// The source animation's timing properties define a _timeline_ on which the
/// ``AnimationView/trimDuration``, ``AnimationView/delay``, and
/// ``AnimationView/speed`` properties operate to derive the view. The
/// ``AnimationView/trimDuration`` property specifies which animation data the
/// view displays. If ``AnimationView/trimDuration`` exceeds the length of the
/// source animation’s timeline, the animation plays according to the
/// characteristics of ``AnimationView/repeatMode``. The ``AnimationView/delay``
/// property defines a waiting period before the animation begins, and the
/// ``AnimationView/speed`` determines how fast the view plays in relation to
/// the original pace.
@available(macOS 12.0, iOS 15.0, *)
public struct AnimationView : AnimationDefinition {

    /// A textual name for the animation.
    public var name: String

    /// The order in which the framework composites the animation.
    ///
    /// The framework applies multiple animations on the same target in
    /// ascending order of this property’s value. Animations in a lower layer
    /// run before animations in a higher layer. Animations that share the same
    /// value apply in the order that they execute.
    public var blendLayer: Int32

    /// An option that determines which data displays outside of the normal
    /// duration.
    ///
    /// This property determines what to display when the framework samples the
    /// animation outside of the range defined by its underlying duration. The
    /// animation applies this property when:
    ///
    /// - Playback progresses toward, but hasn't yet reached, a nonzero
    /// ``AnimationView/offset``. - A range determined by
    /// ``AnimationView/trimStart``, ``AnimationView/trimEnd``, or
    /// ``AnimationView/trimDuration`` exceeds the animation's underlying
    /// duration.
    public var fillMode: AnimationFillMode

    /// A textual name that identifies the animated property.
    ///
    /// The property name is a key path. For more information on key paths, see
    /// <doc://com.apple.documentation/documentation/swift/swift_standard_library/key-path_expressions>.
    public var bindTarget: BindTarget

    /// The time, in seconds, at which the source animation plays.
    ///
    /// This property is `nil` by default, which plays the animation with `time`
    /// = `0`. If you set a value, the animation edits the duration according to
    /// the specified beginning time.
    ///
    /// If you set a negative value for this property, the duration increases
    /// and the additional animation data fills in based on the
    /// ``AnimationView/fillMode`` you choose.
    public var trimStart: TimeInterval?

    /// The time, in seconds, at which the source animation stops.
    ///
    /// This property is `nil` by default, which plays the animation until
    /// `time` = ``AnimationView/duration``. If you set a value, the animation
    /// edits the duration according to the specified ending time.
    public var trimEnd: TimeInterval?

    /// An optional duration that overrides the calculated duration.
    ///
    /// The framework calculates ``FromToByAnimation/duration``, but you can set
    /// this property to override it. This property is `nil` by default, which
    /// indicates that the animation stops after one play that spans
    /// ``AnimationView/duration``.
    ///
    /// If you set a value for this property and both
    /// ``AnimationView/trimStart`` and ``AnimationView/trimEnd`` are `nil`, the
    /// animation observes this property as an edited duration.
    ///
    /// A value greater than ``AnimationView/duration`` causes the animation to
    /// repeat, applying the characteristics defined by
    /// ``AnimationView/repeatMode``. Assign this property
    /// <doc://com.apple.documentation/documentation/swift/double/1849607-greatestfinitemagnitude>
    /// to repeat indefinitely.
    public var trimDuration: TimeInterval?

    /// The time, in seconds, at which the animation begins within the duration.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no offset. Setting a value for this property moves the animation data
    /// along the timeline and doesn't change timing. If you set a
    /// ``SampledAnimation/fillMode`` other than ``AnimationFillMode/none``, the
    /// animation fills the vacant area created by the offset according to the
    /// characteristics of the specified fill mode.
    public var offset: TimeInterval

    /// An amount of time that lapses before the animation plays.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no delay. If you set a value for this property, the animation plays from
    /// its start time after the specified delay lapses.
    ///
    /// During the delayed time, the animation doesn't update. However, to fill
    /// the delayed time with some portion of animation, set a negative
    /// ``AnimationView/trimStart`` instead and choose a
    /// ``AnimationView/fillMode`` that displays the desired portion of
    /// animation.
    public var delay: TimeInterval

    /// A factor that increases or decreases the animation’s rate of playback.
    ///
    /// The default value is `1.0`, which doesn’t alter the animation’s
    /// duration. A value of `2.0` indicates that the duration is half the
    /// underlying setting. A value of `0.5` indicates that the duration is
    /// twice the underlying setting. Negative values play the animation in
    /// reverse.
    ///
    /// This property doesn’t affect the animation’s ``AnimationView/delay``.
    public var speed: Float

    /// An option that determines how the animation repeats.
    ///
    /// If you call ``AnimationView/trimmed(start:end:duration:)`` with a
    /// `start` or `end` that lies outside of the timeline defined by
    /// ``AnimationView/duration``, the animation fills the additional playback
    /// by applying this property.
    public var repeatMode: AnimationRepeatMode

    /// The original animation that this structure modifies.
    public var source: (any AnimationDefinition)?

    /// The total playback time of the animation.
    ///
    /// The framework sets a value for this property depending on the underlying
    /// animation data and the specified ``AnimationView/speed``.
    ///
    /// You can override the default duration by defining
    /// ``AnimationView/trimStart``, ``AnimationView/trimEnd``, or
    /// ``AnimationView/trimDuration``.
    public var duration: TimeInterval { get }

    /// Creates a variation of the given animation by overriding its properties.
    ///
    /// - Parameters:
    ///   - source: The original animation that this structure modifies.
    ///
    ///   - name: A textual name for the animation.
    ///
    ///   - bindTarget: A textual name that identifies the animated property.
    ///
    ///   - blendLayer: The order in which the framework visually composites the
    ///     animation among other running animations.
    ///
    ///   - repeatMode: An option that determines how the animation repeats
    ///     outside the length of the view.
    ///
    ///   - fillMode: The behavior when the animated property reaches its end value.
    ///
    ///   - trimStart: The optional time, in seconds, at which the source animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the source animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that lapses before the animation plays.
    ///
    ///   - speed: A factor that increases or decreases the animation’s playback rate.
    public init(source: any AnimationDefinition, name: String = "", bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)
}

/// The rendering technique used to smooth edges of virtual content.
@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
public enum AntialiasingMode : Hashable, Sendable {

    /// Do not apply any technique to smooth jagged edges.
    ///
    /// This option has no performance cost.
    case none

    /// Multisampling renders each pixel multiple times and combines the results, creating a higher
    /// quality image at a performance cost proportional to the number of samples used.
    case multisample4X

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AntialiasingMode, b: AntialiasingMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Mesh buffer stored in the container.
@available(macOS 12.0, iOS 15.0, *)
public struct AnyMeshBuffer {

    public var id: MeshBuffers.Identifier { get }

    public var count: Int { get }

    public var rate: MeshBuffers.Rate { get }

    public var elementType: MeshBuffers.ElementType { get }

    public func get<Value>(_: Value.Type = Value.self) -> MeshBuffer<Value>?
}

/// A namespace for types that are used commonly in audio.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public enum Audio {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension Audio {

    /// The different ways that audio intensity diminishes as the distance between the listener and the sound source increases.
    public enum DistanceAttenuation {

        /// A standard geometric model for attenuating audio intensity naturally with distance, using a specified loss strength factor.
        ///
        /// - Parameter factor: The attenuation model's loss strength factor in the range of `[0, Double.infinity]`.
        ///
        /// The case's default value is `1.0`, which attenuates spatial audio as the listener moves away from the source, similar to real-world physics.
        /// You can increase or decrease this effect by changing `factor` to other values.
        /// For example:
        /// - `0.5` reduces the effect by 50%
        /// - `2.0` doubles the effect
        /// - `0.0` completely disables attenuation
        case rolloff(factor: Double)
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Audio {

    /// The unit for measuring intensity of sound on a logarithmic scale.
    public typealias Decibel = Double
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Audio {

    /// The radiation pattern of sound emitted from an entity.
    public enum Directivity {

        /// A parametric frequency-dependent radiation pattern, where the `focus` determines the width of a beam.
        ///
        /// The `focus` parameter is in the range `0...1` where `0` is the default. The default `.beam(focus: 0)`
        /// projects sound of all frequencies evenly in all directions, where the rotation of the spatial audio source has no impact on the
        /// tonality of the sound. A `focus` of `0` is commonly referred to as "omnidirectional".
        ///
        /// Increasing the `focus` parameter up to `1` will constrain the projection to increasingly narrow beam patterns, with high
        /// frequencies being more directional than low frequencies. A spatial audio source with a non-zero `focus` will sound
        /// "darker" when auditioning the source from the rear.
        case beam(focus: Double)
    }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension Audio {

    /// A handler that generates real-time audio.
    ///
    /// The audio format is ``Float32`` with a sample rate of ``48000``.
    ///
    /// - Note: The system executes your handler in a real-time audio thread.
    ///         Achieve optimal performance by ensuring the closure finishes quickly.
    ///         Avoid heap allocations or locks within the closure.
    public typealias GeneratorRenderHandler = AVAudioSourceNodeRenderBlock
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension Audio.DistanceAttenuation {

    /// The default distance attenuation, which uses a rolloff model that mimics real-world physics.
    ///
    /// The ``Audio/DistanceAttenuation/rolloff(factor:)`` model attenuates spatial audio with a factor of `1.0` as the listener moves away from the source.
    public static let `default`: Audio.DistanceAttenuation
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension Audio.DistanceAttenuation : Equatable, Hashable, Codable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Audio.DistanceAttenuation, b: Audio.DistanceAttenuation) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Audio.Directivity : Equatable, Hashable, Codable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Audio.Directivity, b: Audio.Directivity) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// An audio resource that you load from an <doc://com.apple.documentation/documentation/avfaudio/avaudiobuffer>.
///
/// Use the resource to create an ``AudioPlaybackController`` instance by calling an entity’s ``Entity/prepareAudio(_:)`` or ``Entity/playAudio(_:)`` function.
/// The controller plays the audio from the location in space of the entity that created the controller.
@available(macOS 12.0, iOS 15.0, *)
@MainActor @preconcurrency public class AudioBufferResource : AudioResource {

    /// The configuration for this `AudioBufferResource`.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency final public let configuration: AudioBufferResource.Configuration

    /// Creates an `AudioBufferResource` with the given `AVAudioBuffer` and configuration.
    ///
    /// - Throws: An error if the given `buffer` is not or cannot be converted to a non-interleaved PCM buffer.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public init(buffer: AVAudioBuffer, configuration: AudioBufferResource.Configuration = .init()) throws

    /// Whether or not this file loops during playback. This should be set for assets
    /// that are prepared as seamless loops. A looping resource will play forever until it is
    /// explicitly told to stop.
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "Use AudioBufferResource.init(buffer:configuration:) instead.")
    @available(macOS, deprecated: 15.0, message: "Use AudioBufferResource.init(buffer:configuration:) instead.")
    @available(macCatalyst, deprecated: 18.0, message: "Use AudioBufferResource.init(buffer:configuration:) instead.")
    @available(iOS, deprecated: 18.0, message: "Use AudioBufferResource.init(buffer:configuration:) instead.")
    @MainActor @preconcurrency public var shouldLoop: Bool { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioBufferResource {

    public struct Configuration {

        public var shouldLoop: Bool

        public var shouldRandomizeStartTime: Bool

        public var normalization: AudioResource.Normalization?

        public var calibration: AudioResource.Calibration?

        public var mixGroupName: String?

        public init(shouldLoop: Bool = false, shouldRandomizeStartTime: Bool = false, normalization: AudioResource.Normalization? = nil, calibration: AudioResource.Calibration? = nil, mixGroupName: String? = nil)
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioBufferResource : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    @MainActor @preconcurrency public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    nonisolated public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioBufferResource {

    /// The duration of this `AudioBufferResource`.
    @MainActor @preconcurrency public var duration: Duration { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioBufferResource.Configuration : Equatable, Hashable, Sendable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AudioBufferResource.Configuration, b: AudioBufferResource.Configuration) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Events associated with audio playback.
///
/// For more information on subscribing to scene events, see ``RealityKit/Scene/Event``.
@available(macOS 10.15, iOS 13.0, *)
public enum AudioEvents {

    /// Audio playback completed.
    public struct PlaybackCompleted : Event {

        /// The audio playback controller that triggered the event.
        public var playbackController: AudioPlaybackController
    }
}

/// An audio file group.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
@MainActor @preconcurrency public class AudioFileGroupResource : AudioResource {

    /// The `AudioFileResource` objects which comprise this `AudioFileGroupResource`.
    @MainActor @preconcurrency final public let resources: [AudioFileResource]

    /// Initializes an audio resource from a Reality Composer Pro project.
    ///
    /// This method initializes a preconfigured ``AudioFileGroupResource`` from a
    /// scene in a Reality Composer Pro project.
    ///
    /// - Important: The name provided **must** be unique.
    ///
    /// - Parameters:
    ///   - name: The USD Prim path to the resource in the Reality Composer Pro project to initialize.
    ///   - scene: The name of the Reality Composer Pro scene to initialize from.
    ///   - bundle: The bundle that contains the project.
    @MainActor @preconcurrency public convenience init(named name: String, from scene: String, in bundle: Bundle) async throws

    /// Creates a group resource from an array of audio file resources.
    ///
    /// An ``AudioFileGroupResource`` provides a single, random element from its collection of ``AudioFileResource`` objects each time
    /// ``AudioPlaybackController/play()`` is called on the ``AudioPlaybackController`` on which it is prepared.
    ///
    /// - Throws: An error if the provided array is empty or if the underlying audio assets do not have matching channel layouts.
    @MainActor @preconcurrency public init(_ resources: [AudioFileResource]) throws

    @MainActor @preconcurrency public static func == (lhs: AudioFileGroupResource, rhs: AudioFileGroupResource) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileGroupResource {

    /// Loads an audio resource from a Reality Composer Pro project.
    ///
    /// This method loads a preconfigured ``RealityKit/AudioFileGroupResource`` from a
    /// scene in a Reality Composer Pro project.
    ///
    /// - Important: The name provided **must** be unique.
    ///
    /// - Parameters:
    ///   - name: The USD Prim path to the resource in the Reality Composer Pro project to load.
    ///   - scene: The name of the Reality Composer Pro scene to load from.
    ///   - bundle: The bundle that contains the project. Leave `nil` to load from the app's bundle.
    @MainActor @preconcurrency public static func load(named name: String, from scene: String, in bundle: Bundle? = nil) throws -> AudioFileGroupResource
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileGroupResource : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    @MainActor @preconcurrency public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    nonisolated public var hashValue: Int { get }
}

/// An audio resource that you load from a file or from a URL.
///
/// Load an audio file resource, like an audio file stored in .aiff or other format, by calling one of the load functions.
/// Use the resource to create an ``AudioPlaybackController`` instance by calling an entity’s ``Entity/prepareAudio(_:)`` or ``Entity/playAudio(_:)`` function.
/// The controller plays the audio from the location in space of the entity that created the controller.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class AudioFileResource : AudioResource {

    /// The name of this `AudioFileResource`.
    @MainActor @preconcurrency final public let name: String

    /// The configuration of this `AudioFileResource`.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency final public let configuration: AudioFileResource.Configuration

    /// The resource's memory model.
    @available(visionOS, introduced: 2.0, deprecated: 1.0, message: "Use configuration.loadingStrategy instead.")
    @available(macOS, introduced: 10.15, deprecated: 15.0, message: "Use configuration.loadingStrategy instead.")
    @available(macCatalyst, introduced: 13, deprecated: 18.0, message: "Use configuration.loadingStrategy instead.")
    @available(iOS, introduced: 13, deprecated: 18.0, message: "Use configuration.loadingStrategy instead.")
    @MainActor @preconcurrency public var loadingStrategy: AudioFileResource.LoadingStrategy

    /// Whether or not this file loops during playback. This should be set for assets
    /// that are prepared as seamless loops. A looping resource will play forever until it is
    /// explicitly told to stop.
    @available(visionOS, introduced: 2.0, deprecated: 1.0, message: "Use configuration.shouldLoop instead.")
    @available(macOS, introduced: 10.15, deprecated: 15.0, message: "Use configuration.shouldLoop instead.")
    @available(macCatalyst, introduced: 13, deprecated: 18.0, message: "Use configuration.shouldLoop instead.")
    @available(iOS, introduced: 13, deprecated: 18.0, message: "Use configuration.shouldLoop instead.")
    @MainActor @preconcurrency public var shouldLoop: Bool
}

@available(macOS 10.15, iOS 13.0, *)
extension AudioFileResource {

    /// A container for different strategies on how to handle resources' data before and during playback.
    public enum LoadingStrategy {

        /// Stream data from disk, decoding in real time.
        case stream

        /// Load and decode all the data into memory before playback.
        case preload
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileResource : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    @MainActor @preconcurrency public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    nonisolated public var hashValue: Int { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension AudioFileResource {

    /// The duration of this `AudioFileResource`.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public var duration: Duration { get }

    @MainActor @preconcurrency public static func == (lhs: AudioFileResource, rhs: AudioFileResource) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileResource {

    /// Initializes an AudioFileResource asynchronously.
    ///
    /// - Important: The name provided **must** be unique.
    @MainActor @preconcurrency public convenience init(named name: String, in bundle: Bundle? = nil, configuration: AudioFileResource.Configuration = .init()) async throws

    /// Initializes a preconfigured AudioFileResource asynchronously from a Reality Composer Pro project
    /// with the given `name` as the the prim-path of the AudioFile, and the `scene` as
    /// the name of the USD file name.
    ///
    /// - Important: The name provided **must** be unique.
    @MainActor @preconcurrency public convenience init(named name: String, from scene: String, in bundle: Bundle? = nil) async throws

    /// Initializes an AudioFileResource asynchronously.
    ///
    /// - Important: The name provided **must** be unique.
    @MainActor @preconcurrency public convenience init(contentsOf url: URL, withName resourceName: String? = nil, configuration: AudioFileResource.Configuration = .init()) async throws
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileResource {

    /// A container for various settings for loading an audio file resource.
    public struct Configuration {

        /// Stores the strategy the system uses for handling
        /// an audio resource's data before and during playback.
        public var loadingStrategy: AudioFileResource.LoadingStrategy

        /// Stores a Boolean indicating whether the playback loops infinitely,
        /// until manually stopped or paused.
        public var shouldLoop: Bool

        /// Stores a Boolean indicating whether the playback begins from the start
        /// of the file, or from a random position.
        ///
        /// When this property and ``shouldLoop`` are both true,
        /// only the first playback iteration begins from a random position.
        public var shouldRandomizeStartTime: Bool

        /// Stores the normalization portion of the configuration.
        public var normalization: AudioResource.Normalization?

        /// Stores the calibration setting that the system applies to
        /// the audio resource, ensuring optimal playback quality.
        public var calibration: AudioResource.Calibration?

        /// An arbitrary name that can assigns an audio resource to an audio mix group.
        ///
        /// See ``AudioMixGroup`` and ``AudioMixGroupsComponent`` for more information.
        public var mixGroupName: String?

        /// Initializes a new audio file resource configuration.
        public init(loadingStrategy: AudioFileResource.LoadingStrategy = .preload, shouldLoop: Bool = false, shouldRandomizeStartTime: Bool = false, normalization: AudioResource.Normalization? = nil, calibration: AudioResource.Calibration? = nil, mixGroupName: String? = nil)
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileResource {

    /// Loads an AudioFileResource synchronously.
    ///
    /// - Important: The name provided **must** be unique.
    @MainActor @preconcurrency public static func load(contentsOf url: URL, withName name: String? = nil, configuration: AudioFileResource.Configuration = .init()) throws -> AudioFileResource

    /// Loads an AudioFileResource synchronously.
    ///
    /// - Important: The name provided **must** be unique.
    @MainActor @preconcurrency public static func load(named name: String, in bundle: Bundle? = nil, configuration: AudioFileResource.Configuration = .init()) throws -> AudioFileResource

    /// Loads a preconfigured AudioFileResource from a Reality Composer Pro project with the given
    /// `name` as the the prim-path of the AudioFile, and the `scene` as the name of the
    /// USD file name.
    ///
    /// - Important: The name provided **must** be unique.
    @MainActor @preconcurrency public static func load(named name: String, from scene: String, in bundle: Bundle? = nil) throws -> AudioFileResource
}

@available(macOS 10.15, iOS 13.0, *)
extension AudioFileResource.LoadingStrategy : Hashable {
}

@available(macOS 12.0, iOS 15.0, *)
extension AudioFileResource.LoadingStrategy : Codable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileResource.LoadingStrategy : Sendable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileResource.LoadingStrategy : RawRepresentable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: String { get }

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: String)

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
    public typealias RawValue = String
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioFileResource.Configuration : Equatable, Hashable, Sendable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AudioFileResource.Configuration, b: AudioFileResource.Configuration) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A container for various settings for preparing and playing an AudioGeneratorController.
@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
public struct AudioGeneratorConfiguration {

    /// The format in which the audio channels are specified.
    public var layoutTag: AudioChannelLayoutTag

    /// An arbitrary name that assigns an audio resource to an audio mix group.
    ///
    /// See ``AudioMixGroup`` and ``AudioMixGroupsComponent`` for more information.
    ///
    /// - Note: The mix group name needs to match a mix group component in the same scene.
    public var mixGroupName: String?

    public init(layoutTag: AudioChannelLayoutTag = kAudioChannelLayoutTag_Mono, mixGroupName: String? = nil)
}

/// A controller that manages the playback of a real-time audio stream.
///
/// To receive an audio generator controller, call an entity's
/// ``Entity/prepareAudio(configuration:_:)`` or ``Entity/playAudio(configuration:_:)`` method.
///
/// The following examples show how you can use the controller:
///
/// ```objc
/// /// myHandler.mm
/// AVAudioSourceNodeRenderBlock myHandler = ^OSStatus(BOOL *isSilence,
///                                                    const AudioTimeStamp *timestamp,
///                                                    AVAudioFrameCount frameCount,
///                                                    AudioBufferList *outputData) {
///
///    double phase = FREQUENCY * timestamp->mSampleTime * (1.f / SAMPLE_RATE);
///    for (int idx = 0; idx < frameCount; idx++) {
///        ((Float32 *)outputData->mBuffers[0].mData)[idx] = sin(phase * 2.f * M_PI) * 0.5;
///        phase += (FREQUENCY / SAMPLE_RATE);
///    }
///
///    return 0;
/// };
/// ```
///
/// ```swift
/// // Create a configuration.
/// var config = AudioGeneratorConfiguration(kAudioChannelLayoutTag_Mono)
///
/// // Prepare a closure that you define in myHandler.mm.
/// var controller = myEntity.prepareAudio(configuration: config, myHandler)
///
/// controller.gain = -3.0
/// controller.play()
/// ```
///
/// During playback, the audio appears to come from the entity that you use to
/// create the controller. As a person moves around the MR scene, RealityKit
/// modulates the characteristics of the audio to account for their location.
///
/// - Note: Audio stops rendering when the system deallocates `AudioGeneratorController`.
///   Create another `AudioGeneratorController` to restart audio.
///
/// Call ``AudioGeneratorController/stop()`` to halt the audio, and 
/// ``AudioGeneratorController/play()`` to restart the stream.
///
@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
@MainActor public class AudioGeneratorController {

    /// The entity the audio stream emanates from.
    @MainActor weak public var entity: Entity? { get }

    /// The configuration with rendering parameters for the render handler.
    @MainActor final public let configuration: AudioGeneratorConfiguration
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension AudioGeneratorController {

    /// The gain in decibels of the audio generator controller output.
    @MainActor public var gain: Audio.Decibel
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension AudioGeneratorController {

    /// A Boolean value that indicates whether playback is currently active.
    ///
    /// You may experience a small delay between when you call the
    /// ``AudioGeneratorController/play()`` method and when the
    /// ``AudioGeneratorController/isPlaying`` property reports `true`.
    @MainActor public var isPlaying: Bool { get }

    /// Begins the audio stream from the generator render handler.
    ///
    /// When you play the controller, the render handler starts receiving callbacks.
    /// The controller ignores calls to ``AudioGeneratorController/play()`` when audio is already playing.
    @MainActor public func play()

    /// Stops playback of the render handler.
    ///
    /// Callbacks to the render handler stop after calling ``AudioGeneratorController/stop()``.
    /// There may be a short delay between when you call `stop` and when the callbacks actually stop.
    @MainActor public func stop()
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension AudioGeneratorController : Sendable {
}

/// A container for audio resources that you can look up by user-defined names.
///
/// `AudioLibraryComponent` serves as a container for audio resources, so that you can
/// store loaded audio resources and associate them with an entity for playback using user-defined names.
/// You may use any ``AudioResource`` type, such as ``AudioFileResource`` or ``AudioFileGroupResource``.
/// - Note: In memory, you can also use ``AudioBufferResource``, but this type doesn't support serializing to disk or sharing via network.
///
/// Below is an example of how you can set this component in code:
///
/// ```swift
/// // Create a new entity.
/// let humanEntity = Entity()
///
/// // Set up two audio file resources, and combine them in one group resource.
/// let walkFileResource = try AudioFileResource.load(named: "HumanWalk")
/// let jumpFileResource = try AudioFileResource.load(named: "HumanJump")
/// let groupResource = try AudioFileGroupResource([walkFileResource, jumpFileResource])
///
/// // Create an `AudioLibraryComponent` to house the audio resources.
/// var audioLibraryComponent = AudioLibraryComponent()
///
/// // Add the resources to the component by name.
/// audioLibraryComponent.resources["Walk"] = walkFileResource
/// audioLibraryComponent.resources["Jump"] = jumpFileResource
/// audioLibraryComponent.resources["group"] = groupResource
///
/// humanEntity.components.set(audioLibraryComponent)
///
/// // Play the resource matching the "Walk" key on the entity -> Expect to play 'HumanWalk'.
/// humanEntity.playAudio(audioLibraryComponent.resources["Walk"]!)
/// ```
///
/// By setting an `AudioLibraryComponent` on different entities, you can use simple defined names
/// that trigger different sounds on different entities.
/// For example, you can reuse the "Walk" string from the preceding example on a different entity:
///
/// ```swift
///
/// // Create a new entity.
/// let robotEntity = Entity()
///
/// // Set up an audio file resource.
/// let robotWalkFileResource = try AudioFileResource.load(named: "RobotWalk")
///
/// // Create an `AudioLibraryComponent` to house the `audioResource`.
/// var audioLibraryComponent = AudioLibraryComponent()
///
/// // Add the resource to the component by name.
/// audioLibraryComponent.resources["Walk"] = robotWalkFileResource
///
/// robotEntity.components.set(audioLibraryComponent)
///
/// // Play the resource matching the "Walk" key on the entity -> Expect to play 'RobotWalk'.
/// robotEntity.playAudio(audioLibraryComponent.resources["Walk"]!)
/// ```
///
/// - Note: You can create a component using code, or add it to your entity using tools such as Reality Composer Pro.
///
/// In Reality Composer Pro, you can add an `AudioLibraryComponent` to an entity and then add audio
/// resources to it for easy access to those resources by name.
/// The system automatically loads the audio resources for you when you search for this component.
///
/// ```swift
/// guard let audioLibraryComponent = entity.components[AudioLibraryComponent.self],
///       let audioResource = audioLibraryComponent.resources["My_Audio_Resource_Name"]
/// else { return }
/// 
/// // Because the system has already loaded the resource for you,
/// // you may prepare or play it on an entity right away.
/// entity.playAudio(audioResource)
/// ```
@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
public struct AudioLibraryComponent : Component, ExpressibleByDictionaryLiteral {

    /// A dictionary of audio resources with user-defined names.
    ///
    /// The values can be any ``AudioResource`` type, such as ``AudioFileResource`` or
    /// ``AudioFileGroupResource``. 
    /// In memory, you can also use ``AudioBufferResource``,
    /// but this type doesn't support serializing to disk or sharing via network.
    public var resources: [String : AudioResource]

    /// Creates a new audio library from a dictionary.
    ///
    /// - Parameter resources: A dictionary of audio resources that you key by name.
    public init(resources: [String : AudioResource] = [:])

    /// Creates an instance initialized with the given key-value pairs.
    public init(dictionaryLiteral elements: (String, AudioResource)...)

    /// The key type of a dictionary literal.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Key = String

    /// The value type of a dictionary literal.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Value = AudioResource
}

/// A group that manages the playback properties of multiple playing sounds.
///
/// A mix group component manages the playback parameters for a collection of different
/// ``AudioPlaybackController`` and ``AudioGeneratorController`` instances.
/// Properties such as ``gain``, ``fade(to:duration:)``, and ``speed``
/// are multiplicative with the parameters you set on the controller.
///
/// You  associate audio resources to a mix group by setting the ``mixGroupName`` parameter in the resource's configuration.
/// For an example, see ``AudioFileResource/Configuration-swift.struct/mixGroupName``.
/// Enable a mix group by adding it to an ``AudioMixGroupsComponent`` structure on an entity in the scene.
/// The scene where the component belongs limits the scope of the mix group.
///
/// ```swift
/// var mixGroup = AudioMixGroup(name: "myMixGroup")
/// entity.components.set(AudioMixGroupsComponent(mixGroups: [mixGroup]))
/// ```
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct AudioMixGroup {

    /// The name of an audio mix group.
    public let name: String

    /// The overall level for all sounds of an audio mix group in relative decibels.
    ///
    /// The gain is a value in the range `[-.infinity, .zero]`,
    /// where `-.infinity` is silent and `.zero` is nominal.
    public var gain: Audio.Decibel

    /// The rate of playback for an audio mix group.
    ///
    /// The system limits the rate of playback to the range of `[0.25, 4]`.
    /// The default speed is `1`, which is equivalent to a normal playback rate.
    ///
    /// - Note: ``AudioGeneratorController`` ignores this value.
    public var speed: Double

    /// A Boolean value that indicates whether an audio mix group emits any sound.
    public var isMuted: Bool

    /// Creates a mix group.
    ///
    /// - Parameters:
    ///   - name: The name to associate this group with various audio configurations.
    public init(name: String)

    /// Transitions the gain to a value over a time interval using a linear curve.
    ///
    /// - Parameters:
    ///   - gain: The overall level for audio from a group after the fade is complete.
    ///   - duration: The duration of the fade in seconds.
    public mutating func fade(to gain: Audio.Decibel, duration: TimeInterval)
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioMixGroup : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AudioMixGroup, rhs: AudioMixGroup) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioMixGroup : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct AudioMixGroupsComponent {

    /// Initializes an `AudioMixGroupsComponent`.
    /// - Important: If more than one `AudioMixGroup` have matching names, only one will be used.
    public init(mixGroups: [AudioMixGroup] = [])

    /// Adds the given `AudioMixGroup` to the component.
    /// - Important: Adding an `AudioMixGroup` will replace an existing `AudioMixGroup` with matching name.
    public mutating func set(_ mixGroup: AudioMixGroup)

    /// Removes the `AudioMixGroup` with the given name, if it exists, from the component.
    public mutating func remove(named name: String)

    /// Returns the `AudioMixGroup` with the given name, if it exists.
    public func mixGroup(named name: String) -> AudioMixGroup?
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioMixGroupsComponent : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AudioMixGroupsComponent, b: AudioMixGroupsComponent) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioMixGroupsComponent : Component {
}

/// A controller that manages an audio playback instance.
///
/// You can obtain an audio playback controller by calling an entity’s Entity/prepareAudio(_:) or Entity/playAudio(_:) method
/// which creates a controller with the associated ``AudioResource``.
/// To play multiple instances of a resource, call ``Entity/playAudio(_:)`` to obtain new AudioPlaybackControllers.
///
/// During playback, the audio appears to come from the entity that you used to
/// create the controller. As you move around the MR scene, RealityKit
/// modulates the characteristics of the audio to account for your
/// location.
///
/// - Note: Playback commences only after the entity is parented and placed within a scene.
///
/// After playback completes, or if you call the
/// ``AudioPlaybackController/stop()`` method, the audio resource resets,
/// allowing you to replay the resource from the beginning. Alternatively, you can
/// enable indefinite looping by setting the `loops` property of
/// the audio resource to `true`.
///
/// Look for one of the events in ``AudioEvents`` if you want to be alerted when
/// certain aspects of audio playback occur.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class AudioPlaybackController {

    /// The entity from which the audio stream emanates.
    @MainActor @preconcurrency weak public var entity: Entity? { get }

    /// The resource that provides the audio stream.
    @MainActor @preconcurrency final public let resource: AudioResource

    /// A closure that the playback controller executes when it reaches the end
    /// of the audio stream.
    ///
    /// The controller doesn’t call the closure if you manually stop the audio
    /// by calling the ``AudioPlaybackController/stop()`` or the
    /// ``AudioPlaybackController/pause()`` method.
    ///
    ///  - Note: You can only register one handler at a time. If you set a new handler,
    /// the controller discards the old one.
    @MainActor @preconcurrency public var completionHandler: (() -> Void)?
}

extension AudioPlaybackController {

    /// A type alias for Double expressing that the value is in Decibels.
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "Audio.Decibel")
    @available(iOS, introduced: 13, deprecated: 18.0, renamed: "Audio.Decibel")
    @available(visionOS, deprecated, renamed: "Audio.Decibel")
    public typealias Decibel = Double
}

@available(macOS 10.15, iOS 13.0, *)
extension AudioPlaybackController {

    /// The rate of playback of the audio resource, with a range of `[.25, 4]`
    ///
    /// Set the speed to `1` for a normal playback rate.
    @MainActor @preconcurrency public var speed: Double

    /// The individual gain in decibels of the audio playback controller output.
    ///
    /// Use the ``AudioPlaybackController/fade(to:duration:)`` method to change
    /// the gain gradually and create smooth transitions.
    @MainActor @preconcurrency public var gain: AudioPlaybackController.Decibel

    /// Transitions the gain to the given value over a time interval using a
    /// linear curve.
    ///
    /// - Parameter newValue: The target decibel level.
    /// - Parameter duration: How long in seconds the fade should last.
    @MainActor @preconcurrency public func fade(to newValue: AudioPlaybackController.Decibel, duration: TimeInterval)
}

@available(macOS 10.15, iOS 13.0, *)
extension AudioPlaybackController {

    /// A Boolean value that indicates whether playback is currently active.
    ///
    /// You may experience a small delay between when you call the
    /// ``AudioPlaybackController/play()`` method and when the
    /// ``AudioPlaybackController/isPlaying`` property reports `true`.
    @MainActor @preconcurrency public var isPlaying: Bool { get }

    /// Plays the audio resource.
    ///
    /// The controller plays from the beginning of the resource, or from the
    /// point at which it was paused if you previously called the
    /// ``AudioPlaybackController/pause()`` method during playback.
    /// The controller ignores calls to ``AudioPlaybackController/play()`` when audio is already playing.
    @MainActor @preconcurrency public func play()

    /// Pauses playback of the audio resource while maintaining the position in
    /// the audio stream.
    ///
    /// Resume playback of a paused audio resource by calling the
    /// ``AudioPlaybackController/play()`` method.
    @MainActor @preconcurrency public func pause()

    /// Stops playback of the audio resource and discards the location in the
    /// audio stream.
    ///
    /// The next time you call ``AudioPlaybackController/play()``, playback starts at the
    /// beginning of the stream.
    @MainActor @preconcurrency public func stop()
}

@available(macOS 10.15, iOS 13.0, *)
extension AudioPlaybackController : Identifiable {

    /// The stable identity of the entity associated with this instance.
    @MainActor @preconcurrency public var id: UInt64 { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    @available(iOS 13.0, macOS 10.15, *)
    public typealias ID = UInt64
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioPlaybackController {

    /// Sets the playback position to the specified time.
    ///
    /// - Parameter time: The desired playback position.
    @MainActor @preconcurrency public func seek(to time: Duration)
}

@available(macOS 10.15, iOS 13.0, *)
extension AudioPlaybackController : Sendable {
}

/// A playable audio resource
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class AudioResource : Resource {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioResource {

    /// Normalization adjusts the level of an audio file or buffer to be at a defined target.
    ///
    /// Audio files produced in a production environment where dynamics are already being
    /// processed may not need normalization.
    ///
    /// Normalization has a CPU cost on _load_ for audio file resources that have a loading strategy
    /// of ``AudioFileResource/LoadingStrategy-swift.enum/preload``
    /// and a CPU cost on _playback_ for audio files that have a loading strategy of
    /// ``AudioFileResource/LoadingStrategy-swift.enum/stream``.
    public struct Normalization {

        /// Performs dynamic compression to normalize the audio source material to a level of -12dBLUFS in real-time.
        public static let dynamic: AudioResource.Normalization
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioResource {

    /// A container for different calibration modes that can be applied for playback.
    public struct Calibration {

        /// Relative adjustment of the resource from the default level of the audio output hardware.
        public static func relative(dBSPL: Audio.Decibel) -> AudioResource.Calibration

        /// The reference level (-12dBLUFS) of the audio source material will be reproduced at the given `dBSPL` level on known
        /// audio output hardware.
        ///
        /// - Note: The -12dBLUFS reference level is achieved automatically by using `Normalization.dynamic`.
        public static func absolute(dBSPL: Audio.Decibel) -> AudioResource.Calibration
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioResource : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @MainActor @preconcurrency public static func == (lhs: AudioResource, rhs: AudioResource) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioResource.Normalization : Equatable, Hashable, Sendable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AudioResource.Normalization, b: AudioResource.Normalization) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AudioResource.Calibration : Equatable, Hashable, Sendable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AudioResource.Calibration, b: AudioResource.Calibration) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// An action that animates the blend factor of an entity's billboard component.
///
/// This action animates the ``BillboardComponent/blendFactor`` value of an
/// entity's ``BillboardComponent``.
///
/// Over its duration, the action updates the `blendFactor` property to `1.0`.
/// If you provide a ``BillboardAction/transitionIn`` configuration,
/// the action interpolates the value of the component's current value for
///  ``BillboardComponent/blendFactor`` towards `1.0`.
/// If you provide a ``BillboardAction/transitionOut`` configuration,
/// the action interpolates the component's ``BillboardComponent/blendFactor`` value from `1.0` to its
/// original value for that component.
///
/// The example below creates a three-part animation that:
/// - Interpolates ``BillboardComponent/blendFactor`` from `0.0` to `1.0`
/// - Pauses for one second
/// - Interpolates ``BillboardComponent/blendFactor`` from `1.0` back to `0.0`
///
///```swift
/// // Load a robot model from a resource file.
/// let robotModel = try await ModelEntity(named: "vintage_robot")
///
/// // A billboard component for the robot model entity.
/// var billboardComponent = BillboardComponent()
///
/// // Disable the billboard at the beginning by setting its blend factor to zero.
/// billboardComponent.blendFactor = 0.0
///
/// // Add the component to the entity.
/// await robotModel.components.set(billboardComponent)
///
/// // A transition that lasts one second.
/// let billboardTransition = BillboardAction.Transition(
///     duration: 1.0,
///     timingFunction: .easeInOut
/// )
///
/// // An action that starts and ends with a one second transition.
/// let billboardAction = BillboardAction(transitionIn: billboardTransition,
///                                       transitionOut: billboardTransition)
///
/// // A three second animation that adjusts the blend factor twice.
/// //
/// // This animation includes a one second pause between both of the action's
/// // one second transitions in and out by setting the duration one second
/// // longer than action's total time.
/// let billboardAnimation = try AnimationResource
///     .makeActionAnimation(for: billboardAction,
///                          duration: 3.0,
///                          bindTarget: .billboardBlendFactor)
///
/// // Play the three second billboard animation that adjusts the blend factor.
/// robotModel.playAnimation(billboardAnimation)
///```
///
/// @Video(
///     source: billboardaction-simple-loop,
///     alt: "A screen recording of a vintage-style robot toy in a living room scene. At the start, the robot isn't looking at the camera, then its body moves in place to look at the camera, stays still for one second, and its body moves back to its original orientation.",
///     poster: billboardaction-simple-loop-poster
/// )
///
/// - Note: If an entity doesn't have a ``BillboardComponent``, the default
///         initializer creates one for you so that it can restore the entity
///         back to a state without the billboard.
///
/// - Important: This action directly animates the ``BindTarget/billboardBlendFactor`` on the bound entity.
///              Ensure a correct bind target is supplied when creating the animation.
///
/// Ensure the action can transition back to a non-billboard state by adding
/// the component to the entity and check the
/// ``BillboardComponent/blendFactor``
/// property has a value that you expect.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct BillboardAction : EntityAction, Codable {

    /// The duration and timing of how an action event transitions from one
    /// state to another.
    public struct Transition : Codable {

        /// The amount of time the transition takes to go from one state to another.
        public var duration: TimeInterval

        /// The rate of change at the beginning and end of the transition.
        public var timingFunction: AnimationTimingFunction

        /// Creates a transition with a duration and timing function.
        public init(duration: TimeInterval = 0, timingFunction: AnimationTimingFunction = .default)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// The rate of change at the beginning of the action.
    public var transitionIn: BillboardAction.Transition

    /// The rate of change at the end of the action.
    public var transitionOut: BillboardAction.Transition

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public var animatedValueType: (any AnimatableData.Type)? { get }

    /// Creates a new billboard action.
    ///
    /// - Parameters:
    ///    - transitionIn: The rate of change at the beginning of the action.
    ///    - transitionOut: The rate of change at the end of the action.
    public init(transitionIn: BillboardAction.Transition = .init(), transitionOut: BillboardAction.Transition = .init())

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A component that orients an entity instance so that it continuously points toward
/// the active camera.
///
/// The `BillboardComponent` automatically adjusts an entity's orientation so
/// that its z-axis keeps pointing in the direction of the main camera in a
/// RealityKit scene.
///
/// Add a `BillboardComponent` to any entity by passing it to an entity's
/// ``Entity/ComponentSet/set(_:)-8sii2`` method.
///
/// ```swift
/// entity.components.set(BillboardComponent())
/// ```
///
/// The entity immediately reorients itself so that it faces the scene's active
/// camera.
///
/// | Without `BillboardComponent` | With `BillboardComponent` |
/// |:-:|:-:|
/// |![An image of a vintage-style toy robot in a living room scene. The robot is facing about 45 degrees to the left and down from the viewer's perspective.](billboardcomponent-robot-side-above-without)|![An image of a vintage-style toy robot in a living room scene. The robot is facing directly towards the viewer.](billboardcomponent-robot-side-above-with)|
///
/// - Important: An entity with `BillboardComponent` doesn't provide access to its end orientation.
///   Requesting the entity's orientation through its transform returns only the unaltered orientation.
///
///
/// For an example of how to animate ``blendFactor``, see ``BillboardAction``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct BillboardComponent : Component {

    /// Creates a billboard component that points an entity's
    /// positive z-axis directly toward the active camera.
    public init()

    /// The degree at which the entity rotates toward the camera.
    ///
    /// The `blendFactor` property is a floating-point number in the range `[0.0, 1.0]`.
    ///
    /// - When `blendFactor` is `1.0`, the entity fully faces the camera.
    ///  This is the default behavior.
    /// - When `blendFactor` is `0.0`, the entity doesn't rotate at all.
    /// - When `blendFactor` is between `0.0` and `1.0`, the entity partially rotates toward the camera.
    ///
    /// The following example configures the entity to rotate by half the angle it needs
    /// to directly face the camera by setting the `blendFactor` to `0.5`:
    ///
    /// ```swift
    /// var billboard = BillboardComponent()
    /// billboard.blendFactor = 0.5
    /// entity.components.set(billboard)
    /// ```
    ///
    /// For example, here's how a few different `blendFactor` values affect the orientation:
    ///
    /// | 0 | 0.25 | 0.5 | 1 |
    /// |:-:|:-:|:-:|:-:|
    /// |![An image of a vintage-style toy robot in a living room scene. The robot is facing about 45 degrees to the left and down from the viewer's perspective.](billboardcomponent-robot-side-above-without)|![An image of a vintage-style toy robot in a living room scene. The robot is facing about 35 degrees to the left and down from the viewer's perspective.](billboardcomponent-robot-side-above-blend-25)|![An image of a vintage-style toy robot in a living room scene. The robot is facing about 22 degrees to the left and down from the viewer's perspective.](billboardcomponent-robot-side-above-blend-50)|![An image of a vintage-style toy robot in a living room scene. The robot is facing directly towards the viewer.](billboardcomponent-robot-side-above-with)|
    ///
    /// For an example of how to animate `blendFactor`, see ``BillboardAction``.
    public var blendFactor: Float
}

/// The components of a target's path that refer to the animation properties of
/// a nested scene or entity.
///
/// The following code demonstrates bind target paths with varying numbers of
/// elements. For a multicomponent target, call the ``BindPath/Part``
/// enumeration for each component. The individual elements form the path's
/// resulting ``BindPath/parts`` array.
///
/// ```swift
/// // Single-component paths:
/// let target0: BindTarget = .transform
/// let target1: BindTarget = .jointTransforms
/// let target2: BindTarget = .parameter("myInt")
///
/// // Relative entity path:
/// let target3: BindTarget = .entity("entityA").entity("entityB").parameter("myInt")
///
/// // Root entity path:
/// let target4: BindTarget = .anchorEntity("entityA").entity("entityB").transform
///
/// // Scene path:
/// let target5: BindTarget = .scene("sceneA").anchorEntity("entityA").entity("entityB").jointTransforms
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct BindPath {

    /// An individual piece of a larger path that refers to the target of an
    /// animation.
    ///
    /// Path-based instances of ``AnimationDefinition/bindTarget``, or those
    /// identified by the ``BindTarget/path(_:)`` call, consist of one or more
    /// components identified by these enumeration options.
    ///
    /// For example, the succession of ``BindPath/Part`` calls in the following
    /// code results in a path with a ``BindPath/parts`` array that contains
    /// three components: `entityA`, `entityB`, and `myInt`.
    ///
    /// ```swift
    /// let target3: BindTarget = .entity("entityA").entity("entityB").parameter("myInt")
    /// ```
    public enum Part : Equatable {

        /// A path component for a nested scene.
        ///
        /// This path component indicates that another component follows, and at
        /// the same time specifies the entity, scene, or property that
        /// animates.
        ///
        /// Because no path contains nested scenes, this component exists only
        /// as the first element of a multicomponent path.
        case scene(String)

        /// A path component for the scene's anchor entity.
        ///
        /// This path component indicates that another component follows, which
        /// either contains or identifies the property of the entity that
        /// animates.
        case anchorEntity(String)

        /// A path component for a nested entity.
        ///
        /// This path component indicates that another component follows, which
        /// either contains or identifies the property of the entity that
        /// animates.
        case entity(String)

        /// A path component to animate a named parameter.
        ///
        /// This path component terminates an array of paths, and at the same
        /// time specifies a named scene or entity property that animates.
        case parameter(String)

        /// A path component to animate a transform.
        ///
        /// This path component terminates an array of paths, and at the same
        /// time specifies a transform that animates.
        ///
        /// This BindTarget references a Transform type
        case transform

        /// A path component to animate joint transforms.
        ///
        /// This path component terminates an array of components, and at the
        /// same time specifies the entity's joint transforms that animate.
        ///
        /// This BindTarget references a Transform type
        case jointTransforms

        /// An path component to animate an opacity. Requires that
        /// the entity has an OpacityComponent
        ///
        /// This BindTarget references a Float type
        @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
        case opacity

        /// An option the entity's blend shape weights animate. Requires that the
        /// entity has a BlendShapeWeightsComponent. Can be indexed by blend shape
        /// index or by blend shape name.  Default is by index 0.
        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        case blendShapeWeights

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        case blendShapeWeightsAtIndex(Int = 0)

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        case blendShapeWeightsWithID(BlendShapeWeightsData.ID)

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        case billboardBlendFactor

        /// A path component to an IK solver instance.
        @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
        case ikSolver(IKComponent.Solver.ID?)

        /// A path component to an IK solver's constraint target transform.
        @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
        case ikConstraintTarget(IKComponent.Constraint.ID)

        /// A path component to an IK solver's constraint target look at position.
        @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
        case ikConstraintLookAtTarget(IKComponent.Constraint.ID)

        /// A path component to animate a material property.
        ///
        /// This path component indicates that another component follows, which
        /// either contains or identifies the material property that animates.
        @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
        case material(Int)

        /// A path component to name a material parameter to animate
        ///
        /// This path component terminates an array of paths, and at the same
        /// time specifies the material parameter to be animated
        @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
        case materialParameter(String)

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        case skeletalPose(SkeletalPose.ID)

        /// Returns a Boolean value that indicates whether two components of a
        /// bind path are equal.
        ///
        /// - Parameters:
        ///   - lhs: The component of the bind path on the left side of the operator.
        ///
        ///   - rhs: The component of the bind path on the right side of the operator.
        ///
        /// - Returns: Returns `true` if the components of the bind path are
        /// equal. Otherwise, returns `false`.
        public static func == (lhs: BindPath.Part, rhs: BindPath.Part) -> Bool
    }

    /// An array of the individual components of a complete bind path.
    public var parts: [BindPath.Part] { get }
}

/// A reference to a particular scene, entity, or property that animates.
///
/// This structure describes a reference to an animated property. The property
/// may be a transform, collection of joint transforms, an arbitrary named
/// property of an entity, or the property of a nested entity.
///
/// For nested entities, the ``BindTarget/path(_:)`` case returns a ``BindPath``
/// instance that contains an array of _parts_ (``BindPath/Part``). Each part
/// identifies one or more nested, named entities or scenes, followed by the
/// property to animate.
@available(macOS 12.0, iOS 15.0, *)
public enum BindTarget : Equatable {

    /// A bind target that refers to a framework-provided property.
    case `internal`(InternalBindPath)

    /// A option that specifies that the target entity's transform animates.
    case transform

    /// An option that specifies that the entity's joint transforms animate.
    case jointTransforms

    /// Provides a property that animates from the given textual name.
    case parameter(String)

    /// Provides a complex bind path capable of animating additional entities
    /// other than the current entity.
    case path(BindPath)

    /// An option that specifies that the entity's opacity to animate. Requires that
    /// the entity has an OpacityComponent
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    case opacity

    /// An option the entity's blend shape weights animate. Requires that the
    /// entity has a BlendShapeWeightsComponent.
    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    case blendShapeWeights

    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    case blendShapeWeightsAtIndex(Int = 0)

    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    case blendShapeWeightsWithID(BlendShapeWeightsData.ID)

    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    case billboardBlendFactor

    /// An option that specifies one of the entity's skeletal poses to animate.
    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    case skeletalPose(String)

    /// A bind path for a particular scene.
    ///
    /// This structure defines an absolute bind path for a scene. You determine
    /// the scene that a particular instance references by specifying the
    /// scene's name as the argument to ``BindPath/Part/scene(_:)``.
    public struct ScenePath {

        /// A path for the scene's anchor entity.
        public func anchorEntity(_ name: String) -> BindTarget.EntityPath

        /// A bind target for the scene.
        ///
        /// This property represents a bind path within an ``AnimationView`` to
        /// redirect the view's ``BlendTreeSourceNode/source`` animation to a
        /// different scene.
        public var `self`: BindTarget { get }
    }

    /// The texture coordinate parameters for a given texture layer that an animation can target.
    ///
    /// When `index` equals `0`, the structure refers to the primary texture coordinates. When `index` equals `1`, the structure refers to the secondary texture coordinates.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public struct TextureCoordinateTransformPath {

        public var offset: BindTarget { get }
    }

    /// Material parameters that an animation can target.
    ///
    /// Each property is a `BindTarget` which defines a parameter an animation can target.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public struct MaterialPath {

        /// This BindTarget references a SIMD4<Float> type
        public var baseColorTint: BindTarget { get }

        /// This BindTarget references a Float type
        public var roughnessScale: BindTarget { get }

        /// This BindTarget references a Float type
        public var metallicScale: BindTarget { get }

        /// This BindTarget references a Float type
        public var specularScale: BindTarget { get }

        /// This BindTarget references a SIMD4<Float> type
        public var sheenTint: BindTarget { get }

        /// This BindTarget references a Float type
        public var clearcoatScale: BindTarget { get }

        /// This BindTarget references a Float type
        public var clearcoatRoughnessScale: BindTarget { get }

        /// This BindTarget references a Float type
        public var anisotropyLevelScale: BindTarget { get }

        /// This BindTarget references a Float type
        public var anisotropyAngleScale: BindTarget { get }

        /// This BindTarget references a SIMD4<Float> type
        public var emissiveColor: BindTarget { get }

        /// This BindTarget references a Float type
        public var emissiveIntensity: BindTarget { get }

        /// This BindTarget references a Float type
        public var opacityThreshold: BindTarget { get }

        /// This BindTarget references a SIMD2<Float> type
        public var textureCoordinate: BindTarget.TextureCoordinateTransformPath { get }

        /// This BindTarget references a SIMD2<Float> type
        public var secondaryTextureCoordinate: BindTarget.TextureCoordinateTransformPath { get }

        public var customValue: BindTarget { get }
    }

    /// A bind path context for a particular entity.
    ///
    /// This structure references all the animated properties of an entity.
    ///
    /// To access the animated properties of one of the entity's children, call
    /// ``BindTarget/EntityPath/entity(_:)`` and pass in the child's name.
    public struct EntityPath {

        /// Provides a child entity's path.
        ///
        /// - Parameters:
        ///   - name: The name of the child entity.
        public func entity(_ name: String) -> BindTarget.EntityPath

        /// A bind target for the entity's transform.
        public var transform: BindTarget { get }

        /// A bind target for the entity's joint transforms.
        public var jointTransforms: BindTarget { get }

        /// A bind target for the entity's blend shape weights.
        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public func blendShapeWeights() -> BindTarget

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public func blendShapeWeightsAtIndex(_ index: Int = 0) -> BindTarget

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public func blendShapeWeightsWithID(_ id: BlendShapeWeightsData.ID) -> BindTarget

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public var billboardBlendFactor: BindTarget { get }

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public func skeletalPose(_ name: SkeletalPose.ID) -> BindTarget

        /// A bind target for the entity's opacity.. Requires that
        /// the entity has an OpacityComponent
        @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
        public var opacity: BindTarget { get }

        /// Provides a bind target for a particular animated property.
        ///
        /// - Parameters:
        ///   - name: The animated property's name.
        public func parameter(_ name: String) -> BindTarget

        /// Provides a specified material's path.
        ///
        /// - Parameters:
        ///   - index: The index of the material.
        @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
        public func material(_ index: Int) -> BindTarget.MaterialPath

        /// A bind target for the entity.
        ///
        /// This property represents a bind path within an ``AnimationView`` to
        /// redirect the view’s ``BlendTreeSourceNode/source`` animation to a
        /// different scene.
        public var `self`: BindTarget { get }

        @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
        public func ikSolver(_ id: IKComponent.Solver.ID? = nil) -> BindTarget.IkSolverPath
    }

    @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
    public struct IkSolverPath {

        /// The bind target of the named constraint's target transform.
        public func constraintTarget(_ constraintName: String) -> BindTarget

        /// The bind target of the named constraint's target look at position.
        public func constraintLookAtTarget(_ constraintName: String) -> BindTarget
    }

    /// Generates a bind path from a particular scene.
    public static func scene(_ name: String) -> BindTarget.ScenePath

    /// Generates a complex bind path from a particular anchor entity in the
    /// scene.
    public static func anchorEntity(_ name: String) -> BindTarget.EntityPath

    /// Generates a complex bind path from a particular child entity of the
    /// current entity.
    public static func entity(_ name: String) -> BindTarget.EntityPath

    /// Generates a complex bind path from one of an entity's materials.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public static func material(_ index: Int) -> BindTarget.MaterialPath

    /// Returns a Boolean value that indicates whether two bind targets are
    /// equal.
    ///
    /// - Parameters:
    ///   - lhs: The bind target on the left side of the operator.
    ///
    ///   - rhs: The bind target on the right side of the operator.
    ///
    /// - Returns: Returns `true` if the bind targets are equal. Otherwise,
    /// returns `false`.
    public static func == (lhs: BindTarget, rhs: BindTarget) -> Bool
}

/// An opaque base protocol for bindable data objects.
///
/// The templated bindable-value object, ``BindableValue`` `<T>`, determines
/// that the value you choose for type `T` adopts this protocol. The types that
/// the framework accepts are: ``Transform``,
/// <doc://com.apple.documentation/documentation/swift/float>,
/// <doc://com.apple.documentation/documentation/swift/double>,
/// <doc://com.apple.documentation/documentation/swift/simd2>,
/// <doc://com.apple.documentation/documentation/swift/simd3>,
/// <doc://com.apple.documentation/documentation/swift/simd4>,
/// <doc://com.apple.documentation/documentation/accelerate/simd_quatf>,
/// <doc://com.apple.documentation/documentation/swift/bool>,
/// <doc://com.apple.documentation/documentation/swift/int>, and
/// <doc://com.apple.documentation/documentation/swift/string>.
@available(macOS 12.0, iOS 15.0, *)
public protocol BindableData {
}

/// The value of a bindable target.
///
/// This structure holds the value of an animatable property
/// (``BindableValue/animatedValue``), that is, the target property that
/// animates. In addition, the structure stores the property's original value
/// (``BindableValue/baseValue``), which represents the property's value before
/// a running animation starts. The ``BindableValue/value`` property returns the
/// animated value when an animation runs; when the animation isn't running, it
/// returns the base value.
@available(macOS 12.0, iOS 15.0, *)
public struct BindableValue<T> where T : BindableData {

    /// Creates a bindable value.
    ///
    /// - Parameters:
    ///   - value: A value that reflects the state of the animated property before or after an animation.
    ///
    ///   - animatedValue: A value that represents the state of the animated
    ///     property as an animation progresses.
    public init(_ value: T, animatedValue: T? = nil)

    /// The main accessor for the bind value.
    ///
    /// This property returns the animated value
    /// (``BindableValue/animatedValue``) if an animation is active. Otherwise,
    /// this property returns the base value (``BindableValue/baseValue``).
    ///
    /// When you assign a value to this property, the setter assigns the
    /// value you provide to ``BindableValue/baseValue``.
    public var value: T

    /// A value that reflects the state of the animated property before or after
    /// an animation.
    public var baseValue: T

    /// A value that represents the state of the animated property as an
    /// animation progresses.
    public var animatedValue: T?
}

/// A reference to a bindable value of an animation.
///
/// As the name indicates, this structure doesn't exhibit copy-on-write behavior
/// because it's a reference. This is in contrast to the ``BindableValue``
/// structure.
@available(macOS 12.0, iOS 15.0, *)
public struct BindableValuesReference {

    /// Returns the bindable value at the subscripted index.
    @MainActor @preconcurrency public subscript<T>(bindTarget: BindTarget, type: T.Type = T.self) -> BindableValue<T>? where T : BindableData
}

/// A set of animatable weight values that collectively represent
/// the blending amounts for all the blend shapes' blend targets.
///
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct BlendShapeWeights : BidirectionalCollection, MutableCollection, ExpressibleByArrayLiteral, Equatable, AnimatableData {

    /// A position of an individual weight in the collection.
    public typealias Index = Int

    /// An individual weight in the collection.
    public typealias Element = Float

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = Float

    /// Initializes a collection of animatable weights for a blend shape.
    public init()

    /// Creates a collection of animatable weights using the argument
    /// elements for a blend shape.
    ///
    /// - Parameters:
    ///   - elements: A comma-delimited list of weights for the blend shape.
    public init(arrayLiteral elements: Float...)

    /// Initializes a collection of weights for a single blend shape.
    ///
    /// - Parameters:
    ///   - weights: An array of float weights for the blend shape.
    public init<S>(_ weights: S) where S : Sequence, S.Element == Float

    /// Accesses a single weight in the collection at the given index.
    ///
    /// For more on accessing elements by index, see
    /// <doc://com.apple.documentation/documentation/swift/array/1540606-subscript>.
    public subscript(index: BlendShapeWeights.Index) -> Float

    /// An index to the first weight in the collection.
    ///
    /// For more on the sequence's beginning index, see
    /// <doc://com.apple.documentation/documentation/swift/array/1541237-startindex>.
    public var startIndex: BlendShapeWeights.Index { get }

    /// An index to the last weight in the collection.
    ///
    /// For more more on the sequence's final index, see
    /// <doc://com.apple.documentation/documentation/swift/array/1539310-endindex>.
    public var endIndex: BlendShapeWeights.Index { get }

    /// Returns the position in the sequence of the weight that follows the given
    /// position.
    ///
    /// For more on calculating indices, see
    /// <doc://com.apple.documentation/documentation/swift/array/1787306-index>.
    public func index(after i: BlendShapeWeights.Index) -> BlendShapeWeights.Index

    /// Returns the position in the sequence of the weight that preceeds the
    /// given position.
    ///
    /// For more on calculating indices, see
    /// <doc://com.apple.documentation/documentation/swift/array/1782301-index>.
    public func index(before i: BlendShapeWeights.Index) -> BlendShapeWeights.Index

    /// Returns a Boolean value that indicates whether two collections of weights
    /// are equal.
    ///
    /// - Parameters:
    ///   - lhs: The collection of weights on the left side of the operator.
    ///
    ///   - rhs: The collection of weights on the right side of the operator.
    ///
    /// - Returns: Returns `true` if the two collections of weights are equal.
    /// Otherwise, returns `false`.
    public static func == (lhs: BlendShapeWeights, rhs: BlendShapeWeights) -> Bool

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = DefaultIndices<BlendShapeWeights>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Iterator = IndexingIterator<BlendShapeWeights>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<BlendShapeWeights>
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension BlendShapeWeights : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A component that provides access to the current weights associated with all blend shape meshes on an entity.
///
/// You can access the weights associated with an entity's blend shapes by using the ``weightSet`` variable after an
/// initialized `BlendShapeWeightsComponent` is added to an entity.
///
///```swift
/// let blendShapeWeightsComponent = BlendShapeWeightsComponent(
///     weightsMapping: weightsMapping)
/// entity.components.set(blendShapeWeightsComponent)
/// let weightValues: [Float] = [0.3, 0.8]
/// entity.components[BlendShapeWeightsComponent.self]!.weightSets[0].weights
///     = weightValues
///```
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct BlendShapeWeightsComponent : Component {

    /// Create a BlendShapeWeightsComponent from a BlendShapeWeightsMapping.
    public init(weightsMapping: BlendShapeWeightsMapping)

    /// The runtime named blend shapes weights.
    ///
    /// Initialize the `weightSet` variable using the ``BlendShapeWeightsSet/init()`` function.
    ///
    /// The `weightSet` variable has the following limitations as to how it can be set:
    ///
    ///    * If `weightSet` is assigned to a new ``BlendShapeWeightsSet``, then
    ///      the new set have the same number of weights and weight names as the
    ///      current variable.
    ///      Additionally, make sure the weight names exactly match
    ///      the current set's weight names.
    ///    * Weight values less than zero are ignored.
    ///    * Weight name changes are ignored.
    ///    * Setting an incorrect number of weight values are ignored.
    ///    * Blend shape name changes are ignored.
    public var weightSet: BlendShapeWeightsSet
}

/// A structure that encapsulates the blend shape name, blend shape weights and the names
/// of those weights to be stored by the blend shape weights set.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct BlendShapeWeightsData : Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = String

    /// Creates an instance of the named weights for a single blend shape.
    /// - Parameters:
    ///   - id: The unique name of the blend shape.
    ///   - weights: An array of name value pairs for the weights in predefined order.
    public init(id: BlendShapeWeightsData.ID, weights: [(String, BlendShapeWeights.Element)])

    /// The unique id of the blend shape. This value is used when binding to the structure using an animation bind target.
    public var id: BlendShapeWeightsData.ID { get }

    /// The blend shape's weight values.
    public var weights: BlendShapeWeights

    /// The name of each weight value defined in the ``weights`` variable.
    public var weightNames: [String] { get }
}

/// A mapping of blend weights to the target meshes that those weights affect.
///
/// Use `BlendShapeWeightsMapping` to initialize a ``BlendShapeWeightsComponent``. You can
/// initialize it in two different ways:
///
/// * Initialize the mapping from a user-provided ``MeshResource``, from which the mapping information can
///   be generated.  In this case, the number of blend shapes and each blend shape's weights map exactly
///   to the `MeshResource`'s structure.
///
///```swift
/// if let modelComponent = blendShapeEntity.components[ModelComponent.self] {
///     let meshResource = modelComponent.mesh
///     let blendShapeWeightsMapping = BlendShapeWeightsMapping(
///         meshResource: meshResource)
///     blendShapeEntity.components.set(BlendShapeWeightsComponent(
///         weightsMapping: blendShapeWeightsMapping))
/// }
///```
///
/// * Initialize the mapping from a user-defined blend shape name and list of weight names.  When used to initialize
///   a ``BlendShapeWeightsComponent``, the weight names define which mesh targets map from the
///   owning entity's ``ModelComponent``'s mesh resource.
///
///   RealityKit expects the ``ModelComponent`` to already be assigned to the entity on which the ``BlendShapeWeightsComponent``
///   resides.  Match the weight names to the weight names found in the ``ModelComponent``'s mesh resource.
///   If a weight name does not match any of the mesh weight names then it is ignored and that weight will have no effect.
///   If a weight name in the ``ModelComponent``'s mesh resource is excluded from the list of weight names, then the
///   associated target mesh will not be controllable by any of the provided weights.
///
///   Note also that the provided blend shape name can be used to reference the blend shape weights in the
///   ``BlendShapeWeightsSet``.
///
///```swift
/// let weightNames: [String] = [
///     "weight0",
///     "weight1"
/// ]
///
/// let blendShapeWeightsMapping = BlendShapeWeightsMapping(
///     blendShapeName: "BlendShape0",
///     weightNames: weightNames)
///
/// blendShapeEntity.components.set(BlendShapeWeightsComponent(
///     weightsMapping: blendShapeWeightsMapping))
///```
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public class BlendShapeWeightsMapping : Resource {

    /// Creates a mapping from the given MeshResource.
    ///
    ///  - Parameters:
    ///    - meshResource: The definition of the mesh from which to build the mapping.
    public init(meshResource: MeshResource)

    /// Creates a mapping that applies the weight names to mesh parts in a
    /// model component.
    ///
    /// This creates a mapping that applies the weight names to every mesh part in the ``ModelComponent`` associated
    /// with the ``BlendShapeWeightsComponent``'s entity.
    ///
    /// Make sure the weight names match the weight names in the mesh resource data.  RealityKit will ignore weight names
    /// that do not match.
    ///
    ///  - Parameters:
    ///    - blendShapeName: The user-defined name of the blend shape.
    ///    - weightNames: The names of the weights that are managed by this mapping.
    public init(blendShapeName: String, weightNames: [String])
}

/// A custom collection of named blend shape weights.
///
/// Retrieve a `BlendShapeWeightsSet` from a ``BlendShapeWeightsComponent`` to access the
/// current weights and weight names for each blend shape managed by the component.
///
/// Set the current weights for a blend shape by assigning a `BlendShapeWeightsSet` to a
/// ``BlendShapeWeightsComponent`` for a specific blend shape.
///
/// The collection allows:
/// * Access to elements by name.
/// * Protection that prohibits updating an element, where such an update would try to rename the stored element.
///
/// ``BlendShapeWeightsSet`` does not support addition/removal of elements, as the blend shape weights are defined in the asset
/// and the number and names of the weights are immutable.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct BlendShapeWeightsSet {

    /// A type representing the sequence's elements.
    public typealias Element = BlendShapeWeightsData

    /// Creates an empty set.
    public init()

    /// The blend shape weights data set that drives the model.
    ///
    /// This is equivalent to reading ``HasModel/blendWeights``.
    public var `default`: BlendShapeWeightsSet.Element?

    /// Number of blend shape weight data in the set.
    public var count: Int { get }

    /// Checks if the set contains any blend shape weights data.
    public var isEmpty: Bool { get }

    /// Accessor for reading a blend shape weights data in the set.
    /// - Parameter blendShapeName: The name of the blend shape to be returned.
    /// - Returns: Blend shape weights data associated with the given name owned by this set, or nil if not found.
    public subscript(blendShapeName: String) -> BlendShapeWeightsSet.Element? { get }

    /// Checks if the set contains a blend shape weights data instance with the given name.
    /// - Parameter blendShapeName: The name of the blend shape to look up.
    /// - Returns: `true` blend shape weights data associated with the matching name is contained in the set.
    public func contains(_ blendShapeName: String) -> Bool

    /// Updates a blend shape weights data instance in the set based on its name. If blend shape weights data with this ID does not exist, does nothing.
    /// - Parameter newValue: The blend shape weights data to store.
    /// - Returns: The previous pose value, if named pose exists. nil otherwise.
    @discardableResult
    public mutating func set(_ newValue: BlendShapeWeightsSet.Element) -> BlendShapeWeightsSet.Element?
}

/// Conformance to Sequence
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension BlendShapeWeightsSet : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> BlendShapeWeightsSet.Element?

        /// The type of element traversed by the iterator.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Element = BlendShapeWeightsSet.Element
    }

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> BlendShapeWeightsSet.Iterator
}

/// Adds conformance to Collection to go along with Sequence
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension BlendShapeWeightsSet : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// The index of the first entry in a non-empty set.
    public var startIndex: BlendShapeWeightsSet.Index { get }

    /// The index of the last entry in a non-empty set.
    public var endIndex: BlendShapeWeightsSet.Index { get }

    /// Returns the index where the specified blend shape weights data appears in the collection.
    public func index(of blendShapeName: String) -> BlendShapeWeightsSet.Index?

    /// Accesses the blend shape weights data at the specified index.
    public subscript(index: BlendShapeWeightsSet.Index) -> BlendShapeWeightsSet.Element

    /// Returns the index after the given index.
    public func index(after i: BlendShapeWeightsSet.Index) -> BlendShapeWeightsSet.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = DefaultIndices<BlendShapeWeightsSet>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<BlendShapeWeightsSet>
}

/// A collection of animations on the same property that the framework blends to
/// a single animation.
///
/// This structure provides a way to form a single animation by mixing several
/// other animations together. You define a source node for each animation, and
/// a weight, which determines how much each individual animation takes effect
/// in the resulting animation.
///
/// To create the blended animation, you define a _blend tree_ that sprouts from
/// ``BlendTreeAnimation/root``, which consists of one or more blend-tree nodes
/// (``BlendTreeNode``). Each node may be one of the following conforming types:
///
/// - ``BlendTreeBlendNode``, which branches the tree for every element in
/// ``BlendTreeBlendNode/sources``
/// - ``BlendTreeSourceNode``, which defines one of the animations to blend
/// via its ``BlendTreeSourceNode/source`` property
///
/// Because source nodes reference no other nodes, they represent leaf nodes in
/// the tree.
///
/// ### Blending two skeletal movements to a single movement
///
/// The following animation plays a sampling of the animations named
/// `anim1` and `anim2`. To fine-tune the interplay between the two animations,
/// the code sets a blend weight for each animation. The weight of `0.25` for
/// `anim1` determines that the first animation's behavior is 25% prominent in
/// the final result. The `anim2` weight is `0.75`, as the cumulative blend
/// weight across all animations in the tree needs to equal `1`. This determines
/// that the second animation influences 75% of the visual behavior of the
/// blended animation.
///
/// ```swift
/// let anim1 = FromToByAnimation<JointTransforms>(
///     name: "anim1",
///     from: JointTransforms([Transform(scale: SIMD3<Float>(1, 2, 3),
///     rotation: simd_quatf(ix: 5, iy: 6, iz: 7, r: 8),
///     translation: SIMD3<Float>(10, 20, 30))]),
///     to: JointTransforms([Transform(scale: SIMD3<Float>(11, 21, 31),
///     rotation: simd_quatf(ix: 50, iy: 60, iz: 70, r: 80),
///     translation: SIMD3<Float>(100, 200, 300))]),
///     duration: 1.0)
///
/// let anim2 = FromToByAnimation<JointTransforms>(
///     name: "anim2",
///     from: JointTransforms([Transform(scale: SIMD3<Float>(10, 20, 30),
///     rotation: simd_quatf(ix: 4, iy: 5, iz: 5, r: 7),
///     translation: SIMD3<Float>(100, 200, 300))]),
///     to: JointTransforms([Transform(scale: SIMD3<Float>(110, 210, 310),
///     rotation: simd_quatf(ix: 500, iy: 60, iz: 70, r: 80),
///     translation: SIMD3<Float>(1000, 2000, 3000))]),
///     duration: 10.0)
///
/// let blendTree = BlendTreeAnimation<JointTransforms>(
///     blend(
///         BlendTreeSourceNode(
///             source: anim1,
///             name: "anim1",
///             weight: .value(0.25)),
///         BlendTreeSourceNode(
///             source: anim2,
///             name: "anim2",
///             weight: .value(0.75)),
///         name: "blend"),
///     name: "blendTree",
///     bindTarget: .parameter("bar")
/// )
/// ```
///
/// - Tip: To modify the weights for each frame, create a source node with a
/// dynamic ``BlendWeight``, such as with the
/// ``BlendWeight/bindTarget(_:defaultWeight:)`` or
/// ``BlendWeight/parameter(_:defaultWeight:)`` enumeration cases.
@available(macOS 12.0, iOS 15.0, *)
public struct BlendTreeAnimation<Value> : AnimationDefinition where Value : AnimatableData {

    /// Creates a unique animation from a combination of other animations in the
    /// form of a tree.
    ///
    /// - Parameters:
    ///   - root: The first node in a tree of animations.
    ///
    ///   - name: A textual name for the animation.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     builds on the current state of the target entity or resets the state
    ///     before running.
    ///
    ///   - bindTarget: A textual name that identifies the particular property
    ///     that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation
    ///     into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The behavior when the animated property reaches its end value.
    ///
    ///   - trimStart: The optional time, in seconds, at which the source animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the source animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that lapses before the animation plays.
    ///
    ///   - speed: A factor that increases or decreases the animation’s rate of playback.
    public init(_ root: any BlendTreeNode, name: String = "", isAdditive: Bool = false, bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1)

    /// The first node in a tree of animations.
    ///
    /// This property defines the node that represents the root of a blend tree.
    /// If you assign this property a ``BlendTreeBlendNode`` instance, the root
    /// branches for every member you add to the instance's
    /// ``BlendTreeBlendNode/sources`` property.
    ///
    /// If you define a ``BlendTreeSourceNode`` instance to this property, the
    /// tree contains a single animation, which blends with no other animations.
    public var root: any BlendTreeNode

    /// A textual name for the animation.
    public var name: String

    /// The order in which the framework composites the animation.
    ///
    /// The framework applies multiple animations on the same target in
    /// ascending order of this property’s value. Animations in a lower layer
    /// run before animations in a higher layer. Animations that share the same
    /// value apply in the order that they execute.
    public var blendLayer: Int32

    /// A textual name that identifies the particular property that animates.
    public var bindTarget: BindTarget

    /// An option that determines which data displays outside of the normal
    /// duration.
    ///
    /// This property determines what to display when the framework samples the
    /// animation outside of the range defined by its underlying duration. The
    /// animation applies this property when:
    ///
    /// - Playback progresses toward, but hasn't yet reached, a nonzero
    /// ``AnimationDefinition/offset``. - A range determined by
    /// ``AnimationDefinition/trimStart``, ``AnimationDefinition/trimEnd``, or
    /// ``AnimationDefinition/trimDuration`` exceeds the animation's underlying
    /// duration.
    public var fillMode: AnimationFillMode

    /// A Boolean value that indicates whether the animation builds on the
    /// current state of the target entity or resets the state before running.
    public var isAdditive: Bool

    /// The optional time, in seconds, at which the source animation plays.
    ///
    /// This property is `nil` by default, which plays the animation with `time`
    /// = `0`. If you set a value, the animation edits the duration according to
    /// the specified beginning time.
    ///
    /// If you set a negative value for this property, the duration increases
    /// and the additional animation data fills in based on the
    /// ``AnimationView/fillMode`` you choose.
    public var trimStart: TimeInterval?

    /// The optional time, in seconds, at which the source animation stops.
    ///
    /// This property is `nil` by default, which plays the animation until
    /// `time` = ``BlendTreeAnimation/duration``. If you set a value, the
    /// animation edits the duration according to the specified ending time.
    public var trimEnd: TimeInterval?

    /// An optional duration that overrides the calculated duration.
    ///
    /// The framework calculates ``FromToByAnimation/duration``, but you can set
    /// this property to override it. This property is `nil` by default, which
    /// indicates that the animation stops after one play that spans
    /// ``BlendTreeAnimation/duration``.
    ///
    /// If you set a value for this property and both
    /// ``BlendTreeAnimation/trimStart`` and ``BlendTreeAnimation/trimEnd`` are
    /// `nil`, the animation observes this property as an edited duration.
    ///
    /// A value greater than ``BlendTreeAnimation/duration`` causes the
    /// animation to repeat, applying the characteristics defined by
    /// ``BlendTreeAnimation/repeatMode``. Assign this property
    /// <doc://com.apple.documentation/documentation/swift/double/1849607-greatestfinitemagnitude>
    /// to repeat indefinitely.
    public var trimDuration: TimeInterval?

    /// The time, in seconds, at which the animation begins within the duration.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no offset. Setting a value for this property moves the animation data
    /// along the timeline and doesn't change timing. If you set a
    /// ``BlendTreeAnimation/fillMode`` other than ``AnimationFillMode/none``,
    /// the animation fills the vacant area created by the offset according to
    /// the characteristics of the specified fill mode.
    public var offset: TimeInterval

    /// An amount of time that lapses before the animation plays.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no delay. If you set a value for this property, the animation plays from
    /// its start time after the specified delay lapses.
    ///
    /// During the delayed time, the animation doesn't update. However, to fill
    /// the delayed time with some portion of animation, set a negative
    /// ``BlendTreeAnimation/trimStart`` instead and choose a
    /// ``OrbitAnimation/fillMode`` that displays the desired portion of
    /// animation.
    public var delay: TimeInterval

    /// A factor that increases or decreases the animation’s rate of playback.
    ///
    /// The default value is `1.0`, which doesn’t alter the animation’s rate of
    /// playback. A value of `2.0` plays the animation at twice the normal rate,
    /// and a speed of `0.5` makes the animation finish after twice the normal
    /// time. A negative value plays the animation in reverse.
    ///
    /// This property doesn’t affect the animation’s
    /// ``FromToByAnimation/delay``.
    public var speed: Float

    /// An option that determines how the animation repeats.
    ///
    /// If you call ``BlendTreeAnimation/trimmed(start:end:duration:)`` with a
    /// `start` or `end` that lies outside of the timeline defined by
    /// ``BlendTreeAnimation/duration``, the animation fills the additional
    /// playback by applying this property.
    public var repeatMode: AnimationRepeatMode

    /// The total playback time of the animation.
    ///
    /// The framework sets a value for this property depending on the underlying
    /// animation data and the specified ``AnimationView/speed``.
    ///
    /// You can override the default duration by defining
    /// ``AnimationView/trimStart``, ``AnimationView/trimEnd``, or
    /// ``AnimationView/trimDuration``.
    public var duration: TimeInterval { get }
}

/// A source node for an animation that mixes several animations to form a
/// single animation.
///
/// A _blend tree animation_ mixes multiple animations to form a single
/// animation. The ``BlendTreeBlendNode`` structure adopts the ``BlendTreeNode``
/// protocol, which specifies the behavior of animations that make up a blend
/// tree animation. This structure adds the ability to branch a blend tree at
/// any point. Each member of this property's ``BlendTreeBlendNode/sources``
/// array represents a branch in the tree. For more information about blend
/// trees, see ``BlendTreeAnimation``.
@available(macOS 12.0, iOS 15.0, *)
public struct BlendTreeBlendNode : BlendTreeNode {

    /// Creates a tree node made up of multiple branches.
    ///
    /// - Parameters:
    ///   - sources: The nodes that branch from this node to form part of a blend tree.
    ///
    ///   - name: A textual name for the node.
    ///
    ///   - weight: A normalized percentage that designates how much this node's
    ///     animation influences the tree's blended animation.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     builds on the current state of the target entity or resets the state
    ///     before running.
    public init(sources: [any BlendTreeNode], name: String = "", weight: BlendWeight = .value(1.0), isAdditive: Bool = false)

    /// The nodes that branch from a node to form part of a blend tree.
    ///
    /// This node combines the animations of each member of this array to a
    /// single animation that represents a _blend_ of the sources. If a source
    /// is a ``BlendTreeSourceNode``, this structure blends its animation into
    /// the output. If a source is a ``BlendTreeBlendNode``, this structure
    /// blends the output of its sources into this structure's output.
    public var sources: [any BlendTreeNode]

    /// A Boolean value that indicates whether the animation builds on the
    /// current state of the target entity or resets the state before running.
    public var isAdditive: Bool

    /// A textual name for the blend node.
    public var name: String

    /// A normalized percentage that designates how much effect this node has
    /// compared to peer nodes.
    public var weight: BlendWeight
}

/// A blend tree node that's internal only or sources from an invalid
/// definition.
///
/// This structure adopts ``BlendTreeNode`` and adds the ability to detect a
/// node that contains neither an animation nor any branches in the blend tree.
///
/// You don't create instances of this structure. Instead, detect whether your
/// blend-tree node matches the framework's criteria for invalid nodes by
/// checking the node type, as the following code demonstrates.
///
/// ```swift
/// // Get the blend tree's root node.
/// guard let blendNode = blendTree.root as? BlendTreeBlendNode else { return }
/// for node in blendNode.sources {
///     if let invalidNode = node as? BlendTreeInvalidNode {
///         // Respond to invalid-node criteria.
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct BlendTreeInvalidNode : BlendTreeNode {

    /// A textual name for the blend node.
    public var name: String

    /// The amount that an animation impacts the entity it applies to.
    public var weight: BlendWeight
}

/// An interface for a node that's a member of a blend tree.
///
/// This protocol specifies the common functionality for the animations that
/// compose a ``BlendTreeAnimation``. The animation defines a
/// ``BlendTreeAnimation/root`` node of this type. To define the tree, you
/// assign the root node one of the follow structures that adopt this protocol:
///
/// - ``BlendTreeBlendNode``, which branches the tree for every element in
/// ``BlendTreeBlendNode/sources``.
/// - ``BlendTreeSourceNode``, which defines an
/// animation to blend with its ``BlendTreeSourceNode/source`` property.
///
/// - Note: A node in the tree may be of type ``BlendTreeInvalidNode``, which
/// neither specifies a list of sources nor an animation.
///
/// Each node type supplies a name and weight, which you can set during or after
/// initialization.
///
/// ```swift
/// let animation1 = FromToByAnimation(...)
///
/// let blendNode = BlendTreeSourceNode(
///     source: animation1,
///     name: "Anim1",
///     weight: .value(0.25))
/// ```
@available(macOS 12.0, iOS 15.0, *)
public protocol BlendTreeNode {

    /// A textual name for the blend node.
    var name: String { get set }

    /// A normalized percentage that designates how much effect this node has
    /// relative to peer nodes.
    ///
    /// The value of this property relates to the node's peers in a
    /// ``BlendTreeBlendNode/sources`` array. The sum of all node weights in a
    /// given ``BlendTreeBlendNode/sources`` array needs to equal `1.0`.
    var weight: BlendWeight { get set }
}

/// A blend node that contains an animation.
///
/// This structure adopts ``BlendTreeNode`` and adds the ability to store a
/// single animation. A complete ``BlendTreeAnimation`` represents a mix of all
/// the animations that its source nodes contain. Each source node defines a
/// ``BlendTreeSourceNode/weight`` that determines how much effect the source's
/// animation has in the blend tree's resulting, mixed animation. To define the
/// source's animation, set this structure's ``BlendTreeSourceNode/source``
/// property.
///
/// ### Access a source node of a blend tree
///
/// A source may exist in any leaf-node position in the blend animation's tree.
/// The following code checks the root node for a source. If instead the root
/// node is a branch, the code begins checking the branches sources.
///
/// ```swift
/// // Check if the root node is a source.
/// if let blendNode = blendTree.root as? BlendTreeSourceNode {
///     // Found a source.
///
/// // Check if the root node is a branch.
/// } else if let source = blendTree.root as? BlendTreeBlendNode {
///
///         // Check for a source in the branch's sources.
///         if let source = blendNode.sources[0] as? BlendTreeSourceNode {
///             // Found a source.
///         }
///     }
/// }
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct BlendTreeSourceNode : BlendTreeNode {

    /// Creates a node that defines an animation within a tree of other blend
    /// nodes.
    ///
    /// - Parameters:
    ///   - source: The blend node’s animation.
    ///
    ///   - name: A textual name for the blend node.
    ///
    ///   - weight: A normalized percentage that designates how much effect this
    ///     node has compared to peer nodes.
    public init(source: any AnimationDefinition, name: String = "", weight: BlendWeight = .value(1.0))

    /// The blend node's animation.
    public var source: (any AnimationDefinition)?

    /// A textual name for the blend node.
    public var name: String

    /// A normalized percentage that designates how much effect this node has
    /// compared to peer nodes.
    public var weight: BlendWeight
}

/// A numerical representation of the impact an animation has on a scene or
/// entity.
///
/// The ``BlendTreeSourceNode`` structure accepts this enumeration as an
/// initializer argument.
///
/// To specify a custom weight, use the value case:
///
/// ```swift
/// let node = BlendTreeSourceNode(
///     source: animation1,
///     name: "anim2",
///     weight: .value(0.75))
/// ```
@available(macOS 12.0, iOS 15.0, *)
public enum BlendWeight : Equatable {

    /// The numerical representation of the impact an animation has on an
    /// entity.
    case value(Float)

    /// The amount of impact an animation has on a named parameter of an entity.
    case parameter(String, defaultWeight: Float = 1.0)

    /// The amount of impact  an animation has on the bind target of an entity.
    case bindTarget(BindTarget, defaultWeight: Float = 1.0)

    /// Returns a Boolean value that indicates whether two blend weights are
    /// equal.
    ///
    /// - Parameters:
    ///   - lhs: The blend weight on the left side of the operator.
    ///
    ///   - rhs: The blend weight on the right side of the operator.
    ///
    /// - Returns: Returns `true` if the blend weights are equal. Otherwise,
    /// returns `false`.
    public static func == (lhs: BlendWeight, rhs: BlendWeight) -> Bool
}

/// An axis-aligned bounding box (AABB).
@available(macOS 10.15, iOS 13.0, *)
@frozen public struct BoundingBox : Hashable {

    /// An empty bounding box.
    ///
    /// An empty bounding box is defined with ``min`` set to positive infinity and ``max`` set to negative
    /// infinity.
    ///
    /// - Note: An empty bounding box where ``min`` is greater than ``max`` is different from a bounding
    /// box of size 0, where ``min``  is equal to ``max``. The former defines empty space without a position. The
    /// latter describes an object of size 0 at a certain position in space.
    public static let empty: BoundingBox

    /// The position of the minimum corner of the box.
    public var min: SIMD3<Float>

    /// The position of the maximum corner of the box.
    public var max: SIMD3<Float>

    /// Creates an empty bounding box.
    public init()

    /// Creates a bounding box with the given settings.
    ///
    /// - Parameters:
    ///   - min: The position of the minimum corner of the box.
    ///
    ///   - max: The position of the maximum corner of the box.
    public init(min: SIMD3<Float>, max: SIMD3<Float>)

    /// Indicates whether two bounding boxes are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first box to compare.
    ///
    ///   - rhs: The second box to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two boxes are equal.
    @inlinable public static func == (lhs: BoundingBox, rhs: BoundingBox) -> Bool

    /// Hashes the essential components of the bounding box by feeding them into
    /// the given hash function.
    ///
    /// - Parameters:
    ///   - hasher: The hash function to use when combining the components of the
    ///     box.
    @inlinable public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension BoundingBox {

    public init(_ rect3D: Rect3D)
}

@available(macOS 10.15, iOS 13.0, *)
extension BoundingBox {

    /// The center of the bounding box.
    ///
    /// This value is (0, 0, 0) if the box is empty.
    public var center: SIMD3<Float> { get }

    /// The extents of the bounding box.
    ///
    /// This value is (0, 0, 0) if the box is empty.
    public var extents: SIMD3<Float> { get }

    /// The radius of a bounding sphere that encompasses the bounding box.
    ///
    /// This value is 0 if the box is empty.
    public var boundingRadius: Float { get }

    /// A Boolean that indicates whether the bounding box is empty.
    ///
    /// This value is `true` if the box is empty.
    public var isEmpty: Bool { get }

    /// Creates a bounding box containing the current bounds and the specified
    /// point.
    ///
    /// - Parameters:
    ///   - point: A point in space.
    ///
    /// - Returns: The new bounding box.
    public func union(_ point: SIMD3<Float>) -> BoundingBox

    /// Expands the bounding box to contain the specified point.
    ///
    /// - Parameters:
    ///   - point: A point in space.
    public mutating func formUnion(_ point: SIMD3<Float>)

    /// Creates a bounding box containing the current bounds and the specified
    /// bounds.
    ///
    /// - Parameters:
    ///   - other: Another bounding box.
    ///
    /// - Returns: The new bounding box.
    public func union(_ other: BoundingBox) -> BoundingBox

    /// Expands the bounding box to contain the specified bounds.
    ///
    /// - Parameters:
    ///   - other: Another bounding box.
    public mutating func formUnion(_ other: BoundingBox)

    /// Checks whether the bounding box contains the specified point.
    ///
    /// - Returns: A Boolean that’s `true` if the box contains the specified
    /// point.
    public func contains(_ point: SIMD3<Float>) -> Bool

    /// Checks whether the bounding box contains the specified bounds.
    ///
    /// - Returns: A Boolean that’s `true` if the box contains the specified
    /// bounds.
    public func contains(_ boundingBox: BoundingBox) -> Bool

    /// Checks whether the bounding box intersects the specified bounds.
    ///
    /// - Returns: A Boolean that’s `true` if the box intersects the specified
    /// bounds.
    public func intersects(_ boundingBox: BoundingBox) -> Bool

    /// Transforms the bounding box and finds the bounds of the result.
    ///
    /// - Parameters:
    ///   - transform: The transform to apply to the box.
    ///
    /// - Returns: The bounds of the transformed box.
    public func transformed(by transform: float4x4) -> BoundingBox

    /// Transforms the bounding box.
    ///
    /// - Parameters:
    ///   - transform: The transform to apply to the box.
    public mutating func transform(by transform: float4x4)

    /// Calculates the distance from a point to the bounding box.
    ///
    /// - Parameters:
    ///   - toPoint: The point.
    ///
    /// - Returns: The square of the distance, in meters, from the point to the
    /// box.
    public func distanceSquared(toPoint: SIMD3<Float>) -> Float
}

@available(macOS 10.15, iOS 13.0, *)
extension BoundingBox : Sendable {
}

@available(macOS 10.15, iOS 13.0, *)
extension BoundingBox : BitwiseCopyable {
}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
public struct CameraControls : Hashable, Sendable {

    /// Disable camera control via gestures.
    public static var none: CameraControls { get }

    /// Change the viewing angle by dragging a trackpad or mouse.
    public static var tilt: CameraControls { get }

    /// Move the viewport up, left, right, or down by dragging a trackpad or mouse.
    public static var pan: CameraControls { get }

    /// Move the camera around a target by dragging a trackpad or mouse.
    public static var orbit: CameraControls { get }

    /// Move the camera forward and backward by dragging a trackpad or mouse.
    public static var dolly: CameraControls { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: CameraControls, b: CameraControls) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// The orientations that a camera's field-of-view degrees can apply.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public enum CameraFieldOfViewOrientation {

    /// Applies the field-of-view degrees in the camera's horizontal axis.
    case horizontal

    /// Applies the field-of-view degrees in the camera's vertical axis.
    case vertical

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: CameraFieldOfViewOrientation, b: CameraFieldOfViewOrientation) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension CameraFieldOfViewOrientation : Equatable {
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension CameraFieldOfViewOrientation : Hashable {
}

/// A component that configures channel-based rendering of sounds from an entity.
///
/// Channel audio sources route the audio resource's channels directly to the device's output without any spatialization or reverberation
/// applied. Neither the position nor orientation of the entity is taken into consideration for channel rendering.
/// For example,
/// the left channel is heard from the left,
/// and the right channel is heard from the right,
/// regardless of where the user is oriented.
///
/// The channels of multichannel audio resources are panned according to their channel layout, including rear channels.
///
/// ```swift
/// let entity = Entity()
/// let resource = try AudioFileResource.load(named: "MyAudioFile")
/// entity.channelAudio = ChannelAudioComponent()
/// entity.playAudio(resource)
/// ```
///
/// The `ChannelAudioComponent` allows you to set the overall level of all sounds played from the entity with the `gain` property,
/// in relative Decibels, in the range `-.infinity ... .zero` where `-infinity` is silent and `.zero` is nominal.
///
/// ```swift
/// entity.channelAudio?.gain = -10
/// ```
///
/// Channel audio sources are well suited to play back sounds not associated with any visual elements in a scene.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct ChannelAudioComponent {

    /// The overall level for all sounds emitted from an entity. In relative Decibels, in the range  `-.infinity ... .zero` where
    /// `.zero` is the default.
    public var gain: Audio.Decibel

    /// Configure the behavior of a channel audio source.
    ///
    /// - Parameter gain: The overall level for all sounds emitted from an entity.
    public init(gain: Audio.Decibel = .zero)
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ChannelAudioComponent : Component {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ChannelAudioComponent : Equatable, Hashable, Codable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ChannelAudioComponent, b: ChannelAudioComponent) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A component that manages character movement.
///
/// To use a character controller, add a ``CharacterControllerComponent`` and a ``CharacterControllerStateComponent``
/// to your entity to make it a character entity. Character entities can *move* to new locations in space,
/// which happens over a period of time based on how you've configured the character controller component,
/// and also *teleport*, which moves the charcter to the new location instantaneously.
///
/// - Note: PhysicsBodyComponent and CollisionComponent can not exist on the same Entity that contains
///         a CharacterControllerComponent and are therefore inactivated.
@available(macOS 12.0, iOS 15.0, *)
public struct CharacterControllerComponent : Component {

    /// A container that holds collision state for the character controller.
    ///
    /// All coordinates are in _physics space_, the coordinate system of the physics simulation.
    public struct Collision {

        /// Create Collision and initialize all fields.
        public init(characterEntity: Entity, hitEntity: Entity, hitPosition: SIMD3<Float>, hitNormal: SIMD3<Float>, moveDirection: SIMD3<Float>, moveDistance: Float)

        /// Entity owning the character controller component.
        public var characterEntity: Entity

        /// The entity that was hit by the character controller.
        public var hitEntity: Entity

        /// Hit position relative to physics origin. In physics space.
        public var hitPosition: SIMD3<Float>

        /// Hit normal relative to physics origin. In physics space.
        public var hitNormal: SIMD3<Float>

        /// Move direction controller was moving (unit vector). In physics space.
        public var moveDirection: SIMD3<Float>

        /// Move distance controller was attempting to move. In physics space.
        public var moveDistance: Float
    }

    /// An option set that specifies which parts of the character capsule have collided with other objects.
    public struct CollisionFlags : OptionSet {

        /// Initializes collisions flags from a raw value.
        public init(rawValue: UInt8)

        /// The bitmask representation of the option set.
        public let rawValue: UInt8

        /// No collision.
        public static let none: CharacterControllerComponent.CollisionFlags

        /// The side of capsule was hit when moving in the direction tangent to the up vector.
        public static let side: CharacterControllerComponent.CollisionFlags

        /// The top of capsule was hit when moving in the up direction.
        public static let top: CharacterControllerComponent.CollisionFlags

        /// The bottom of capsule was hit when moving in the down direction.
        public static let bottom: CharacterControllerComponent.CollisionFlags

        /// The type of the elements of an array literal.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias ArrayLiteralElement = CharacterControllerComponent.CollisionFlags

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias Element = CharacterControllerComponent.CollisionFlags

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias RawValue = UInt8
    }

    /// Initializes a character controller component using default values.
    public init()

    /// Initializes a character controller component using specified values.
    public init(radius: Float, height: Float, skinWidth: Float = defaultSkinWidth, slopeLimit: Float = defaultSlopeLimit, stepLimit: Float = defaultStepLimit, upVector: SIMD3<Float> = defaultUpVector, collisionFilter: CollisionFilter = .default)

    /// The capsule radius.
    ///
    /// Specify this value in the entity's coordinate system.
    public var radius: Float

    /// The capsule height.
    ///
    /// The capsule height includes radii and should be specified the entity's coordinate system.
    public var height: Float

    /// An added tolerance around the character capsule.
    ///
    /// A small skin, known as the *contact offset*, is maintained around the controller's volume to avoid
    /// rounding and precision issues with collision detection. Specify this value relative to the entity's
    /// coordinate system.
    public var skinWidth: Float

    /// The slope limit expressed as a limit angle in radians.
    ///
    /// This value represents the maximum slope that the character can move over. RealityKit applies this value
    /// to characters that are walking on static objects, but not when walking on kinematic or dynamic objects.
    ///
    /// Changing this value after the CharacterControllerComponent has been created and added to Entity
    /// has no effect.
    public var slopeLimit: Float

    /// The maximum obstacle height that the controller can move over.
    ///
    /// Specify this value relative to the entity's coordinate system.
    ///
    /// Changing this value after the CharacterControllerComponent has been created and added to Entity
    /// has no effect.
    public var stepLimit: Float

    /// The y-axis direction relative to the physics origin.
    ///
    /// Rotates the object so that the vertical height is along the up vector.
    /// Normalize and specify the vector in *physics space*,
    /// the coordinate system of the physics simulation.
    public var upVector: SIMD3<Float>

    /// The character's collision filter.
    ///
    /// For more information on using collision filters, see <doc://com.apple.documentation/documentation/realitykit/controlling_entity_collisions_in_realitykit>.
    public var collisionFilter: CollisionFilter

    public static let defaultRadius: Float

    public static let defaultHeight: Float

    public static let defaultSkinWidth: Float

    public static let defaultSlopeLimit: Float

    public static let defaultStepLimit: Float

    public static let defaultUpVector: SIMD3<Float>
}

/// A component that represents the state of a character controller.
///
/// RealityKit adds this component to an entity when you add a ``CharacterControllerComponent`` instance to it.
/// Manually adding this component to an entity that has a character controller component has no effect because it's redundant.
@available(macOS 12.0, iOS 15.0, *)
public struct CharacterControllerStateComponent : Component {

    public init()

    /// The linear speed relative to the origin in physics space.
    public let velocity: SIMD3<Float>

    /// A Boolean value that indicates whether the character controller is on the ground.
    public let isOnGround: Bool
}

/// A hit result of a collision cast.
///
/// You get a collection of collision cast hits from either the
/// ``Scene/raycast(origin:direction:length:query:mask:relativeTo:)`` method, or
/// the
/// ``Scene/convexCast(convexShape:fromPosition:fromOrientation:toPosition:toOrientation:query:mask:relativeTo:)``
/// method. Each hit indicates where the ray or the convex shape, starting at a
/// given point and traveling in a given direction, hit a particular entity in
/// the scene.
///
/// The frame of reference for the position and normal of the hit depends on the
/// reference entity parameter passed to the method that generated the hit. Pass
/// `nil` as the reference to use world space.
@available(macOS 10.15, iOS 13.0, *)
public struct CollisionCastHit : Equatable {

    /// The entity that was hit.
    public var entity: Entity { get }

    /// The position of the hit.
    ///
    /// The frame of reference for this point depends on the reference entity
    /// used in the call to either the
    /// ``Scene/raycast(origin:direction:length:query:mask:relativeTo:)`` method
    /// or the
    /// ``Scene/convexCast(convexShape:fromPosition:fromOrientation:toPosition:toOrientation:query:mask:relativeTo:)``
    /// method that generated the hit.
    public var position: SIMD3<Float> { get }

    /// The normal of the hit.
    ///
    /// The frame of reference for this point depends on the reference entity
    /// used in the call to either the
    /// ``Scene/raycast(origin:direction:length:query:mask:relativeTo:)`` method
    /// or the
    /// ``Scene/convexCast(convexShape:fromPosition:fromOrientation:toPosition:toOrientation:query:mask:relativeTo:)``
    /// method that generated the hit.
    public var normal: SIMD3<Float> { get }

    /// The distance from the ray origin to the hit, or the convex shape travel
    /// distance.
    public var distance: Float { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: CollisionCastHit, b: CollisionCastHit) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension CollisionCastHit {

    /// Information returned when ray intersects a triangle mesh.
    public struct TriangleHit : Equatable {

        /// The face index for the mesh face that that the ray hit.
        public var faceIndex: Int { get }

        /// The barycentric uv coordinate for where in the triangle the ray hit.
        public var uv: SIMD2<Float> { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: CollisionCastHit.TriangleHit, b: CollisionCastHit.TriangleHit) -> Bool
    }

    /// Information the system provides when a ray touches or intersects a triangle mesh.
    public var triangleHit: CollisionCastHit.TriangleHit? { get }

    /// The index of the shape that was hit.
    public var shapeIndex: Int { get }
}

/// The kinds of ray and convex shape cast queries that you can make.
@available(macOS 10.15, iOS 13.0, *)
public enum CollisionCastQueryType : Hashable {

    /// Report the closest hit.
    ///
    /// If you only want to test if a hit occurs and don’t care about which hit
    /// out of multiple possible hits is returned, use
    /// ``CollisionCastQueryType/any`` instead because it typically executes
    /// faster.
    case nearest

    /// Report all hits sorted in ascending order by distance from the cast
    /// origin.
    case all

    /// Report one hit.
    ///
    /// This query type typically executes fastest, but doesn’t guarantee
    /// anything about which hit it returns. If you need the hit closest to the
    /// origin of the cast, use ``CollisionCastQueryType/nearest`` instead.
    case any

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: CollisionCastQueryType, b: CollisionCastQueryType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A component that gives an entity the ability to collide with other entities
/// that also have collision components.
///
/// This component holds the entity's data related to participating in the scene's
/// physics simulation. It is also used to calculate collision queries, raycasts, and convex shape casts.
/// Entities can participate in the scene simulation in two different modes: as a *rigid body* or as a
/// *trigger*.  A rigid body fully participates in the collision simulation. It affects the velocity and direction of
/// entities it collides. If configured with a rigid body ``RealityKit/PhysicsBodyComponent/mode``
/// of ``RealityKit/PhysicsBodyMode/dynamic``, it's own velocity and direction can be affected
/// by other rigid body entities. A trigger entity doesn't have any impact on the rigid bodies in the scene, but
/// can trigger code or Reality Composer behaviors when a rigid body entity overlaps it.
///
/// Note the following when considering applying a non-uniform scale to an entity:
/// - Non-uniform scaling is applicable only to box, convex mesh and triangle mesh collision shapes.
/// - Non-uniform scaling is not supported for all other types of collision shapes. In this case the scale.x
/// value is duplicated to the scale's y and z components as well to force scale uniformity based on the x component.
/// - If the entity has a non-uniform scale assigned to its transform then that entity should not
/// have any descendants assigned that contain rotations in their transforms. A good rule of thumb is to
/// assign the non-uniform scale to the entity that has the collision shape, and avoid adding children below
/// that entity.
///
/// Turn an entity into a trigger by adding a ``RealityKit/CollisionComponent`` to it and setting its
/// ``RealityKit/CollisionComponent/mode-swift.property`` to
/// ``RealityKit/CollisionComponent/Mode-swift.enum/trigger``.
///
/// Turn an entity into a _rigd body_ by adding a  ``RealityKit/PhysicsBodyComponent`` to the
/// entity in addition to a ``RealityKit/CollisionComponent``.  The ``PhysicsBodyComponent``
/// defines the physical properties of the entity, such as its mass and collision shape.
///
/// The `filter` property defines the entity's collision filter, which determines which other objects the entity
/// collides with. For more information, see <doc://com.apple.documentation/documentation/realitykit/controlling_entity_collisions_in_realitykit>.
///
/// - Note: If an entity has a ``RealityKit/PhysicsBodyComponent``, the  collision component's
/// mode is ignored. An entity can be a rigid body, or a trigger, but not both at the same time.
@available(macOS 10.15, iOS 13.0, *)
public struct CollisionComponent : Component, Equatable {

    /// A mode that dictates how much collision data is collected for a given
    /// entity.
    public enum Mode {

        /// A default collision object.
        ///
        /// When two objects of this type collide, RealityKit computes the full
        /// contact details (contact points, normal vectors, penetration depths,
        /// and so on) and stores them in the contact set.
        ///
        /// - Note: Collisions will fall through and do not collide by default, to
        ///       enable colliding see the ``colliding`` mode.
        case `default`

        /// A trigger collision object.
        ///
        /// When a collision object of this type collides with any other object,
        /// RealityKit records that contact was made, but does not compute other
        /// details, like contact points, normal vectors, and so on. This makes
        /// a trigger object more performant when all you need is a Boolean
        /// indicator that contact occurred.
        ///
        /// Triggers are not simulated, so if the ``Entity`` also contains ``PhysicsBodyComponent``, `trigger` is ignored.
        case trigger

        /// An environmental collision object.
        ///
        /// Enabling this flag allows collision objects to interact with dynamic
        /// rigid bodies without requiring an extra physicsBody component.
        @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
        case colliding

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: CollisionComponent.Mode, b: CollisionComponent.Mode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A collection of shape resources that collectively represent the outer
    /// dimensions of an entity for the purposes of collision detection.
    public var shapes: [ShapeResource]

    /// The collision mode.
    public var mode: CollisionComponent.Mode

    /// The collision filter used to segregate entities into different collision
    /// groups.
    public var filter: CollisionFilter

    /// Creates a collision component with the given collision shape, mode, and
    /// filter parameters.
    ///
    /// - Parameters:
    ///   - shapes: The collection of shapes that collectively define the outer
    ///     dimensions of the associated entity for the purposes of collision
    ///     detection.
    ///
    ///   - mode: The mode of the collision component.
    ///
    ///   - filter: A filter that limits the other entities with which the entity
    ///     can collide.
    public init(shapes: [ShapeResource], mode: CollisionComponent.Mode = .default, filter: CollisionFilter = .default)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: CollisionComponent, b: CollisionComponent) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension CollisionComponent {

    /// Creates a collision component.
    public init(shapes: [ShapeResource], isStatic: Bool, filter: CollisionFilter = .default)

    /// A Boolean value that indicates whether the collider is static.
    ///
    /// When an object is static the physics engine recognizes that the object isn't moving, which typically improves performance.
    public var isStatic: Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension CollisionComponent {

    /// The options set that defines how a collision object reports collisions.
    public struct CollisionOptions : OptionSet {

        /// An option that reports the default collision information with dynamic collision objects.
        public static let none: CollisionComponent.CollisionOptions

        /// Omits reporting collisions with static collision objects.
        ///
        /// When a collision object is static, it doesn't report collisions with static collision objects,
        /// only with dynamic collision objects.
        /// In contrast, when a collision object is dynamic (not static), it reports collisions with all other collision objects.
        ///
        /// - Note: Static collision objects are more light-weight and improve performance. They should be used
        /// where collisions are tested against these objects, not between these objects.
        public static let `static`: CollisionComponent.CollisionOptions

        /// Reports full contact information for collision events.
        ///
        /// - Note: This does not work with triggers because triggers do not have contact information.
        public static let fullContactInformation: CollisionComponent.CollisionOptions

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: UInt

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: UInt)

        /// The type of the elements of an array literal.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias ArrayLiteralElement = CollisionComponent.CollisionOptions

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias Element = CollisionComponent.CollisionOptions

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias RawValue = UInt
    }

    public init(shapes: [ShapeResource], mode: CollisionComponent.Mode = .default, collisionOptions: CollisionComponent.CollisionOptions, filter: CollisionFilter = .default)

    public var collisionOptions: CollisionComponent.CollisionOptions
}

@available(macOS 10.15, iOS 13.0, *)
extension CollisionComponent.Mode : Equatable {
}

@available(macOS 10.15, iOS 13.0, *)
extension CollisionComponent.Mode : Hashable {
}

@available(macOS 10.15, iOS 13.0, *)
public enum CollisionEvents {

    /// An event raised when two objects collide.
    public struct Began : Event {

        /// The first entity involved in the collision.
        public let entityA: Entity

        /// The second entity involved in the collision.
        public let entityB: Entity

        /// A position representing the estimated point of contact.
        ///
        /// The point is an average calculated from the intersecting shapes.
        /// It’s specified in the coordinate space of the physics simulation,
        /// which means it’s relative to ``PhysicsSimulationComponent/nearestSimulationEntity(for:)``. If the
        /// physics origin is `nil`, the point is given in world space.
        public let position: SIMD3<Float>

        /// The total impulse in this collision pair obtained by adding up all the
        /// individual impulses applied at each contact point.
        public let impulse: Float
    }

    /// An event raised on every frame when two objects are in contact.
    public struct Updated : Event {

        /// The first entity involved in the collision.
        public let entityA: Entity

        /// The second entity involved in the collision.
        public let entityB: Entity

        /// A position representing the estimated point of contact.
        ///
        /// The point is an average calculated from the intersecting shapes.
        /// It’s specified in the coordinate space of the physics simulation,
        /// which means it’s relative to ``PhysicsSimulationComponent/nearestSimulationEntity(for:)``. If the
        /// physics origin is `nil`, the point is given in scene space.
        public let position: SIMD3<Float>

        /// The total impulse in this collision pair obtained by adding up all the
        /// individual impulses applied at each contact point
        public let impulse: Float
    }

    /// An event raised when two objects, previously in contact, separate.
    public struct Ended : Event {

        /// The first entity involved in the collision.
        public let entityA: Entity

        /// The second entity involved in the collision.
        public let entityB: Entity
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension CollisionEvents.Began {

    /// The estimated distance of overlap between the two colliding entities in scene coordinate space.
    ///
    /// This is the maximum penetration distance for all contacts, for more detailed
    /// penetration distance see ``contacts`` and
    /// ``CollisionComponent/CollisionOptions-swift.struct/fullContactInformation``.
    public var penetrationDistance: Float { get }

    /// The direction of the total impulse in scene coordinate space.
    public var impulseDirection: SIMD3<Float> { get }

    /// All contacts between the collision pair. Empty if all contact information is not requested.
    /// @see `CollisionComponent.CollisionOptions.fullContactInformation`
    public var contacts: [Contact] { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension CollisionEvents.Updated {

    /// The estimated distance of overlap between the two colliding entities in scene coordinate space.
    ///
    /// This is the maximum penetration distance for all contacts, for more detailed
    ///        penetration distance see ``contacts`` and
    ///        ``CollisionComponent/CollisionOptions-swift.struct/fullContactInformation``.
    public var penetrationDistance: Float { get }

    /// The direction of the total impulse in scene coordinate space.
    public var impulseDirection: SIMD3<Float> { get }

    /// All contacts between the collision pair. Empty if all contact information is not requested.
    /// @see `CollisionComponent.CollisionOptions.fullContactInformation`
    public var contacts: [Contact] { get }
}

/// A set of masks that determine whether entities can collide during
/// simulations.
///
/// Use Collision filters in combination with collision groups to define which
/// entities collide with which other entities in a scene. For more information
/// on using collision filters, see ``CollisionGroup``
@available(macOS 10.15, iOS 13.0, *)
public struct CollisionFilter : Equatable {

    /// The default collision filter.
    ///
    /// Entities with a ``CollisionFilter/default`` collision filter have a
    /// ``CollisionFilter/group`` of ``CollisionGroup/default`` and a
    /// ``CollisionFilter/mask`` of ``CollisionGroup/all``.
    public static let `default`: CollisionFilter

    /// A collision filter for an entity that collides with everything.
    ///
    /// The sensor collision filter is typically used by rays in ray casts,
    /// shapes in convex shape casts, and trigger volumes. It corresponds to a
    /// ``CollisionFilter/group`` and ``CollisionFilter/mask`` both set to
    /// ``CollisionGroup/all``.
    public static let sensor: CollisionFilter

    /// The collision group or groups, stored as a bit mask, to which the entity
    /// belongs.
    public var group: CollisionGroup

    /// The collision group or groups, stored as a bitmask, with which the
    /// entity can collide.
    public var mask: CollisionGroup

    /// Creates a collision filter.
    ///
    /// Collision filters are created for the collision group specified in the
    /// `group` parameter. The `mask` parameter defines which objects will
    /// collide with the objects that use this filter. Because
    /// ``CollisionGroup`` conforms to
    /// <doc://com.apple.documentation/documentation/swift/optionset>, you can
    /// specify any combination of collision groups in the `mask` parameter by
    /// using the various
    /// <doc://com.apple.documentation/documentation/swift/optionset> methods
    /// like ``CollisionGroup/union(_:)``, ``CollisionGroup/subtracting(_:)``,
    /// and ``CollisionGroup/intersection(_:)``. Entities from any group
    /// contained in `mask` will collide with entities using this filter, while
    /// those not contained by `mask` will not.
    ///
    /// To combine multiple groups into a filter, use the
    /// ``CollisionGroup/union(_:)`` method, like this:
    ///
    /// ```swift
    /// let groupA = CollisionGroup(rawValue: 1 << 0)
    /// let groupB = CollisionGroup(rawValue: 1 << 1)
    /// let groupC = CollisionGroup(rawValue: 1 << 2)
    ///
    /// // Create a filter that collides with A and C, but not B
    /// let theFilter = CollisionFilter(group: groupA, mask: groupA.union(groupB))
    /// ```
    ///
    /// A common use case is to want entities to collide with everything except
    /// one group, or a few groups. In a game, for example, you might not want a
    /// player’s pieces to collide with their own pieces, or you might not want
    /// players on the same team to collide with each other. You can accomplish
    /// that by starting with the ``CollisionGroup/all`` property, subtracting
    /// the group or groups that you don’t want the entities using this filter
    /// to collide with, like this:
    ///
    /// ```swift
    /// // Create a filter that collides with everything except B
    /// let notGroupB = CollisionGroup.all.subtracting(groupB)
    /// ```
    ///
    /// - Parameters:
    ///   - group: The collision group identifier.
    ///
    ///   - mask: The collision mask defines what objects will collide with
    ///     objects using this filter.
    public init(group: CollisionGroup, mask: CollisionGroup)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: CollisionFilter, b: CollisionFilter) -> Bool
}

/// A bitmask used to define the collision group to which an entity belongs.
///
/// You use collision groups along with ``CollisionFilter`` to define custom
/// collision properties for entities in your scene and controlling which
/// entities collide wit which other entities. By default, all entities that
/// participate in the physics simulation collide with all other participating
/// entities. There are times, however, when you need certain entities to not
/// collide with certain other entities, and that’s where collision groups and
/// filters come into play.
///
/// Create individual collision groups using raw bit flag values, like this:
///
/// ```swift
/// let redGroup = CollisionGroup(rawValue: 1 << 0)
/// let blueGroup = CollisionGroup(rawValue: 1 << 1)
/// let greenGroup = CollisionGroup(rawValue: 1 << 2)
/// let yellowGroup = CollisionGroup(rawValue: 1 << 3)
/// ```
///
/// Because ``CollisionGroup`` conforms to
/// <doc://com.apple.documentation/documentation/swift/optionset>, this allows
/// you to create aggregate groups that encompass multiple individual collision
/// groups, like so:
///
/// ```swift
/// let blueAndRedGroup = redGroup.union(blueGroup)
/// let greenAndYellowGroup = greenGroup.union(yellowGroup)
/// ```
///
/// You can also define groups that have all entities except those in specific
/// groups. In a game, for example, you might want to turn off collisions
/// between members of the same team or between pieces owned by the same player.
/// This is what creating that kind of filter would look like:
///
/// ```swift
/// let allButRedGroup = CollisionGroup.all.subtracting(redGroup)
/// ```
///
/// Collision groups aren’t assigned directly to entities. Instead, you create a
/// ``CollisionFilter`` for the group, and then assign that filter to all the
/// entities you wish to include in its group. The collision filter’s mask
/// defines which objects the entities in this group collide with, and all
/// entities that share the same filter are part of the same collision group.
///
/// ```swift
/// let allButRedFilter = CollisionFilter(group: redGroup, mask: allButRedGroup)
/// redTeamPlayer1.collision?.filter = allButRedFilter
/// ```
@available(macOS 10.15, iOS 13.0, *)
public struct CollisionGroup : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: UInt32

    /// The default collision group for objects.
    ///
    /// If no ``CollisionFilter`` is assigned to an entity, that entity will be
    /// part of this default collision group.
    public static let `default`: CollisionGroup

    /// The default collision group for scene-understanding meshes.
    ///
    /// See <doc://com.apple.documentation/documentation/realitykit/realitykit-scene-understanding> for usage and platform availability of ``SpatialTrackingSession/Configuration/SceneUnderstandingCapability``
    /// and ``ARView/Environment/SceneUnderstanding``.
    /// See <doc://com.apple.documentation/documentation/realitykit/realitykit-scene-understanding> for a complete overview of scene-understanding functionality.
    @available(iOS 13.4, *)
    public static let sceneUnderstanding: CollisionGroup

    /// The collision group that represents all groups.
    public static let all: CollisionGroup

    /// Creates a collision group from a raw value.
    ///
    /// This initializer succeeds even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set.
    /// Usually, you will want to create each collision groups setting a
    /// different bit flag for each value, so that multiple individual groups
    /// can be combined using
    /// <doc://com.apple.documentation/documentation/swift/optionset> methods.
    ///
    /// Here is an example of creating four collision groups using different
    /// bitflag values for each one.
    ///
    /// ```swift
    /// let redGroup = CollisionGroup(rawValue: 1 << 0)
    /// let blueGroup = CollisionGroup(rawValue: 1 << 1)
    /// let greenGroup = CollisionGroup(rawValue: 1 << 2)
    /// let yellowGroup = CollisionGroup(rawValue: 1 << 3)
    /// ```
    ///
    /// - Parameters:
    ///   - rawValue: The raw value of the option set to create. Each bit of
    ///     rawValue potentially represents an element of the option set, though raw
    ///     values may include bits that are not defined as distinct values of the
    ///     OptionSet type.
    public init(rawValue: UInt32)

    /// The type of the elements of an array literal.
    @available(iOS 13.0, macOS 10.15, *)
    public typealias ArrayLiteralElement = CollisionGroup

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 13.0, macOS 10.15, *)
    public typealias Element = CollisionGroup

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 13.0, macOS 10.15, *)
    public typealias RawValue = UInt32
}

/// A representation of a geometry or a behavior that you apply to an entity.
///
/// You assemble a particular combination of behavior and appearance for an
/// entity by adding components to the ``Entity/components`` set of an
/// ``Entity`` instance. Each component, represented by a type that conforms to
/// the ``Component`` protocol, defines a single aspect of the entity. For
/// example, one might define a position in space, while another provides a
/// visual appearance. You can add at most one component of a given type to an
/// entity.
///
/// ![Diagram showing the components present in different kinds of
/// entities.](Component-1)
///
/// RealityKit has a variety of predefined component types that you can use to
/// add commonly needed characteristics. For example, the ``ModelComponent``
/// specifies visual appearance with a mesh and materials. The
/// ``CollisionComponent`` contains a shape and other information used to decide
/// if one entity collides with another.
///
/// You can also define custom component types. When you do, register that type
/// with the system by calling the new component’s
/// ``Component/registerComponent()`` method—a default implementation of which
/// is provided by the ``Component`` protocol. Call this method once before
/// using the component type. You don’t need to make this call for component
/// types that RealityKit provides.
@available(macOS 10.15, iOS 13.0, *)
public protocol Component {
}

@available(macOS 10.15, iOS 13.0, *)
extension Component {

    /// Registers a new component type.
    ///
    /// Call the ``DirectionalLightComponent/Shadow/registerComponent()`` method
    /// once for every custom component type that you use in your app before you
    /// use it. You don’t need to call the method for built-in component types,
    /// like ``ModelComponent`` or ``AnchoringComponent``.
    public static func registerComponent()
}

/// Provides the events related to components.
///
/// For more information on subscribing to scene events, see ``RealityKit/Scene/Event``.
@available(macOS 12.0, iOS 15.0, *)
public enum ComponentEvents {

    /// Event raised after a component has been added to an entity,
    public struct DidAdd : Event {

        /// The component's entity.
        public let entity: Entity

        /// The component type.
        public let componentType: any Component.Type
    }

    /// Event raised after a component has been activated.
    public struct DidActivate : Event {

        /// The component's entity.
        public let entity: Entity

        /// The component type.
        public let componentType: any Component.Type
    }

    /// Event raised before a component is deactivated.
    public struct WillDeactivate : Event {

        /// The component's entity.
        public let entity: Entity

        /// The component type.
        public let componentType: any Component.Type
    }

    /// Event raised before a component is removed from an entity.
    public struct WillRemove : Event {

        /// The component's entity.
        public let entity: Entity

        /// The component type.
        public let componentType: any Component.Type
    }

    /// Event raised after a component has been modified.
    public struct DidChange : Event {

        /// The component's entity.
        public let entity: Entity

        /// The component type.
        public let componentType: any Component.Type
    }
}

/// A force effect that exerts a constant force in a direction relative to the effect's transform.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ConstantForceEffect : ForceEffectProtocol, Codable {

    /// Creates a constant force effect.
    ///  - Parameters:
    ///     - strength: The magnitude of the force.
    ///     - direction: The direction of the force relative to the effect's transform.
    public init(strength: Double, direction: SIMD3<Float>)

    /// Calculates the constant forces for rigid bodies from the force effect.
    ///
    /// - Parameter parameters: On input, the parameters that calculate forces to the affected physics bodies; on output, the updates to those forces.
    ///
    /// The framework automatically calls this method for you at each physics simulation step,
    /// so you don't need to call it yourself.
    public func update(parameters: inout ForceEffectParameters)

    /// The magnitude of the force.
    public let strength: Float

    /// The direction of the force relative to the effect's transform.
    public let direction: SIMD3<Float>

    /// The input rigid body parameters.
    public var parameterTypes: PhysicsBodyParameterTypes { get }

    /// The type of force this effect applies.
    public var forceMode: ForceMode

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A force effect that pulls objects toward its center with a constant strength.
///
/// This force's magnitude is constant and does not depend on objects' distances to the effect origin.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ConstantRadialForceEffect : ForceEffectProtocol, Codable {

    /// Creates a radial force effect with constant magnitude.
    ///  - Parameters:
    ///     - strength: The magnitude of the force.
    public init(strength: Double)

    /// Calculates the radial forces with constant magnitude for rigid bodies from the force effect.
    ///
    /// - Parameter parameters: On input, the parameters that calculate forces to the affected physics bodies; on output, the updates to those forces.
    ///
    /// The framework automatically calls this method for you at each physics simulation step,
    /// so you don't need to call it yourself.
    public func update(parameters: inout ForceEffectParameters)

    /// The magnitude of the force.
    public let strength: Float

    /// The input rigid body parameters.
    public var parameterTypes: PhysicsBodyParameterTypes { get }

    /// The type of force this effect applies.
    public var forceMode: ForceMode

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// Events associated with collisions.
///
/// To subscribe to a collision event, import Combine, create a property of type <doc://com.apple.documentation/documentation/combine/cancellable>
/// so that you maintain a reference to the subscription, then call ``RealityKit/Scene/subscribe(to:on:_:)``
/// or ``RealityKit/Scene/subscribe(to:on:componentType:_:)`` and provide a closure.
///
/// The closure is passed an ``RealityKit/Scene/Event`` object that contains information relevant to the type of event you subscribed to.
///
/// Here's an example of subscribing to the collision begain event and retrieving the two entities involved in the collision:
///
/// ```swift
///  import AppKit
///  import RealityKit
///  import Combine
///
///  class GameViewController: NSViewController {
///
///      @IBOutlet var arView: ARView!
///      var collisionSubscription:Cancellable?
///
///      override func awakeFromNib() {
///         let boxAnchor = try! Experience.loadBox()
///         arView.scene.anchors.append(boxAnchor)
///
///         collisionSubscription = arView.scene.subscribe(
///            to: CollisionEvents.Began.self,
///             on: boxAnchor
///        ) { event in
///            print("collision started")
///            let firstEntity = event.entityA
///            let secondEntity = event.entityB
///            // Take appropriate action...
///         }
///    }
///  }
/// ```
///
/// You can also create a function to respond to the event rather than a closure by using
/// <doc://com.apple.documentation/documentation/combine/publisher/sink(receivecompletion:receivevalue:)>.
/// Here's an example of using a function to respond to a collision event:
///
/// ```swift
/// import AppKit
/// import RealityKit
/// import Combine
///
/// class GameViewController: NSViewController {
///
///     @IBOutlet var arView: ARView!
///     var collisionSubscription:Cancellable?
///
///     override func awakeFromNib() {
///         let boxAnchor = try! Experience.loadBox()
///         arView.scene.anchors.append(boxAnchor)
///
///         collisionSubscription = arView.scene.publisher(for: CollisionEvents.Began.self,
///                                                        on:nil).sink(receiveValue: onCollisionBegan)
///     }
///
///     private func onCollisionBegan(_ event:
///                                   CollisionEvents.Began) {
///         print("collision started")
///         let firstEntity = event.entityA
///         let secondEntity = event.entityB
///         // Take appropriate action...
///     }
/// }
/// ```
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct Contact : Sendable {

    /// Point of contact in scene coordinate space.
    public let point: SIMD3<Float>

    /// The normal of the contacting surfaces at the contact point. The normal direction points from the
    /// second shape to the first shape in scene coordinate space.
    public let normal: SIMD3<Float>

    /// Impulse, the force over time of the collision, in newton-seconds
    public let impulse: Float

    /// Impulse direction in scene coordinate space.
    public let impulseDirection: SIMD3<Float>

    /// The distance of overlap between the contact pair.
    public let penetrationDistance: Float
}

/// An entity that casts a virtual light in a particular direction.
///
/// During an AR session, RealityKit automatically lights your virtual objects
/// to match real-world lighting.
/// You can also explicitly add virtual lights that act upon your virtual content.
/// This is typically most useful outside of an AR session on iOS or macOS,
/// where your ``RealityViewCameraContent`` ``RealityViewCameraContent/camera``
/// property is set to ``RealityViewCamera/virtual``.
///
/// A directional light uniformly casts light along its local z-axis—specifically,
/// along `[0, 0, -1]`.
/// This is equivalent to creating an ``Entity``, and then adding
/// a ``DirectionalLightComponent`` to its ``Entity/components`` set.
/// Use the light’s ``HasTransform/look(at:from:upVector:relativeTo:)``
/// method to aim the light in a particular direction.
///
/// You can configure the light’s color and intensity with the component properties
/// in ``HasDirectionalLight/light``.
/// You can also control how or if it casts a ``HasDirectionalLight/shadow``.
///
/// A RealityKit scene can contain up to eight dynamic lights, which are
/// entities that contain a
/// ``SpotLightComponent``, ``PointLightComponent``, or a ``DirectionalLightComponent``.
/// This limit doesn’t include light from image-based lighting.
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
@MainActor @preconcurrency public class DirectionalLight : Entity, HasDirectionalLight {

    /// Creates a new entity.
    @MainActor @preconcurrency required public init()
}

/// A component that defines a directional light source.
///
/// A directional light shines in the entity's forward direction `[0, 0, -1]`.
///
/// Change the a directional light's direction with the ``Entity/orientation`` or
/// ``HasTransform/look(at:from:upVector:relativeTo:)`` method
/// of the ``Entity`` with a `DirectionalLightComponent`.
/// The position of the entity does not play a part in the directional light's effect.
///
/// - Tip: Turn on shadows for a directional light by adding the ``Shadow`` component
///   to an entity that has a `DirectionalLightComponent`.
///
/// Use this component with shadows by adding `DirectionalLightComponent`
/// and ``Shadow`` to an entity's ``Entity/components`` set.
/// In this example, the light's color is red, and the intensity is `10_000`,
/// which is an approximate lux for ambient daylight:
///
/// ```swift
/// let lightEntity = Entity()
///
/// let redLightComponent = DirectionalLightComponent(
///     color: .red, intensity: 10_000
/// )
/// let lightShadowComponent = DirectionalLightComponent.Shadow()
/// lightEntity.components.set([redLightComponent, lightShadowComponent])
/// ```
///
/// The directional light illuminates entities evenly in the direction it derives from the orientation of `lightEntity`.
/// Here is a visual example of how the above code snippet could illuminates entities in a scene:
///
/// | Without a directional light | With a directional light |
/// |:-:|:-:|
/// | ![A screenshot of a RealityKit scene with a dark gray floor, a light gray cube. There is no obvious lighting in the scene, so the edges of the cube are not clear.](directionallight-cube-off) | ![A screenshot of a RealityKit scene with a dark gray floor, a light gray cube, and five small green arrows in a row above the cube. There is a red light uniformly affecting the scene from above, casting a shadow to the right of the cube.](directionallight-cube-on) |
///
/// - Note: The green arrows in the above illustration are only a visual representation of the light's direction.
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
public struct DirectionalLightComponent : Component, Equatable {

    /// A directional light component that adds shadows to entities that it illuminates
    public struct Shadow : Component, Equatable {

        /// A constant value that RealityKit applies as a bias to its shadow calculations.
        ///
        /// Reduce visual effects such as _shadow acne_, by adjusting this property.
        /// The default value is `1.0`.
        public var depthBias: Float

        /// Creates a directional light shadow using default values.
        public init()

        /// Creates a directional light shadow with a maximum distance and depth
        /// bias.
        ///
        /// The `maximumDistance` parameter in this initializer
        /// is equivalent to setting ``shadowProjection`` to
        /// `.automatic(maximumDistance: maximumDistance)`.
        ///
        /// - Parameters:
        ///   - maximumDistance: The maximum distance for the shadow.
        ///   - depthBias: The depth bias for the shadow.
        public init(maximumDistance: Float = 5.0, depthBias: Float = 1.0)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: DirectionalLightComponent.Shadow, b: DirectionalLightComponent.Shadow) -> Bool
    }

    /// The intensity of the directional light, measured in lumen per square
    /// meter.
    ///
    /// Lumen per square meter, also known as lux,
    /// measures how much light is spread over an area.
    /// It tells you how bright a surface appears based on the light it receives.
    ///
    /// The default value for this property is `2145.7078`.
    ///
    /// Use the following table as an estimate for Lux levels:
    ///
    /// | Environment | Typical Lux Level   |
    /// |:-|:-|
    /// | Full moon | 0.1 - 1 lux |
    /// | Street lighting | 10 - 20 lux |
    /// | Living room lighting | 50 - 100 lux |
    /// | Classroom | 250 - 750 lux |
    /// | Office lighting | 300 - 500 lux |
    /// | Sunrise/Sunset on a clear day | 400 lux |
    /// | Overcast daylight | 1000 - 2000 lux |
    /// | Photography studio lighting | 1,000 - 2,000 lux |
    /// | Ambient daylight | 10,000 - 25,000 lux |
    /// | Direct sunlight | 32,000 - 100,000 lux |
    public var intensity: Float

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: DirectionalLightComponent, b: DirectionalLightComponent) -> Bool
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension DirectionalLightComponent.Shadow {

    public typealias ShadowMapCullMode = MaterialParameterTypes.FaceCulling

    /// The light's culling mode for shadow map rendering.
    public var cullModeOverride: DirectionalLightComponent.Shadow.ShadowMapCullMode?

    public enum ShadowProjectionType : Equatable {

        /// Shadow projection is manually set up with near plane, far plane, and orthographicScale for width and height
        case fixed(zNear: Float = 0.01, zFar: Float = 10, orthographicScale: Float = 1)

        /// Shadow projection is automatically fit with the camera frustum, range is within maximumDistance from camera
        case automatic(maximumDistance: Float = 5)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: DirectionalLightComponent.Shadow.ShadowProjectionType, b: DirectionalLightComponent.Shadow.ShadowProjectionType) -> Bool
    }

    /// Sets the shadow projection used for shadow map rendering
    public var shadowProjection: DirectionalLightComponent.Shadow.ShadowProjectionType

    /// Creates a directional light shadow with a shadow projection, depth bias and cull mode.
    ///
    /// - Parameters:
    ///   - shadowProjection: The shadow projection used for shadow map rendering.
    ///   - depthBias: The depth bias for the shadow.
    ///   - cullMode: The mode used to cull faces when generating the shadow.
    public init(shadowProjection: DirectionalLightComponent.Shadow.ShadowProjectionType, depthBias: Float, cullMode: DirectionalLightComponent.Shadow.ShadowMapCullMode? = nil)
}

/// A component that docks a scene within a region of an immersive space.
///
/// ## Overview
///
/// A docking-region component establishes a fixed area within an immersive environment that an
/// <doc://com.apple.documentation/documentation/avkit/avplayerviewcontroller>
/// window scene anchors to, which prevents a person from moving the window with a pinch-and-drag gesture.
///
/// To anchor dockable scenes, attach a `DockingRegionComponent` to an entity. The entity's position represents the
/// docking position. Specify the width to set the docking boundary; the docking region maintains a cinematic `2.4:1`
/// width/height ratio, ideal for wide display formats.
///
/// The following code is an example of a basic setup for a `DockingRegionComponent`:
///
///```swift
/// // Create an entity.
/// let entity = Entity()
///
/// // Create a docking-region component.
/// var dockingRegionComponent = DockingRegionComponent()
///
/// // Set entity's position as the docking position, in meters.
/// entity.position = [0, 10, -65]
///
/// // Set the width of the docking boundary to 75 meters.
/// dockingRegionComponent.width = 75
///
/// // Attach the docking-region component to the entity.
/// entity.components.set(dockingRegionComponent)
/// ```
///
/// In the example below, the video player docks in a built-in sky dome scene from Reality Composer Pro:
///
/// @Video(
///     source: dockingregioncomponent-docking,
///     alt: "A screen recording of a video player docking in a built-in sky dome scene from Reality Composer Pro",
///     poster: dockingregioncomponent-docking-poster
/// )
///
@available(visionOS 2.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
public struct DockingRegionComponent : Component {

    /// The width of the docking region, in meters.
    ///
    /// - Note: The docking region maintains a cinematic `2.4:1`
    /// width/height ratio.
    public var width: Float

    /// Creates a docking-region component.
    public init()
}

/// A force effect that slows bodies within its area of effect
/// with a force proportional to the body's velocity.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct DragForceEffect : ForceEffectProtocol, Codable {

    /// Creates a drag force effect.
    ///  - Parameters:
    ///     - strength: The magnitude of the force.
    public init(strength: Double)

    /// Calculates the drag forces for rigid bodies from the force effect.
    ///
    /// - Parameter parameters: On input, the parameters that calculate forces to the affected physics bodies; on output, the updates to those forces.
    ///
    /// The framework automatically calls this method for you at each physics simulation step,
    /// so you don't need to call it yourself.
    public func update(parameters: inout ForceEffectParameters)

    /// The magnitude of the force.
    public let strength: Float

    /// The input rigid body parameters.
    public var parameterTypes: PhysicsBodyParameterTypes { get }

    /// The type of force this effect applies.
    public var forceMode: ForceMode

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A component that controls an entity's shadow from dynamic (virtual) lights.
///
/// Use `DynamicLightShadowComponent` to control whether an entity casts shadows from
/// dynamic (virtual) lights.
/// Dynamic lights cast shadows on other virtual objects, but not on physical objects.
/// You can add a dynamic light shadow component to any entity
/// that has a ``ModelComponent`` in its component set by adding a dynamic light shadow
/// component to the entity's ``Entity/components`` property.
///
/// ```swift
/// if let model = try? await ModelEntity(named: "tv_retro") {
///     let shadowComponent = DynamicLightShadowComponent(castsShadow: false)
///     model.components.set(shadowComponent)
/// }
/// ```
///
/// You need to add the dynamic lights shadow component to each entity you want to
/// apply the effect to because the dynamic light shadow component doesn't apply to
/// hierarchies.
///
///  - Note: By default, without a dynamic light shadow component, entities cast
///  shadows from dynamic lights.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct DynamicLightShadowComponent : Component {

    /// A Boolean value that indicates whether an entity casts a shadow.
    public var castsShadow: Bool

    /// Creates a dynamic light shadow component.
    ///
    /// - Parameter castsShadow: A Boolean value that indicates whether an entity
    /// with the component casts a shadow.
    ///
    /// By default, the component makes an entity to stop casting shadows 
    /// from dynamic lights.
    public init(castsShadow: Bool)
}

/// An action that performs an animation to call attention to an entity.
///
/// This action plays a preexisting animation, dependent on the ``EmphasizeAction/style``
/// and ``EmphasizeAction/motionType`` options.
///
/// The example below creates an animation that causes the entity to bounce in a
/// playful style.
///
/// ```swift
/// // An action that performs a bounce motion in a playful style.
/// let emphasizeAction = EmphasizeAction(motionType: .bounce,
///                                       style: .playful,
///                                       isAdditive: false)
///
/// // A five second animation that plays the preexisting animation.
/// //
/// // This animation causes the entity to raise up, and then drop,
/// // appearing to bounce on the ground in a playful style,
/// // before returning to its original position.
/// let playfulBounceAnimation = try AnimationResource
///     .makeActionAnimation(for: emphasizeAction,
///                          duration: 5.0,
///                          bindTarget: .transform)
///
/// // Play the five second emphasize animation that causes the entity to
/// // bounce in a playful style.
/// entity.playAnimation(playfulBounceAnimation)
/// ```
///
/// @Video(
///     source: emphasizeaction-bounce,
///     alt: "A screen recording of a red cube in a living room scene. At the start, the cube begins to raise up in a whimsical motion, and then drops, appearing to bounce. This motion is repeated twice more, before returning to its original position.",
///     poster: emphasizeaction-bounce-poster
/// )
///
/// - Important: This action directly animates the ``BindTarget/transform`` on the bound entity.
///              Ensure a correct bind target is supplied when creating the animation.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct EmphasizeAction : EntityAction, Codable {

    /// Options available to determine the kinds of animation timing.
    ///
    /// The ``EmphasizeAction`` structure accepts this enumeration as an
    /// initializer argument.
    public enum EmphasisAnimationStyle : Int, Codable {

        /// Animates with steady motion.
        case basic

        /// Animates with whimsical motion.
        case playful

        /// Animates with sporadic motion.
        case wild

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    /// Options available to determine the kinds of animation effects.
    ///
    /// The ``EmphasizeAction`` structure accepts this enumeration as an
    /// initializer argument.
    public enum EmphasisMotionType : Int, Codable {

        /// Grows like an inflating bubble before shrinking as if popped.
        case pop

        /// Scales vertically, mimicking an eye blinking.
        case blink

        /// Raises up and then drops, appearing to bounce on the ground.
        case bounce

        /// Raises up and rotates around a central axis before returning to its original position.
        case flip

        /// Raises up and levitates for a moment before returning to its original position.
        case float

        /// Oscillates back and forth before returning to its original place.
        case jiggle

        /// Scales larger and smaller like a heartbeat.
        case pulse

        /// Rotates around its central y-axis and returns to its original pose.
        case spin

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    /// An option that implements animation effects.
    public var motionType: EmphasizeAction.EmphasisMotionType

    /// An option that implements different kinds of animation timing.
    public var style: EmphasizeAction.EmphasisAnimationStyle

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public var animatedValueType: (any AnimatableData.Type)? { get }

    /// A Boolean value that indicates whether the animation system additively blends the action's output with the base value.
    public var isAdditive: Bool

    /// Creates a new emphasize action.
    ///
    /// - Parameters:
    ///   - motionType: An option that implements animation effects.
    ///   - style: An option that implements different kinds of animation timing.
    ///   - isAdditive: A Boolean value that indicates whether the animation system additively blends 
    ///                 the action's output with the base value.
    public init(motionType: EmphasizeAction.EmphasisMotionType, style: EmphasizeAction.EmphasisAnimationStyle = .basic, isAdditive: Bool = false)

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EmphasizeAction.EmphasisAnimationStyle : Equatable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EmphasizeAction.EmphasisAnimationStyle : Hashable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EmphasizeAction.EmphasisAnimationStyle : RawRepresentable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EmphasizeAction.EmphasisMotionType : Equatable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EmphasizeAction.EmphasisMotionType : Hashable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EmphasizeAction.EmphasisMotionType : RawRepresentable {
}

/// An element of a RealityKit scene to which you attach components that provide
/// appearance and behavior characteristics for the entity.
///
/// You create and configure entities to embody objects that you want to place
/// in the real world in an AR app. You do this by adding ``Entity`` instances
/// to the ``Scene`` instance associated with an ``ARView``.
///
/// RealityKit defines a few concrete subclasses of ``Entity`` that provide
/// commonly used functionality. For example, you typically start by creating an
/// instance of ``AnchorEntity`` to anchor your content, and add the anchor to a
/// scene’s ``Scene/anchors`` collection. You might then instantiate a
/// ``ModelEntity`` to represent a physical object in the scene, and add that as
/// a child entity to the anchor. You can also create custom entities, and add
/// them either to an anchor, or as children of another entity.
///
/// ![Block diagram showing how entity hierarchies, composed of different kinds
/// of entities, attach to a scene, which is itself a child of the AR
/// view.](Entity-1)
///
/// You can load predefined entities or a hierarchy of entities from your app’s
/// bundle, or from a file on disk, using the methods in <doc:stored-entities>.
/// Alternatively, you can create entities programmatically.
///
/// Entities contain components (instances conforming to the ``Component``
/// protocol) that provide appearance and behaviors for the entity. For example,
/// the ``Transform`` component contains the scale, rotation, and translation
/// information needed to position an entity in space. You store components in
/// the entity’s ``Entity/components`` collection, which can hold exactly one of
/// any component type. It makes sense to have only a single ``Transform``
/// component, one ``ModelComponent`` (specifying the visual appearance of the
/// entity), and so on.
///
/// ![Diagram showing the components present in the base entity class, as well
/// as in the derived anchor entity and model entity classes.](Entity-2)
///
/// All entities inherit a few common components from the ``Entity`` base class:
/// the ``Transform`` component for spatial positioning, and
/// ``SynchronizationComponent``, which enables synchronization of the entity
/// among networked peers. Specific types of entities define additional
/// behaviors. For example, the model entity has components for visual
/// appearance (``ModelComponent``), collision detection
/// (``CollisionComponent``), and physics simulations (``PhysicsBodyComponent``
/// and ``PhysicsMotionComponent``).
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency open class Entity : HasHierarchy, HasSynchronization, HasTransform, Sendable {

    /// All the components that an entity stores.
    ///
    /// You can only store one component of a given type on an entity.
    @MainActor @preconcurrency public var components: Entity.ComponentSet

    /// The scene that owns the entity.
    ///
    /// An entity belongs to a scene if the entity is part of a hierarchy that’s
    /// rooted in the scene’s ``Scene/anchors`` collection.
    ///
    /// The value of the property is `nil` if the entity isn’t currently
    /// attached to any scene.
    @MainActor @preconcurrency public var scene: Scene? { get }

    /// The name of the entity.
    ///
    /// You can find an entity by name in a scene by calling the scene’s
    /// ``Scene/findEntity(named:)`` method. Or you can recursively search among
    /// the children of a given entity by calling the entity’s
    /// ``Entity/findEntity(named:)`` method.
    ///
    /// Entity names are not guaranteed to be unique. When you search by name,
    /// these methods return the first entity encountered with the given name.
    @MainActor @preconcurrency public var name: String

    /// A Boolean that indicates whether the entity is active.
    ///
    /// The value of this property is `true` if the entity is anchored in a
    /// scene, and it and all of its ancestors are enabled (``Entity/isEnabled``
    /// is set to `true`). RealityKit doesn’t simulate or render inactive
    /// entities.
    @MainActor @preconcurrency public var isActive: Bool { get }

    /// A Boolean that indicates whether the entity is anchored.
    ///
    /// The value of this property is `true` if the entity is anchored in a
    /// scene. An entity that isn’t anchored becomes inactive
    /// (``Entity/isActive`` returns `false`), meaning RealityKit doesn’t render
    /// or simulate it.
    @MainActor @preconcurrency public var isAnchored: Bool { get }

    /// A Boolean that you set to enable or disable the entity and its
    /// descendants.
    ///
    /// Set this value to `true` to enable the entity. Unless an ancestor is
    /// disabled, the entity and all of its enabled descendants, up to the first
    /// that’s disabled, report ``Entity/isEnabledInHierarchy`` of `true`. If an
    /// ancestor is disabled, they all report `false`. The state of
    /// ``Entity/isActive`` for enabled entities is `true` if they are anchored,
    /// or `false` otherwise.
    ///
    /// If you disable an entity, it and all of its descendants become both
    /// disabled (``Entity/isEnabledInHierarchy`` returns `false`) and inactive
    /// (``Entity/isActive`` returns `false`), regardless of any other state.
    ///
    /// When an entity is disabled, it's no longer visible in your scene. However, the entity is still included in an ``RealityKit/EntityQuery``.
    @MainActor @preconcurrency public var isEnabled: Bool

    /// A Boolean that indicates whether the entity and all of its ancestors are
    /// enabled.
    ///
    /// The value of this property is `true` if the entity and all of its
    /// ancestors are enabled, regardless of anchor state.
    @MainActor @preconcurrency public var isEnabledInHierarchy: Bool { get }

    /// Creates a new entity.
    @MainActor @preconcurrency required public init()

    /// Tells a newly cloned entity that cloning is complete.
    ///
    /// This method clones all component data automatically. When you clone an
    /// entity that stores custom data that’s not part of a component, override
    /// the ``Entity/didClone(from:)`` method to copy that data manually after
    /// the clone finishes.
    ///
    /// - Parameters:
    ///   - source: The entity from which the cloned entity was copied.
    @MainActor @preconcurrency open func didClone(from source: Entity)

    /// Recursively searches all descendant entities for one with the given
    /// name.
    ///
    /// The ``Entity/findEntity(named:)`` method conducts a depth-first,
    /// recursive search over all of the entity’s descendants for one whose
    /// ``Entity/name`` property matches the given name. The method returns the
    /// first match. Entity names need not be unique.
    ///
    /// - Parameters:
    ///   - name: The entity name for which to search.
    ///
    /// - Returns: An entity with the given name, or `nil` if no entity is
    /// found.
    @MainActor @preconcurrency public func findEntity(named name: String) -> Entity?
}

@available(macOS 12.0, iOS 15.0, *)
extension Entity {

    @MainActor @preconcurrency public var bindableValues: BindableValuesReference
}

@available(macOS 12.0, iOS 15.0, *)
extension Entity {

    /// Represents a reference to the parameters for a particular entity.
    ///
    /// Note this struct is a reference and does not have copy-on-write semantics.
    public struct ParameterSet {

        /// Accessor for the parameters, returns a bindable value.
        @MainActor @preconcurrency public subscript<T>(name: String, type: T.Type = T.self) -> BindableValue<T>? where T : BindableData
    }

    /// Represents a reference to the parameters for a particular entity.
    @MainActor @preconcurrency public var parameters: Entity.ParameterSet
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension Entity {

    /// Resolves the entity from the given entity path.
    ///
    /// - Parameters:
    ///   - entityPath: The entity path to resolve.
    @MainActor @preconcurrency public subscript(entityPath: BindTarget.EntityPath) -> Entity? { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity : RealityCoordinateSpace {
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// A collection of components that an entity stores.
    ///
    /// A `ComponentSet` represents all the components that an entity holds.
    /// Use this set to add, remove, and update components on an entity.
    /// This set can hold one component of each type.
    ///
    /// Access the `ComponentSet` of an ``Entity``
    /// using its ``Entity/components`` property.
    ///
    /// `ComponentSet` conforms to
    /// <doc://com.apple.documentation/documentation/swift/sequence>,
    /// allowing you to iterate over it to access and use each component, as the example below shows:
    ///
    /// ```swift
    /// for component in entity.components {
    ///     print(component)
    /// }
    /// ```
    @MainActor @preconcurrency public struct ComponentSet {

        /// Gets or sets the component of the specified type.
        @MainActor @preconcurrency public subscript<T>(componentType: T.Type) -> T? where T : Component

        /// Gets or sets the component with a specific dynamically supplied type.
        @MainActor @preconcurrency public subscript(componentType: any Component.Type) -> (any Component)?

        /// Adds a new component to the set, or overrides an existing one.
        ///
        /// - Parameter component: The component to add.
        @MainActor @preconcurrency public func set<T>(_ component: T) where T : Component

        /// Adds multiple components to the set,
        /// overriding any existing components of the same type.
        ///
        /// If the input array includes multiple components of the same type,
        /// the set adds the component with the highest index.
        /// This is because the set can only hold one component of each type.
        ///
        /// - Parameter components: An array of components to add.
        @MainActor @preconcurrency public func set(_ components: [any Component])

        /// Returns a Boolean value that indicates whether the set contains a
        /// component of the given type.
        ///
        /// - Parameters:
        ///   - componentType: A component type, like `ModelComponent.Self`.
        ///
        /// - Returns: A Boolean value that’s `true` if the set contains a component
        /// of the given type.
        @MainActor @preconcurrency public func has(_ componentType: any Component.Type) -> Bool

        /// Removes the component of the specified type from the collection.
        @MainActor @preconcurrency public func remove(_ componentType: any Component.Type)

        /// Removes all components from the collection.
        @MainActor @preconcurrency public func removeAll()

        /// The number of components in the collection.
        @MainActor @preconcurrency public var count: Int { get }
    }
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity : CustomDebugStringConvertible {

    /// A human readable description of the entity.
    @MainActor @preconcurrency public var debugDescription: String { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// The list of animations associated with the entity.
    ///
    /// When you import an entity from a file, for example by using the
    /// ``Entity/load(named:in:)`` method, the entity might contain associated
    /// animations. Any that RealityKit supports appear in the
    /// ``Entity/availableAnimations`` array.
    ///
    /// To play a particular animation resource from the list, call the
    /// ``Entity/playAnimation(_:transitionDuration:startsPaused:)`` method.
    /// Alternatively, to play all animations with a given name, call the
    /// `playAnimation(named:transitionDuration:startsPaused:)` method instead.
    @MainActor @preconcurrency public var availableAnimations: [AnimationResource] { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity {

    /// The component that configures the spatial rendering of sounds from this entity.
    @MainActor @preconcurrency public var spatialAudio: SpatialAudioComponent?
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension Entity {

    /// Prepares and plays a real-time audio playback instance.
    /// 
    /// Maintain playback by keeping a reference to the generator controller.
    /// 
    /// - Parameters:
    ///   - configuration: A set of configuration parameters necessary for initializing and rendering the `generatorRenderHandler`.
    ///   - generatorRenderHandler: The audio render handler to play. The system runs this handler to generate real-time audio.
    ///
    /// - Returns: An ``AudioGeneratorController`` instance that you use to manage audio 
    ///   playback. Use the controller to set the volume and start or stop playback.
    @MainActor @preconcurrency public func playAudio(configuration: AudioGeneratorConfiguration = .init(), _ generatorRenderHandler: @escaping Audio.GeneratorRenderHandler) throws -> AudioGeneratorController

    /// Prepares a real-time audio playback instances.
    ///  
    /// If you want to start playback immediately, use the
    /// ``Entity/playAudio(configuration:_:)`` method instead.
    ///  
    /// - Parameters:
    ///   - configuration: A set of configuration parameters necessary for initializing and rendering the `generatorRenderHandler`.
    ///   - generatorRenderHandler: The audio render handler to prepare. The system runs this handler to generate real-time audio.
    ///
    /// - Returns: An ``AudioGeneratorController`` instance that you use to manage audio playback. Use the controller to set the volume and start or stop playback.
    @MainActor @preconcurrency public func prepareAudio(configuration: AudioGeneratorConfiguration = .init(), _ generatorRenderHandler: @escaping Audio.GeneratorRenderHandler) throws -> AudioGeneratorController
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// A collection of child entities.
    @MainActor @preconcurrency public struct ChildCollection : Collection {

        /// A type representing the sequence's elements.
        public typealias Element = Entity

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = Int

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = DefaultIndices<Entity.ChildCollection>

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public typealias Iterator = Entity.ChildCollection.IndexingIterator<Entity.ChildCollection>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        public typealias SubSequence = Slice<Entity.ChildCollection>

        /// Returns an iterator over the elements of the collection.
        @MainActor @preconcurrency public func makeIterator() -> Entity.ChildCollection.Iterator

        /// The position of the first element in a nonempty collection. (See `Collection.startIndex`.)
        @MainActor @preconcurrency public var startIndex: Int { get }

        /// TThe collection’s “past the end” position—that is, the position one greater than the
        /// last valid subscript argument. (See `Collection.endIndex`.)
        @MainActor @preconcurrency public var endIndex: Int { get }

        /// Returns the position immediately after the given index. (See `Collection.index`.)
        @MainActor @preconcurrency public func index(after i: Int) -> Int

        /// Accesses the element at the specified position. (See `Collection.subscript`.)
        @MainActor @preconcurrency public subscript(index: Int) -> Entity

        /// Adds the specified entity as a child to this entity.
        ///
        /// - Parameters:
        ///   - child:                    The child entity to add to the collection.
        ///   - preservingWorldTransform: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 model should keep its effective location and size in the
        ///                                 scene!)
        @MainActor @preconcurrency public func append(_ child: Entity, preservingWorldTransform: Bool = false)

        /// Adds the specified list of entity as children to this entity.
        ///
        /// - Parameters:
        ///   - array:                    The child entities to add to the collection.
        ///   - preservingWorldTransforms: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 entities should keep its effective location and size in
        ///                                 the scene!)
        @MainActor @preconcurrency public func append(contentsOf array: [Entity], preservingWorldTransforms: Bool = false)

        /// Adds the specified list of entity as children to this entity.
        ///
        /// - Parameters:
        ///   - sequence:                 The child entities to add to the collection.
        ///   - preservingWorldTransforms: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 entities should keep its effective location and size in
        ///                                 the scene!)
        @MainActor @preconcurrency public func append<S>(contentsOf sequence: S, preservingWorldTransforms: Bool = false) where S : Sequence, S.Element : Entity

        /// Moves all `children` to be children of this entity.
        ///
        /// - Parameters:
        ///   - children:                 The child entities to add to the collection.
        ///   - preservingWorldTransforms: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 entities should keep its effective location and size in
        ///                                 the scene!)
        @MainActor @preconcurrency public func append(contentsOf children: Entity.ChildCollection, preservingWorldTransforms: Bool = false)

        /// Removes the specified child from this entity.
        ///
        /// - Note: This may modify the order of the `ChildCollection`.
        ///
        /// - Parameters:
        ///   - child:                    The child entity to remove from the collection.
        ///   - preservingWorldTransform: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 entities should keep its effective location and size in
        ///                                 the scene!)
        @MainActor @preconcurrency public func remove(_ child: Entity, preservingWorldTransform: Bool = false)

        /// Removes the specified child from this entity.
        ///
        /// - Note: This may modify the order of the `ChildCollection`.
        ///
        /// - Parameters:
        ///   - index:                    The index of the child entity to remove from the collection.
        ///   - preservingWorldTransform: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 entities should keep its effective location and size in
        ///                                 the scene!)
        @MainActor @preconcurrency public func remove(at index: Int, preservingWorldTransform: Bool = false)

        /// Removes all children from this entity.
        ///
        /// - Parameters:
        ///   - keepCapacity:             `true` to keep the memory reserved for storing the children.
        ///                                 `false` to free the reserved memory.
        ///   - preservingWorldTransforms: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 entities should keep its effective location and size in
        ///                                 the scene!)
        @MainActor @preconcurrency public func removeAll(keepCapacity: Bool = false, preservingWorldTransforms: Bool = false)

        @MainActor @preconcurrency public func removeAll(preservingWorldTransforms: Bool = false)

        /// Removes all children from this entity and adds the specified list of entities as the new
        /// children.
        ///
        /// - Parameters:
        ///   - children:                 The list of the new children.
        ///   - preservingWorldTransforms: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 entities should keep its effective location and size in
        ///                                 the scene!)
        @MainActor @preconcurrency public func replaceAll(_ children: [Entity], preservingWorldTransforms: Bool = false)

        /// Removes all children from this entity and adds the specified list of entities as the new
        /// children.
        ///
        /// - Parameters:
        ///   - children:                 The list of the new children.
        ///   - preservingWorldTransforms: `true` to preserve the world transform. `false` to
        ///                                 preserve the relative transform. (Use `true` if the
        ///                                 entities should keep its effective location and size in
        ///                                 the scene!)
        @MainActor @preconcurrency public func replaceAll<S>(_ children: S, preservingWorldTransforms: Bool = false) where S : Sequence, S.Element : Entity
    }
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// Prepares and plays a new audio playback instance on this entity.
    ///
    /// The method prepares the audio by calling
    /// ``Entity/prepareAudio(_:)``, and then immediately calls the
    /// ``AudioPlaybackController/play()`` method of the controller that it returns.
    /// To begin multiple playback instances you can call `playAudio` multiple times.
    ///
    /// - Parameters:
    ///   - resource: The audio resource the method plays.
    ///     Load an audio resource from the file system with
    ///     ``AudioFileResource/init(named:in:configuration:)`` ,
    ///     or from a URL with
    ///     ``AudioFileResource/init(contentsOf:withName:configuration:)``.
    ///
    /// - Returns: An ``AudioPlaybackController`` object that you can use to start and
    /// stop audio playback for this specific instance of a resource playing on this entity.
    /// You can also use this controller to update playback properties, such as gain and speed, during playback.
    @discardableResult
    @MainActor @preconcurrency public func playAudio(_ resource: AudioResource) -> AudioPlaybackController

    /// Prepares an audio resource for playback.
    ///
    /// To start playback right away with default `AudioPlaybackController` properties, use the
    /// ``Entity/playAudio(_:)`` method instead.
    ///
    /// - Note: As soon as the system prepares an audio resource, the audio engine begins tracking the
    ///   position of the entity and allocates rendering resources, which incurs a power cost.
    ///
    /// For optimal system resource usage, avoid preparing sounds before they are needed. For example:
    ///
    /// ```swift
    /// let controller = entity.prepareAudio(anAudioResource)
    /// controller.gain = -10 // Apply a custom gain, if desired.
    /// controller.speed = 1.2 // Apply a custom speed, if desired.
    /// controller.play()
    /// ```
    ///
    /// - Parameters:
    ///   - resource: The audio resource the method plays.
    ///     Load an audio resource from the file system with
    ///     ``AudioFileResource/init(named:in:configuration:)`` ,
    ///     or from a URL with
    ///     ``AudioFileResource/init(contentsOf:withName:configuration:)``.
    ///
    /// - Returns: An ``AudioPlaybackController`` object that you can use to start and
    /// stop audio playback for this specific instance of a resource playing on this entity.
    /// You can also use this controller to update playback properties, such as gain and speed, during playback.
    @MainActor @preconcurrency public func prepareAudio(_ resource: AudioResource) -> AudioPlaybackController

    /// Stops playback for all audio on this entity. 
    ///
    /// You can stop a specific ``AudioPlaybackController`` instance from
    /// playing a particular resource by calling the controller’s
    /// ``AudioPlaybackController/stop()`` method. 
    @MainActor @preconcurrency public func stopAllAudio()
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// Creates the shape used to detect collisions between two entities that
    /// have collision components.
    ///
    /// Call this method on entities that adopt the ``HasModel`` and
    /// ``HasCollision`` protocols to prepare a shape used for collision
    /// detection. The method stores the shape in the entity’s
    /// ``CollisionComponent`` instance.
    ///
    /// For non-model entities, the method has no effect. Nevertheless, the
    /// method is defined for all entities so that you can call it on any
    /// entity, and have the calculation propagate recursively to all that
    /// entity’s descendants.
    ///
    /// - Parameters:
    ///   - recursive: A Boolean that you set to `true` to also generate the
    ///   collision shapes for all descendants of the entity.
    @MainActor @preconcurrency public func generateCollisionShapes(recursive: Bool)
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity {

    /// Creates the shape used to detect collisions between two entities that
    /// have collision components.
    ///
    /// Call this method on entities that adopt the ``HasModel`` and
    /// ``HasCollision`` protocols to prepare a shape used for collision
    /// detection. The method stores the shape in the entity’s
    /// ``CollisionComponent`` instance.
    ///
    /// For non-model entities, the method has no effect. Nevertheless, the
    /// method is defined for all entities so that you can call it on any
    /// entity, and have the calculation propagate recursively to all that
    /// entity’s descendants.
    ///
    /// - Parameters:
    ///   - recursive: A Boolean that you set to `true` to also generate the
    ///   collision shapes for all descendants of the entity.
    ///   - isStatic: A Boolean value that indicates whether the colliders move. Set this to `true` to indicate the colliders don't move.
    ///    Non-moving, static colliders are more efficient to use than non-static ones.
    @MainActor @preconcurrency public func generateCollisionShapes(recursive: Bool, static isStatic: Bool)
}

@available(macOS 12.0, iOS 15.0, *)
extension Entity {

    /// Moves the character along a specified vector over a period of time.
    ///
    /// Moves the character in the collision world, with continuous collision checking and response.
    /// This will create character collision events.
    /// Entity.transform will be updated on the next engine tick.
    /// Use `CharacterControllerStateComponent` to get additional information about the state of the character after the move.
    ///
    /// - Parameters:
    ///    - moveDelta:        Delta vector to attempt to move capsule in collision world.
    ///    - deltaTime:        Time between last frame and current.
    ///    - referenceEntity:  Reference entity that defines the frame of reference of the move delta.
    ///                        Can be `nil`, which is equivalent to "world space".
    ///    - collisionHandler: Optional callback when an entity was hit. One call per each hit entity.
    /// - Returns:             Collision flags that indicate the location of the collision.
    @discardableResult
    @MainActor @preconcurrency public func moveCharacter(by moveDelta: SIMD3<Float>, deltaTime: Float, relativeTo referenceEntity: Entity?, collisionHandler: ((CharacterControllerComponent.Collision) -> Void)? = nil) -> CharacterControllerComponent.CollisionFlags

    /// Moves the character instantly to a new position.
    ///
    /// This method moves the character to a location specified relative to another entity. Pass `nil` in
    /// `relativeTo` to specify a position in world coordinates. A teleport move happens instantly.
    /// RealityKit does no collision checking when it moves the entity.
    ///
    /// - Parameters:
    ///   - position: The position to move the character to, relative to `referenceEntity`.
    ///   - referenceEntity: The entity that defines a frame of reference.
    ///     Set this to `nil` to indicate world space.
    @MainActor @preconcurrency public func teleportCharacter(to position: SIMD3<Float>, relativeTo referenceEntity: Entity?)

    /// The character controller component for the entity.
    @MainActor @preconcurrency public var characterController: CharacterControllerComponent?

    /// The character controller state for  the entity.
    @MainActor @preconcurrency public var characterControllerState: CharacterControllerStateComponent?
}

/// An extension that facilitates entity transform conversion with specified coordinate space references.
extension Entity {

    /// Defines the coordinate space reference for transform conversion.
    ///
    /// Entity uses this option as a reference coordinate space during transform conversion.
    ///
    /// Depending on the coordinate space that a caller entity is parented under, and whether there is an immersive space open, some transform conversion case can be inapplicable. Check out each case for more information.
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(tvOS, unavailable)
    public enum CoordinateSpaceReference {

        /// A reference to an entity's parent window scene.
        ///
        /// You can use this enum case to get an entity's relative transform in its parented window scene:
        ///
        /// ```swift
        /// let transformInWindowSpace = windowEntity.transformMatrix(relativeTo: .scene)
        /// ```
        /// - Note: If an entity is parented under an **immersive space**, calling ``Entity/transformMatrix(relativeTo:)-70l1k`` with the case `scene` returns `nil`.
        case scene

        /// A reference to an opened immersive space.
        ///
        /// You can use this enum case to get an entity's relative transform to the immersive space:
        /// ```swift
        /// let transformInImmersiveSpace = entity.transformMatrix(relativeTo: .immersiveSpace)
        /// ```
        /// - Note: If no immersive space is open, calling ``Entity/transformMatrix(relativeTo:)-70l1k`` with the case `immersiveSpace` returns `nil`.
        case immersiveSpace

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Entity.CoordinateSpaceReference, b: Entity.CoordinateSpaceReference) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Returns the 4 x 4 transform matrix of an entity relative to the given
    /// coordinate space.
    ///
    /// - Parameters:
    ///   - referenceSpace: The coordinate space that defines a frame of reference.
    ///
    /// - Returns: The transform of the entity relative to `referenceSpace`, or `nil` when the given coordinate space is not applicable to the given entity.
    ///
    /// This method overloads  ``HasTransform/transformMatrix(relativeTo:)``.
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(tvOS, unavailable)
    @MainActor @preconcurrency public func transformMatrix(relativeTo referenceSpace: Entity.CoordinateSpaceReference) -> float4x4?
}

/// Parses configurations available in a USD or reality file.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension Entity {

    /// A collection of alternative representations of an entity you can choose from.
    ///
    /// A configuration catalog allows you to create an entity from alternative configurations, such as
    /// different mesh geometries, levels of detail, or material properties.
    /// From these options, you can select the configurations according to how you want that entity to appear.
    ///
    /// You can load a configuration catalog from a USD file with variant sets or a `.reality` file with a
    /// configuration catalog.
    ///
    /// ### Create a configuration catalog
    ///
    /// To create a configuration catalog with RealityKit, first set up a configuration set for each category you
    /// want to represent.
    /// A configuration set consists of a name and an array of alternative representations for that category.
    /// For example, a configuration set can include different levels of detail or different material representations
    /// of an entity.
    ///
    /// The following example creates a configuration set for the categories `size` and `color`:
    ///
    /// ```swift
    /// let configurationSets: [Entity.ConfigurationCatalog.ConfigurationSet] = [
    ///     try Entity.ConfigurationCatalog.ConfigurationSet(
    ///         id: "size",
    ///         configurations: [
    ///             Entity.ConfigurationCatalog.Configuration(id: "small"),
    ///             Entity.ConfigurationCatalog.Configuration(id: "big")
    ///         ],
    ///         defaultConfigurationId: "small"
    ///     ),
    ///     try Entity.ConfigurationCatalog.ConfigurationSet(
    ///         id: "color",
    ///         configurations: [
    ///             Entity.ConfigurationCatalog.Configuration(id: "red"),
    ///             Entity.ConfigurationCatalog.Configuration(id: "green"),
    ///         defaultConfigurationId: "green"
    ///     ),
    /// ]
    /// ```
    ///
    /// Use a configuration combination to associate entities that represent specific configuration choices
    /// with a dictionary that describes those selections, as the following example shows:
    ///
    /// ```swift
    /// let combinations: [Entity.ConfigurationCatalog.ConfigurationCombination] = [
    ///     Entity.ConfigurationCatalog.ConfigurationCombination(
    ///         entity: smallRedEntity,
    ///         configurationSpecifications: ["size" : "small", "color" : "red"]
    ///     ),
    ///     Entity.ConfigurationCatalog.ConfigurationCombination(
    ///         entity: smallGreenEntity,
    ///         configurationSpecifications: ["size" : "small", "color" : "green"]
    ///     ),
    ///     Entity.ConfigurationCatalog.ConfigurationCombination(
    ///         entity: bigRedEntity,
    ///         configurationSpecifications: ["size" : "big", "color" : "red"]
    ///     ),
    ///     Entity.ConfigurationCatalog.ConfigurationCombination(
    ///         entity: bigGreenEntity,
    ///         configurationSpecifications: ["size" : "big", "color" : "green"]
    ///     ),
    /// ]
    /// ```
    ///
    /// Create a catalog from the configuration sets and combinations.
    ///
    /// ```swift
    /// let configurableEntity = try Entity.ConfigurationCatalog(
    ///    configurationSets: configurationSets,
    ///    combinations: combinations
    /// )
    /// ```
    ///
    /// Save the catalog to a `.reality` file that your RealityKit app can load.
    ///
    /// ```swift
    /// try await configurableEntity.write(to: url)
    /// ```
    ///
    /// ### Load an entity with a configuration
    ///
    /// The following code example loads a small, red entity from the configuration catalog in the preceding
    /// example.
    /// The entity initializer looks for the catalog to have configuration sets named `size` and `color`,
    /// and the sets to contain configurations named `small` and `red`, respectively.
    ///
    /// ```swift
    /// func loadSmallRedEntity(from url: URL) async throws -> Entity {
    ///     let catalog = try await Entity.ConfigurationCatalog(from: url)
    ///     return try await Entity(
    ///         from: catalog,
    ///         configurations: ["size": "small", "color": "red"]
    ///     )
    /// }
    /// ```
    public struct ConfigurationCatalog {

        /// A type that represents an alternative that you can choose.
        public struct Configuration : Identifiable, Sendable {

            /// A name that identifies the configuration.
            public var id: String { get }

            /// Creates a configuration with an identifier.
            public init(id: String)

            /// A type representing the stable identity of the entity associated with
            /// an instance.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias ID = String
        }

        /// A collection of alternatives to choose from.
        ///
        /// For example, a configuration set might contain configurations named `small`, `medium`,
        /// and `big` to represent a choice of sizes.
        public struct ConfigurationSet : Identifiable, Sendable {

            /// A name that identifies the configuration set.
            public var id: String { get }

            /// The alternative configurations that are available in a set.
            ///
            /// The keys are configuration IDs, and the values are the corresponding configurations.
            public var configurations: [String : Entity.ConfigurationCatalog.Configuration] { get }

            /// The default configuration, if you don't explicitly set one.
            public var defaultConfiguration: Entity.ConfigurationCatalog.Configuration { get }

            /// Creates a configuration set from an ID, a dictionary of configurations, and a default
            /// configuration ID.
            ///
            /// - Parameters:
            ///   - id: The ID of the configuration set that's unique across all other configuration sets.
            ///   - configurations: A dictionary of configurations you can choose from.
            ///     Each key needs to match the ID of the configuration value it maps to.
            ///   - defaultConfigurationId: The ID of one of the configuration elements in the
            ///     `configurations` parameter, which is the default configuration the entity initializer
            ///     applies if you don't choose a configuration from the set.
            ///
            /// - Returns: A configuration set containing the configurations.
            public init(id: String, configurations: [String : Entity.ConfigurationCatalog.Configuration], defaultConfigurationId: String? = nil) throws

            /// Creates a configuration set from an ID, an array of configurations, and a default
            /// configuration ID.
            ///
            /// - Parameters:
            ///   - id: The ID of the configuration set that's unique across all other configuration sets.
            ///   - configurations: An array of configurations you can choose from.
            ///     The configuration set stores the array in the ``configurations``
            ///     property and doesn't preserve the order of the array.
            ///   - defaultConfigurationId: The ID of one of the configuration elements in the
            ///     `configurations` parameter, which is the default configuration the entity initializer
            ///     applies if you don't choose a configuration from the set.
            ///
            /// - Returns: A configuration set containing the configurations.
            public init(id: String, configurations: [Entity.ConfigurationCatalog.Configuration], defaultConfigurationId: String? = nil) throws

            /// A type representing the stable identity of the entity associated with
            /// an instance.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias ID = String
        }

        /// A type that associates an entity with a combination of configurations.
        public struct ConfigurationCombination {

            /// Creates a configuration combination from an entity and a configuration dictionary.
            ///
            /// - Parameters:
            ///     - entity: An entity that represents the configuration choices in `configurationSpecifications`.
            ///     - configurationSpecifications: A dictionary that associates a configuration set name with a choice from that set.
            public init(entity: Entity, configurationSpecifications: [String : String])

            /// The entity that represents the configuration choices.
            public let entity: Entity

            /// A dictionary that associates IDs of configuration sets to IDs of configurations.
            ///
            /// Use this property to represent a configuration choice from each configuration set.
            public let configurationSpecifications: [String : String]
        }

        /// Creates a configuration catalog from in-memory entities and a dictionary of configuration sets.
        ///
        /// - Parameters:
        ///     - configurationSets: The configuration choices that the configuration catalog presents.
        ///     Each key needs to match the ID of the configuration set value it maps to.
        ///     - combinations: The combinations of in-memory entities and configurations that can
        ///     address them. The keys you use in
        ///     ``ConfigurationCombination/configurationSpecifications`` need to match
        ///     IDs of configuration sets from the `configurationSets` argument. 
        ///     The values you use in
        ///     ``ConfigurationCombination/configurationSpecifications`` need to match
        ///     IDs of configurations from the `configurationSets` argument.
        ///     There needs to be one ``ConfigurationCombination`` for each possible combination
        ///     of configurations.
        ///
        /// - Returns: A configuration catalog that maintains the provided entities in memory.
        public init(configurationSets: [String : Entity.ConfigurationCatalog.ConfigurationSet], combinations: [Entity.ConfigurationCatalog.ConfigurationCombination]) throws

        /// Creates a configuration catalog from in-memory entities and an array of configuration sets.
        ///
        /// - Parameters:
        ///     - configurationSets: The configuration choices that the configuration catalog presents.
        ///     Each configuration set needs to have a unique ID from all others.
        ///     The configuration catalog stores the array as the `configurationSets` dictionary
        ///     property and doesn't preserve its order.
        ///     - combinations: The combinations of in-memory entities and the configurations that can
        ///     address them. 
        ///     The keys you use in
        ///     ``ConfigurationCombination/configurationSpecifications`` need to match
        ///     IDs of configuration sets from the `configurationSets` argument. 
        ///     The values you use in
        ///     ``ConfigurationCombination/configurationSpecifications`` need to match
        ///     IDs of configurations from the `configurationSets` argument.
        ///     There needs to be one ``ConfigurationCombination`` for each possible combination
        ///     of configurations.
        ///
        /// - Returns: A configuration catalog that maintains the provided entities in memory.
        public init(configurationSets: [Entity.ConfigurationCatalog.ConfigurationSet], combinations: [Entity.ConfigurationCatalog.ConfigurationCombination]) throws

        /// Writes the configurations of the configuration catalog to a reality file.
        ///
        /// Another configuration catalog instance can open the `.reality` file for reading.
        ///
        /// - Parameters:
        ///     - url: The destination where the configuration catalog writes the `.reality` file.
        @MainActor public func write(to url: URL) async throws

        /// The configuration sets that configure the default prim or entity.
        ///
        /// The keys are configuration set IDs, and the values are the corresponding configuration sets.
        public var configurationSets: [String : Entity.ConfigurationCatalog.ConfigurationSet] { get }
    }

    /// Loads an entity from a configuration catalog and a dictionary of configuration choices.
    ///
    /// - Parameters:
    ///     - catalog: A collection of alternative representations for an entity.
    ///     - configurations: A dictionary of configuration choices the initializer applies as it loads the entity,
    ///     mapping the ID of a configuration set to the ID of a configuration within that set.
    @MainActor @preconcurrency public convenience init(from catalog: Entity.ConfigurationCatalog, configurations: [String : String]? = nil) async throws
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity {

    /// The component that configures the channel-based rendering of sounds from this entity.
    @MainActor @preconcurrency public var channelAudio: ChannelAudioComponent?
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// The nearest ancestor entity that can act as an anchor.
    ///
    /// This property returns `nil` if no ancestor can act as an anchor. An
    /// entity can act as an anchor if it adopts the ``HasAnchoring`` protocol.
    /// Just because an ancestor can be anchored doesn’t mean that it is.
    /// Inspect the ``Entity/isAnchored`` property to see if an entity (or one
    /// of its ancestors) is anchored.
    @MainActor @preconcurrency public var anchor: (any HasAnchoring)? { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity : Hashable {

    /// Hashes the essential components of the entity by feeding them into the
    /// given hash function.
    ///
    /// - Parameters:
    ///   - hasher: The hash function to use when combining the components of the
    ///     entity.
    nonisolated public func hash(into hasher: inout Hasher)

    /// Indicates whether two entities are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first entity to compare.
    ///
    ///   - rhs: The second entity to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two entities are equal.
    nonisolated public static func == (lhs: Entity, rhs: Entity) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    nonisolated open var hashValue: Int { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity : Identifiable {

    /// The stable identity of the entity associated with this instance.
    nonisolated public var id: UInt64 { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    @available(iOS 13.0, macOS 10.15, *)
    public typealias ID = UInt64
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// Duplicates an entity to create a new entity.
    ///
    /// All component data is cloned automatically. If you clone an entity that
    /// stores custom data that’s not part of a component, override the
    /// ``Entity/didClone(from:)`` method to copy that data manually.
    ///
    /// - Parameters:
    ///   - recursive: A Boolean that you set to `true` to recursively copy all
    ///     the children of the entity. Otherwise, no descendants are copied.
    ///
    /// - Returns: The duplicate.
    @MainActor @preconcurrency public func clone(recursive: Bool) -> Self
}

/// Entity is a class that can be used as an object
/// on which events can be published and subscribed to.
@available(macOS 10.15, iOS 13.0, *)
extension Entity : EventSource {
}

extension Entity {

    /// Defines the forward direction for an entity.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public enum ForwardDirection {

        case negativeZ

        case positiveZ

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Entity.ForwardDirection, b: Entity.ForwardDirection) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 11.0, iOS 14.0, *)
extension Entity {

    /// A Boolean value indicating whether the receiver is an accessibility
    /// element that an assistive application can access.
    @MainActor @preconcurrency public var isAccessibilityElement: Bool

    /// A succinct label that identifies the purpose of the image.
    ///
    /// The default value for this property is `false`.
    ///
    /// For entities with ``Entity/isAccessibilityElement`` set to
    /// <doc://com.apple.documentation/documentation/swift/true>, iOS uses this
    /// string to provide information to users of assistive technologies like
    /// VoiceOver. Set this property to a name or short description that
    /// accurately describes the entity. If you wish to provide additional
    /// information or a longer description of the entity, you can use
    /// ``Entity/accessibilityDescription``.
    @available(*, deprecated, message: "Use accessibilityLabelKey instead")
    @MainActor @preconcurrency public var accessibilityLabel: String?

    /// A longer description of the entity for use by assistive technologies.
    @available(*, deprecated, message: "Use accessibilityCustomContent instead")
    @MainActor @preconcurrency public var accessibilityDescription: String?
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// Returns an entity by synchronously loading it from a bundle.
    ///
    /// Loading an ``Entity`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// RealityKit supports loading entities from USD (`.usd`, `.usda`, `.usdc`,
    /// `.usdz`) and Reality files (`.reality`).
    ///
    /// When building your app, Xcode automatically converts any Reality
    /// Composer projects (`.rcproject`) in the selected target into Reality
    /// files, which it then copies into your app’s bundle.
    ///
    /// For more information on loading entities, see
    /// <doc:loading-entities-from-a-file>.
    ///
    /// - Parameters:
    ///   - name: The base name of the file to load.  An extension is not required,
    ///     but can be provided to resolve collisions.  In the presence of a collision,
    ///     the provided name will be resolved with the following order of precedence
    ///     [usdz, usd, usdc, usda].
    ///
    ///   - bundle: The bundle containing the file. Use `nil` to search the app’s
    ///     main bundle.
    ///
    /// - Returns: The root entity in the loaded file.
    @available(*, noasync, message: "Synchronous Entity loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func load(named name: String, in bundle: Bundle? = nil) throws -> Entity

    /// Returns a load request that creates an entity by asynchronously loading it from a bundle.
    ///
    /// RealityKit supports loading entities from USD (`.usd`, `.usda`, `.usdc`,
    /// `.usdz`) and Reality files (`.reality`).
    ///
    /// When building your app, Xcode automatically converts any Reality
    /// Composer projects (`.rcproject`) in the selected target into Reality
    /// files, which it then copies into your app’s bundle.
    ///
    /// For more information on loading entities, see
    /// <doc:loading-entities-from-a-file>.
    ///
    /// - Parameters:
    ///   - name: The base name of the file to load, omitting the file extension.
    ///
    ///   - bundle: The bundle containing the file. Use `nil` to search the app’s
    ///     main bundle.
    ///
    /// - Returns: A resource loader that publishes the root entity in the
    ///     loaded file.
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "init(named:in:)")
    @available(iOS, introduced: 13.0, deprecated: 18.0, renamed: "init(named:in:)")
    @available(macCatalyst, introduced: 13.0, deprecated: 18.0, renamed: "init(named:in:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "init(named:in:)")
    @MainActor @preconcurrency public static func loadAsync(named name: String, in bundle: Bundle? = nil) -> LoadRequest<Entity>

    /// Returns an entity by synchronously loading it from a file URL.
    ///
    /// Loading an ``Entity`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// RealityKit supports loading entities from USD (`.usd`, `.usda`, `.usdc`,
    /// `.usdz`) and Reality files (`.reality`).
    ///
    /// When building your app, Xcode automatically converts any Reality
    /// Composer projects (`.rcproject`) in the selected target into Reality
    /// files, which it then copies into your app’s bundle.
    ///
    /// For more information on loading entities, see
    /// <doc:loading-entities-from-a-file>.
    ///
    /// - Parameters:
    ///   - url: A file URL representing the file to load.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    /// - Returns: The root entity in the loaded file.
    @available(*, noasync, message: "Synchronous Entity loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func load(contentsOf url: URL, withName resourceName: String? = nil) throws -> Entity

    /// Returns a load request that creates an entity by asynchronously loading
    /// it from a file URL and preserving the entity's hierarchy.
    ///
    /// RealityKit supports loading entities from USD (`.usd`, `.usda`, `.usdc`,
    /// `.usdz`) and Reality files (`.reality`).
    ///
    /// When building your app, Xcode automatically converts any Reality
    /// Composer projects (`.rcproject`) in the selected target into Reality
    /// files, which it then copies into your app’s bundle.
    ///
    /// For more information on loading entities, see
    /// <doc:loading-entities-from-a-file>.
    ///
    /// - Parameters:
    ///   - url: The location of a file that represents an entity.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "init(contentsOf:withName:)")
    @available(iOS, introduced: 13.0, deprecated: 18.0, renamed: "init(contentsOf:withName:)")
    @available(macCatalyst, introduced: 13.0, deprecated: 18.0, renamed: "init(contentsOf:withName:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "init(contentsOf:withName:)")
    @MainActor @preconcurrency public static func loadAsync(contentsOf url: URL, withName resourceName: String? = nil) -> LoadRequest<Entity>

    /// Synchronously loads an anchor entity from a bundle.
    ///
    /// Loading an ``Entity`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// - Parameters:
    ///   - name: The base name of the file to load, omitting the file extension.
    ///
    ///   - bundle: The bundle containing the file. Use `nil` to search the app’s
    ///     main bundle.
    ///
    /// - Returns: The root entity in the loaded file, cast as an ``AnchorEntity``.
    @available(*, noasync, message: "Synchronous Entity loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func loadAnchor(named name: String, in bundle: Bundle? = nil) throws -> AnchorEntity

    /// Asynchronously loads an anchor entity from a bundle.
    ///
    /// - Parameters:
    ///   - name: The base name of the file to load, omitting the file extension.
    ///
    ///   - bundle: The bundle containing the file. Use `nil` to search the app’s
    ///     main bundle.
    ///
    /// - Returns: A resource loader that publishes the root entity in the
    ///   loaded file as an ``AnchorEntity``.
    ///
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "AnchorEntity.init(named:in:)")
    @available(iOS, introduced: 13.0, deprecated: 18.0, renamed: "AnchorEntity.init(named:in:)")
    @available(macCatalyst, introduced: 13.0, deprecated: 18.0, renamed: "AnchorEntity.init(named:in:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "AnchorEntity.init(named:in:)")
    @MainActor @preconcurrency public static func loadAnchorAsync(named name: String, in bundle: Bundle? = nil) -> LoadRequest<AnchorEntity>

    /// Synchronously loads an anchor entity from a file URL.
    ///
    /// Loading an ``Entity`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// - Parameters:
    ///   - url: A file URL representing the file to load.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    /// - Returns: The root entity in the loaded file, cast as an ``AnchorEntity``.
    @available(*, noasync, message: "Synchronous Entity loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func loadAnchor(contentsOf url: URL, withName resourceName: String? = nil) throws -> AnchorEntity

    /// Asynchronously loads an anchor entity from a file URL.
    ///
    /// - Parameters:
    ///   - url: A file URL representing the file to load.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    /// - Returns: A resource loader that publishes the root entity in the
    /// loaded file as an ``AnchorEntity``.
    ///
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "AnchorEntity.init(contentsOf:withName:)")
    @available(iOS, introduced: 13.0, deprecated: 18.0, renamed: "AnchorEntity.init(contentsOf:withName:)")
    @available(macCatalyst, introduced: 13.0, deprecated: 18.0, renamed: "AnchorEntity.init(contentsOf:withName:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "AnchorEntity.init(contentsOf:withName:)")
    @MainActor @preconcurrency public static func loadAnchorAsync(contentsOf url: URL, withName resourceName: String? = nil) -> LoadRequest<AnchorEntity>

    /// Synchronously loads a model entity from a bundle.
    ///
    /// Loading an ``Entity`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// - Parameters:
    ///   - name: The base name of the file to load, omitting the file extension.
    ///
    ///   - bundle: The bundle containing the file. Use `nil` to search the app’s
    ///     main bundle.
    ///
    /// - Returns: The root entity in the loaded file, cast as a ``ModelEntity``.
    @available(*, noasync, message: "Synchronous Entity loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func loadModel(named name: String, in bundle: Bundle? = nil) throws -> ModelEntity

    /// Asynchronously loads a model entity from a bundle.
    ///
    /// - Parameters:
    ///   - name: The base name of the file to load, omitting the file extension.
    ///
    ///   - bundle: The bundle containing the file. Use `nil` to search the app’s
    ///     main bundle.
    ///
    /// - Returns: A resource loader that publishes the root entity in the
    ///   loaded file as a ``ModelEntity``.
    ///
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "ModelEntity.init(named:in:)")
    @available(iOS, introduced: 13.0, deprecated: 18.0, renamed: "ModelEntity.init(named:in:)")
    @available(macCatalyst, introduced: 13.0, deprecated: 18.0, renamed: "ModelEntity.init(named:in:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "ModelEntity.init(named:in:)")
    @MainActor @preconcurrency public static func loadModelAsync(named name: String, in bundle: Bundle? = nil) -> LoadRequest<ModelEntity>

    /// Synchronously loads a model entity from a file URL.
    ///
    /// Loading an ``Entity`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// - Parameters:
    ///   - url: A file URL representing the file to load.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    /// - Returns: The root entity in the loaded file, cast as a ``ModelEntity``.
    @available(*, noasync, message: "Synchronous Entity loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func loadModel(contentsOf url: URL, withName resourceName: String? = nil) throws -> ModelEntity

    /// Returns a load request that creates a model entity by asynchronously loading
    /// it from a file URL and flattening the model entity's hierarchy.
    ///
    /// For more information on loading entities, see
    /// <doc:loading-entities-from-a-file>.
    ///
    /// - Parameters:
    ///   - url: The location of a file that represents an entity.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "ModelEntity.init(contentsOf:withName:)")
    @available(iOS, introduced: 13.0, deprecated: 18.0, renamed: "ModelEntity.init(contentsOf:withName:)")
    @available(macCatalyst, introduced: 13.0, deprecated: 18.0, renamed: "ModelEntity.init(contentsOf:withName:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "ModelEntity.init(contentsOf:withName:)")
    @MainActor @preconcurrency public static func loadModelAsync(contentsOf url: URL, withName resourceName: String? = nil) -> LoadRequest<ModelEntity>
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity {

    /// Creates a new entity by asynchronously loading it from a bundle.
    ///
    /// RealityKit supports loading entities from USD (`.usd`, `.usda`, `.usdc`,
    /// `.usdz`) and Reality files (`.reality`).
    ///
    /// For more information on loading entities, see
    /// <doc:loading-entities-from-a-file>.
    ///
    /// You can use a task group to await all loads before adding them to the scene to
    /// display content from multiple scenes without hitches or pop in.
    ///
    /// ```swift
    /// struct SomeRealityView: View {
    ///     var body: some View {
    ///         RealityView { content in
    ///             // Add the initial RealityKit content.
    ///             let entities : [Entity] = await withTaskGroup(of: Entity?.self) { taskGroup in
    ///                 // Load all the scenes concurrently.
    ///                 taskGroup.addTask { return try? await Entity(named: "SceneA", in: realityKitContentBundle) }
    ///                 taskGroup.addTask { return try? await Entity(named: "SceneB", in: realityKitContentBundle) }
    ///                 taskGroup.addTask { return try? await Entity(named: "SceneC", in: realityKitContentBundle) }
    ///
    ///                 var entities = [Entity]()
    ///                 // Wait for all the scenes to load.
    ///                 for await entity in taskGroup {
    ///                     if let entity {
    ///                         entities.append(entity)
    ///                     }
    ///                 }
    ///                 return entities
    ///             }
    ///             // Add all the content.
    ///             for entity in entities {
    ///                 content.add(entity)
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - name: The base name of the file to load, omitting the file extension, or scene name if loading from a .reality file. 
    ///     - bundle: The bundle containing the file. Use `nil` to search the app's main bundle.
    ///
    /// - Returns: The root entity in the loaded file.
    @MainActor @preconcurrency public convenience init(named name: String, in bundle: Bundle? = nil) async throws

    /// Creates a new entity by asynchronously loading it from a file URL.
    ///
    /// RealityKit supports loading entities from USD (`.usd`, `.usda`, `.usdc`,
    /// `.usdz`) and Reality files (`.reality`).
    ///
    /// For more information on loading entities, see
    /// <doc:loading-entities-from-a-file>.
    ///
    /// See ``init(named:in:)`` for an example of optimally loading content.
    ///
    /// - Parameters:
    ///     - url: A file URL representing the file to load.
    ///     - resourceName: A unique name the method assigns to the resource it loads,
    ///       for use in network synchronization.
    ///
    /// - Returns: The root entity of the loaded file.
    @MainActor @preconcurrency public convenience init(contentsOf url: URL, withName resourceName: String? = nil) async throws
}

extension Entity {

    /// Apply a tap to an Entity or one of its ancestors to trigger a RealityComposer behavior if one is present.
    ///
    /// This method looks for a RealityComposer tap trigger, starting with `self` and moving up the Entity hierarchy.
    /// As soon as an entity with a tap trigger is found, the trigger is fired, and the method returns `true`.  If no
    /// tap trigger is found, the method returns `false`.
    ///
    /// - Returns: `true` if a tap trigger was fired, otherwise returns `false`.
    ///
    /// ```swift
    /// struct ContentView: View {
    ///   var body: some View {
    ///     RealityView() { content in
    ///       if let entity = try? await Entity(named: "Content") {
    ///         content.add(entity)
    ///       }
    ///     }.gesture(TapGesture().targetedToAnyEntity().onEnded { value in
    ///       if value.entity.applyTapForBehaviors() {
    ///         // Behavior was activated
    ///       } else {
    ///         // Behavior was not activated
    ///       }
    ///     })
    ///   }
    /// }
    /// ```
    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    @MainActor @preconcurrency public func applyTapForBehaviors() -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity {

    /// The component that configures the ambient rendering of sounds from this entity.
    @MainActor @preconcurrency public var ambientAudio: AmbientAudioComponent?
}

@available(visionOS 1.0, macOS 10.15, iOS 13.0, *)
extension Entity {

    /// Creates an entity with one or multiple components.
    /// - Parameter components: A comma-delimited list of components to add to the entity.
    ///
    /// The components you specify in this initializer override any default
    /// components of the same type that RealityKit creates the entity with,
    /// such as ``Transform``.
    ///
    /// For example, you can use this initializer to create an entity that has a ``SpotLightComponent``:
    ///
    /// ```swift
    /// let spotlightEntity = Entity(components: SpotLightComponent())
    /// ```
    ///
    /// You can also create an entity with multiple initial components,
    /// such as a ``ModelComponent`` and a ``Transform``:
    ///
    /// ```swift
    /// let sphereEntity = Entity(
    ///     components: ModelComponent(mesh: .generateBox(size: 1), materials: []),
    ///                 Transform(translation: [0, 0.5, 0])
    /// )
    /// ```
    ///
    /// - Note: You can change any of the entity's components at any time by modifying
    ///   the entity's ``Entity/components`` set.
    @MainActor @preconcurrency public convenience init<each T>(components: repeat each T) where repeat each T : Component

    /// Creates an entity with multiple components.
    /// - Parameter components: The components to add to the entity.
    ///
    /// This initializer adds the contents of `components` to the new ``Entity``.
    /// The components you specify in this initializer override any default
    /// components of the same type that RealityKit creates the entity with,
    /// such as ``Transform``.
    ///
    /// For example, you can use this initializer to create an entity that
    /// anchors to the floor, displays a 1x1x1m box,
    /// and has a y-position of 0.5:
    ///
    /// ```swift
    /// let floorCubeComponents = [
    ///     AnchoringComponent(.plane(.horizontal, classification: .floor, minimumBounds: [1, 1])),
    ///     ModelComponent(mesh: .generateBox(size: 1), materials: []),
    ///     Transform(translation: [0, 0.5, 0])
    /// ]
    ///
    /// let floorCubeEntity = Entity(components: floorCubeComponents)
    /// ```
    ///
    /// - Note: You can change any of the entity's components at any time by modifying
    ///   the entity's ``Entity/components`` set.
    @MainActor @preconcurrency public convenience init(components: [any Component])
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension Entity {

    /// Exports the entity as a RealityKit file to a location in the file system.
    ///
    /// - Parameters:
    ///   - url: The location URL in the file system where you want to save the `.reality` file.
    ///
    /// This method generates a file with a `.reality` suffix that's compatible
    /// with the following systems:
    /// - iOS 18 and later
    /// - macOS 15 and later
    /// - visionOS 2 and later
    ///
    /// > Important:
    /// > During its initial setup phase, this method can indirectly block the main thread,
    /// > and also has the potential to block it for the full duration of the call if the system
    /// > has additional work it needs to do there.
    @MainActor public func write(to url: URL) async throws
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity {

    /// Plays all the animations with the given name on the entity.
    ///
    /// The method plays all the animations in the
    /// ``Entity/availableAnimations`` property with a matching name. If there
    /// are none, the method returns a controller showing a stopped animation.
    ///
    /// - Parameters:
    ///   - animationName: The name of the animation.
    ///
    ///   - transitionDuration: The duration in seconds over which the animation
    ///     fades in or cross-fades.
    ///
    ///   - startsPaused: A Boolean that you set to `true` to return from the call
    ///     with the animations paused. Set to `false` to start the animations right
    ///     away.
    ///
    ///   - recursive: Indicates whether to also play animations on all
    ///     descendants of the entity.
    ///
    /// - Returns: An animation playback controller that you can use to start
    /// and stop the animations.
    @available(*, deprecated, message: "Use playAnimation functions that utilize an AnimationResource instead of a name.")
    @discardableResult
    @MainActor @preconcurrency public func playAnimation(named animationName: String, transitionDuration: TimeInterval = 0, startsPaused: Bool = false, recursive: Bool = true) -> AnimationPlaybackController

    /// Plays the given animation on the entity.
    ///
    /// - Parameters:
    ///   - animation: The animation to play.
    ///
    ///   - transitionDuration: The duration in seconds over which the animation
    ///     fades in or cross-fades.
    ///
    ///   - startsPaused: A Boolean that you set to `true` to return from the call
    ///     with the animation paused. Set to `false` to start the animation right away.
    ///
    /// - Returns: An animation playback controller that you can use to start
    /// and stop the animation.
    @discardableResult
    @MainActor @preconcurrency public func playAnimation(_ animation: AnimationResource, transitionDuration: TimeInterval, startsPaused: Bool) -> AnimationPlaybackController

    /// Stops all playing of animations on this entity.
    ///
    /// - Parameters:
    ///   - recursive: Indicates whether to also stop animations on all
    ///     descendants of the entity.
    @MainActor @preconcurrency public func stopAllAnimations(recursive: Bool = true)
}

@available(macOS 12.0, iOS 15.0, *)
extension Entity {

    /// Plays an animation with the specified options.
    ///
    /// Call this method to play an animation and configure playback options.
    /// RealityKit supports blending up to two different animations at the same
    /// time. When RealityKit applies multiple animations to an entity, the
    /// order in which it applies the animations affects the final animation.
    /// Use the `blendLayerOffset` parameter to specify the order of animations
    /// when playing multiple animations at the same time.
    ///
    /// - Parameters:
    ///   - animation: The animation to play.
    ///
    ///   - transitionDuration: The duration in seconds over which the animation
    ///     fades in or cross-fades.
    ///
    ///   - blendLayerOffset: An integer that specifies the order in which to
    ///     apply animations when more than one animation is playing. Valid values
    ///     are `0` or `1`.
    ///
    ///   - separateAnimatedValue: When set to false, this value indicates that the
    ///     animation will write directly to the entity's base value. When set to true,
    ///     this value indicates that the animation will write to an interim value for
    ///     the duration of the animation. If this value is set to true then when the
    ///     animation completes, the entity's value will be reset to the base value.
    ///
    ///   - startsPaused: A Boolean that pauses the progress of an animation when
    ///     set to `true`.
    ///
    ///   - clock: An optional clock to drive the animation with a custom
    ///     timescale.
    ///
    ///   - Returns: An animation playback controller that you can use to start
    ///     and stop the animation.
    @discardableResult
    @MainActor @preconcurrency public func playAnimation(_ animation: AnimationResource, transitionDuration: TimeInterval = 0, blendLayerOffset: Int = 0, separateAnimatedValue: Bool = false, startsPaused: Bool = false, clock: CMClockOrTimebase? = nil) -> AnimationPlaybackController

    /// Returns the default animation clock for this entity.
    @MainActor @preconcurrency public var defaultAnimationClock: CMClockOrTimebase
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity {

    /// Plays an animation with the specified options.
    ///
    /// Call this method to play an animation and configure playback options.
    /// RealityKit supports blending up to two different animations at the same
    /// time. When RealityKit applies multiple animations to an entity, the
    /// order in which it applies the animations affects the final animation.
    /// Use the `blendLayerOffset` parameter to specify the order of animations
    /// when playing multiple animations at the same time.
    ///
    /// - Parameters:
    ///   - animation: The animation to play.
    ///
    ///   - transitionDuration: The duration in seconds over which the animation
    ///     fades in or cross-fades.
    ///
    ///   - blendLayerOffset: An integer that specifies the order in which to
    ///     apply animations when more than one animation is playing.
    ///
    ///   - separateAnimatedValue: When set to false, this value indicates that the
    ///     animation will write directly to the entity's base value. When set to true,
    ///     this value indicates that the animation will write to an interim value for
    ///     the duration of the animation. If this value is set to true then when the
    ///     animation completes, the entity's value will be reset to the base value.
    ///
    ///   - startsPaused: A Boolean that pauses the progress of an animation when
    ///     set to `true`.
    ///
    ///   - clock: An optional clock to drive the animation with a custom timescale.
    ///
    ///   - handoffType: Type of handoff behavior between a currently-playing animation
    ///     and the new animation. Defaults to `.snapshotAndReplace(applyToAllLayers: true)`.
    ///
    ///   - Returns: An animation playback controller that you can use to start
    ///     and stop the animation.
    @discardableResult
    @MainActor @preconcurrency public func playAnimation(_ animation: AnimationResource, transitionDuration: TimeInterval = 0, blendLayerOffset: Int = 0, separateAnimatedValue: Bool = false, startsPaused: Bool = false, clock: CMClockOrTimebase? = nil, handoffType: AnimationHandoffType = .default) -> AnimationPlaybackController
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension Entity {

    /// The entity's geometric pins.
    ///
    /// You can look up, add, and remove a ``GeometricPin`` for the owning entity
    /// through this ``EntityGeometricPins`` instance.
    /// The entity's ``GeometricPinsComponent`` stores any added geometric pins.
    ///
    /// Other ``Component`` types on an ``Entity`` may also provide ``GeometricPin`` instances,
    /// such as for skeletal pose joints.
    /// There is no distinction between these two when ``GeometricPin`` instances are accessed.
    ///
    /// ### Geometric pins for skeletal pose joints
    ///
    /// Entities with skeletal poses expose skeletal pose joints as ``GeometricPin`` instances.
    /// These pins are not stored in the ``GeometricPinsComponent`` on the ``Entity``,
    /// but are obtained directly from the skeletal pose.
    ///
    /// The name of the ``GeometricPin`` is the name of the skeletal pose joint.
    /// The pose (position and orientation) of the ``GeometricPin`` is the current pose of the joint
    /// in the coordinate frame of the ``Entity`` (i.e. *not* relative to the parent joint).
    /// While the skeletal pose is animated, the ``GeometricPin`` pose change on every frame.
    ///
    /// The geometric pin's ``GeometricPin/name`` can be given as either the full skeletal pose joint path name,
    /// such as `"root/hips_joint/spine_1_joint/spine_2_joint"`, or as the leaf joint name, like `"spine_2_joint"`.
    ///
    /// For example, get a pin via a full pose joint name, or with its leaf joint name:
    ///
    /// ```swift
    /// let jointPinFromFullName = skeletalPoseEntity.pins["root/hips_joint/spine_1_joint/spine_2_joint"]
    /// let jointPinFromShortName = skeletalPoseEntity.pins["spine_2_joint"]
    /// ```
    ///
    /// To print all the pins, you can loop over ``Entity/pins``.
    ///
    /// ```swift
    /// for pin in skeletalPoseEntity.pins {
    ///     print("joint   name: \(pin.name)")        // Full joint path name.
    ///     print("    position: \(pin.position)")    // In coordinate frame of skeletalPoseEntity.
    ///     print(" orientation: \(pin.orientation)") // In coordinate frame of skeletalPoseEntity.
    /// }
    /// ```
    ///
    /// In skeletal pose joint names, prefix the characters
    /// `.`, `[`, `]` and `\`
    /// with an escaping character (`\`).
    ///
    /// For example, to access a skeletal pose joint named `"my.joint"`:
    ///
    /// ```swift
    /// // To include a literal backslash in a string,
    /// // escape it with an additional backslash.
    /// let myJointPinEscaped = skeletalPoseEntity.pins["my\\.joint"]
    /// // Alternatively, use Swift's raw string feature
    /// // by enclosing the string in # symbols.
    /// let myJointPinRaw = skeletalPoseEntity.pins[#"my\.joint"#]
    /// ```
    ///
    /// - Note: Character escaping is only required for skeletal pose joints.
    @MainActor @preconcurrency public var pins: EntityGeometricPins { get }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension Entity.ComponentSet : Sequence {

    /// Returns an iterator over the elements of this sequence.
    @MainActor @preconcurrency public func makeIterator() -> Entity.ComponentSet.Iterator

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> (any Component)?

        /// The type of element traversed by the iterator.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Element = (any Component)
    }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension Entity.ComponentSet : Collection {

    /// A type representing the sequence's elements.
    public typealias Element = (any Component)

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public struct Index : Comparable, Sendable {

        /// Returns a Boolean value indicating whether the value of the first
        /// argument is less than that of the second argument.
        ///
        /// This function is the only requirement of the `Comparable` protocol. The
        /// remainder of the relational operator functions are implemented by the
        /// standard library for any type that conforms to `Comparable`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func < (lhs: Entity.ComponentSet.Index, rhs: Entity.ComponentSet.Index) -> Bool

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Entity.ComponentSet.Index, b: Entity.ComponentSet.Index) -> Bool
    }

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @MainActor @preconcurrency public var startIndex: Entity.ComponentSet.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    @MainActor @preconcurrency public var endIndex: Entity.ComponentSet.Index { get }

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!"
    ///
    /// - Complexity: O(1)
    @MainActor @preconcurrency public var isEmpty: Bool { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    @MainActor @preconcurrency public func index(after index: Entity.ComponentSet.Index) -> Entity.ComponentSet.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @MainActor @preconcurrency public func formIndex(after i: inout Entity.ComponentSet.Index)

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    @MainActor @preconcurrency public func distance(from start: Entity.ComponentSet.Index, to end: Entity.ComponentSet.Index) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    @MainActor @preconcurrency public subscript(position: Entity.ComponentSet.Index) -> any Component { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public struct Indices : Collection, Sendable {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = Entity.ComponentSet.Index

        /// A type representing the sequence's elements.
        public typealias Element = Entity.ComponentSet.Index

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Entity.ComponentSet.Indices

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        public typealias SubSequence = Entity.ComponentSet.Indices

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Entity.ComponentSet.Indices.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Entity.ComponentSet.Indices.Index { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Entity.ComponentSet.Indices.Index) -> Entity.ComponentSet.Indices.Index

        /// Replaces the given index with its successor.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        public func formIndex(after i: inout Entity.ComponentSet.Indices.Index)

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        @inlinable public subscript(position: Entity.ComponentSet.Indices.Index) -> Entity.ComponentSet.Indices.Index { get }

        /// Returns the distance between two indices.
        ///
        /// Unless the collection conforms to the `BidirectionalCollection` protocol,
        /// `start` must be less than or equal to `end`.
        ///
        /// - Parameters:
        ///   - start: A valid index of the collection.
        ///   - end: Another valid index of the collection. If `end` is equal to
        ///     `start`, the result is zero.
        /// - Returns: The distance between `start` and `end`. The result can be
        ///   negative only if the collection conforms to the
        ///   `BidirectionalCollection` protocol.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
        ///   resulting distance.
        public func distance(from start: Entity.ComponentSet.Indices.Index, to end: Entity.ComponentSet.Indices.Index) -> Int

        /// Accesses a contiguous subrange of the collection's elements.
        ///
        /// For example, using a `PartialRangeFrom` range expression with an array
        /// accesses the subrange from the start of the range expression until the
        /// end of the array.
        ///
        ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     let streetsSlice = streets[2..<5]
        ///     print(streetsSlice)
        ///     // ["Channing", "Douglas", "Evarts"]
        ///
        /// The accessed slice uses the same indices for the same elements as the
        /// original collection. This example searches `streetsSlice` for one of the
        /// strings in the slice, and then uses that index in the original array.
        ///
        ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
        ///     print(streets[index])
        ///     // "Evarts"
        ///
        /// Always use the slice's `startIndex` property instead of assuming that its
        /// indices start at a particular value. Attempting to access an element by
        /// using an index outside the bounds of the slice may result in a runtime
        /// error, even if that index is valid for the original collection.
        ///
        ///     print(streetsSlice.startIndex)
        ///     // 2
        ///     print(streetsSlice[2])
        ///     // "Channing"
        ///
        ///     print(streetsSlice[0])
        ///     // error: Index out of bounds
        ///
        /// - Parameter bounds: A range of the collection's indices. The bounds of
        ///   the range must be valid indices of the collection.
        ///
        /// - Complexity: O(1)
        public subscript(bounds: Range<Entity.ComponentSet.Indices.Index>) -> Entity.ComponentSet.Indices { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be nonuniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can result in an unexpected copy of the collection. To avoid
        /// the unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        @inlinable public var indices: Entity.ComponentSet.Indices { get }

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Iterator = IndexingIterator<Entity.ComponentSet.Indices>
    }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @MainActor @preconcurrency public var indices: Entity.ComponentSet.Indices { get }

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<Entity.ComponentSet>
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity.ComponentSet : Sendable {
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity.ChildCollection : CustomStringConvertible {

    /// A textual representation of this instance. (See `CustomStringConvertible`.)
    @MainActor @preconcurrency public var description: String { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity.ChildCollection {

    public struct IndexingIterator<Elements> where Elements : Collection {
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity.ChildCollection : EntityCollection {

    /// Adds the specified list of entity as children to this entity.
    ///
    /// - Parameters:
    ///   - sequence:                 The child entities to add to the collection.
    @MainActor @preconcurrency public func append<S>(contentsOf sequence: S) where S : Sequence, S.Element : Entity

    /// Removes the specified child from this entity.
    ///
    /// - Parameters:
    ///   - child:                    The child entity to remove from the collection.
    @MainActor @preconcurrency public func remove(_ child: Entity)

    /// Adds the specified sequence of entities to this collection in order,
    /// directly before the entity at the given index.
    ///
    /// - Parameters:
    ///   - sequence:                  A sequence of entities to add to the collection.
    ///   - index:                     The index of an entity to insert in front
    ///                                of. If `endIndex` is provided, the
    ///                                entities will be appended.
    ///
    /// > Note: This operation can invalidate the index order of any extant entities.
    @MainActor @preconcurrency public func insert<S>(contentsOf sequence: S, beforeIndex index: Int) where S : Sequence, S.Element : Entity

    /// Removes the specified child from this entity.
    ///
    /// - Parameters:
    ///   - index:                    The index of the child entity to remove from the collection.
    @MainActor @preconcurrency public func remove(at index: Int)

    /// Removes all children from this entity.
    @MainActor @preconcurrency public func removeAll()

    /// Removes all children from this entity and adds the specified list of entities as the new
    /// children.
    ///
    /// - Parameters:
    ///   - children:                 The list of the new children.
    @MainActor @preconcurrency public func replaceAll<S>(_ children: S) where S : Sequence, S.Element : Entity
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity.ChildCollection : Sendable {
}

@available(visionOS 2.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(tvOS, unavailable)
extension Entity.CoordinateSpaceReference : Equatable {
}

@available(visionOS 2.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(tvOS, unavailable)
extension Entity.CoordinateSpaceReference : Hashable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity.ForwardDirection : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Entity.ForwardDirection : Hashable {
}

@available(macOS 10.15, iOS 13.0, *)
extension Entity.ChildCollection.IndexingIterator : IteratorProtocol, Sequence {

    /// The type of element traversed by the iterator.
    public typealias Element = Elements.Element

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = Entity.ChildCollection.IndexingIterator<Elements>

    public typealias SubSequence = AnySequence<Entity.ChildCollection.IndexingIterator<Elements>.Element>

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Elements.Element?
}

/// A protocol that defines an action for an entity.
///
/// Structures that conform to `EntityAction` can contain data that an ``ActionAnimation`` stores.
/// If your apps needs to serialize the animation resource to a file,
/// the structure also needs to adopt and conform to the
/// <doc://com.apple.documentation/documentation/swift/codable> protocol.
///
/// As action animation playback occurs, unique action events are raised for its associated `EntityAction`
/// conforming type.
///
/// These events allow application code to animate target values (see ``AnimationStateProtocol``), and perform
/// custom operations in lock step with animation playback.
///
/// The action data stored within an action animation is available to the action's event handler.
///
/// - Note: Custom actions don't support animating ``BlendShapeWeights``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public protocol EntityAction {

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    associatedtype EventParameterType = Never

    /// A Boolean value that determines whether the action reverses
    /// prior operations when playback is reverses.
    ///
    /// The default value is `true`.
    var isReversible: Bool { get }

    /// A Boolean value that determines whether this action
    /// additively blends with the prior stage.
    ///
    /// When `true`, the action's animation output is relative to an absolute base value,
    /// and the animation system blends the result additively with the prior blend stage.
    ///
    /// Apply actions additively by configuring them to produce
    /// animation offsets, such as delta values.
    ///
    /// The default value is `false`.
    var isAdditive: Bool { get }

    /// A value that defines the type that the action animates,
    /// if the action animates a target value.
    ///
    /// In your implementation, return a type that matches the
    /// action animation's bind target.
    ///
    /// For example if the action animates a ``Transform``,
    /// return `Transform.self` in your implementation,
    /// and set the action animation's bind target to  ``BindTarget/transform``
    /// when creating an ``AnimationResource`` with `AnimationResource.makeActionAnimation(...)`.
    var animatedValueType: (any AnimatableData.Type)? { get }
}

/// The protocol used to define an action. As action animation playback occurs, action events are raised that allows application
/// code to animate target values (see ``AnimationStateProtocol``), and perform operations in lock step
/// with animation playback.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EntityAction {

    /// A Boolean value that determines whether the action reverses
    /// prior operations when playback is reverses.
    ///
    /// The default value is `true`.
    public var isReversible: Bool { get }

    /// A Boolean value that determines whether this action
    /// additively blends with the prior stage.
    ///
    /// When `true`, the action's animation output is relative to an absolute base value,
    /// and the animation system blends the result additively with the prior blend stage.
    ///
    /// Apply actions additively by configuring them to produce
    /// animation offsets, such as delta values.
    ///
    /// The default value is `false`.
    public var isAdditive: Bool { get }

    /// Registers the action into the action-types registry.
    ///
    /// Registering an action allows RealityKit to retrieve its ``AnimationResource``
    /// definitions.
    ///
    /// Registering an action may not be necessary, because RealityKit automatically
    /// registers the action when you:
    /// - Initialize an ``ActionAnimation`` with this action.
    /// - Subscribe to it in any way,
    ///   including subscribing an ``ActionHandlerProtocol``.
    public static func registerAction()

    /// Subscribes to an action event.
    ///
    /// For example, you can call this method to subscribe to the update event,
    /// which the system calls each frame it evaluates the action:
    ///
    /// ```swift
    /// struct MyAction: EntityAction {
    ///     ...
    /// }
    /// MyAction.subscribe(to: .updated) { event in
    ///     // RealityKit calls this closure in lock step as it
    ///     // processes each animation frame.
    /// }
    /// ```
    public static func subscribe(to eventType: ActionEventType, _ handler: @escaping (ActionEvent<Self>) -> Void)

    /// Unsubscribes from an action event.
    public static func unsubscribe(from eventType: ActionEventType)

    /// Unsubscribes from all action events.
    public static func unsubscribeAll()
}

/// See: ``EntityAction`` protocol.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EntityAction where Self : Decodable, Self : Encodable, Self.EventParameterType : Decodable, Self.EventParameterType : Encodable {

    /// Registers the serializable action into the action-types registry.
    ///
    /// Registering an action allows RealityKit to retrieve its ``AnimationResource``
    /// definitions.
    ///
    /// Registering an action may not be necessary, because RealityKit automatically
    /// registers the action when you:
    /// - Initialize an ``ActionAnimation`` with this action.
    /// - Subscribe to it in any way,
    ///   including subscribing an ``ActionHandlerProtocol``.
    public static func registerAction()

    /// Subscribes to a serializable action event.
    ///
    /// For example, you can call this method to subscribe to the update event,
    /// which the system calls each frame it evaluates the action:
    ///
    /// ```swift
    /// struct MyAction: EntityAction {
    ///     ...
    /// }
    /// MyAction.subscribe(to: .updated) { event in
    ///     // RealityKit calls this closure in lock step as it
    ///     // processes each animation frame.
    /// }
    /// ```
    public static func subscribe(to eventType: ActionEventType, _ handler: @escaping (ActionEvent<Self>) -> Void)
}

/// An ordered, mutable collection of entities.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public protocol EntityCollection : Collection where Self.Element == Entity, Self.Index == Int {

    /// Adds the specified entity to the end of this collection.
    ///
    /// - Parameters:
    ///   - entity:                    The entity to add to the collection.
    ///
    /// > Note: This operation can invalidate the index order of any extant entities.
    mutating func append(_ entity: Entity)

    /// Adds the specified sequence of entities to the end of this collection,
    /// in order.
    ///
    /// - Parameters:
    ///   - sequence:                 The entities to add to the collection.
    ///
    /// > Note: This operation can invalidate the index order of any extant entities.
    mutating func append<S>(contentsOf sequence: S) where S : Sequence, S.Element : Entity

    /// Adds the specified entity to this collection directly before the entity
    /// at the given index. If the entity is already located before the index,
    /// the collection will not change.
    ///
    /// - Parameters:
    ///   - entity:                    The entity to add to the collection.
    ///   - index:                     The index of an entity to insert in front
    ///                                of. If `endIndex` is provided, the entity
    ///                                will be appended.
    ///
    /// > Note: This operation can invalidate the index order of any extant entities.
    mutating func insert(_ entity: Entity, beforeIndex index: Int)

    /// Adds the specified sequence of entities to this collection in order,
    /// directly before the entity at the given index.
    ///
    /// - Parameters:
    ///   - sequence:                  A sequence of entities to add to the collection.
    ///   - index:                     The index of an entity to insert in front
    ///                                of. If `endIndex` is provided, the
    ///                                entities will be appended.
    ///
    /// > Note: This operation can invalidate the index order of any extant entities.
    mutating func insert<S>(contentsOf sequence: S, beforeIndex index: Int) where S : Sequence, S.Element : Entity

    /// Removes the entity from the collection.
    ///
    /// - Parameters:
    ///   - entity:                    The entity to remove from the collection.
    ///
    /// > Note: This operation can invalidate the index order of any remaining entities.
    mutating func remove(_ entity: Entity)

    /// Removes the entity at the given index from this collection.
    ///
    /// - Parameters:
    ///   - index:                    The index of the entity to remove from the collection.
    ///
    /// > Note: This operation can invalidate the index order of any remaining entities.
    mutating func remove(at index: Int)

    /// Removes all entities from this collection.
    mutating func removeAll()

    /// Removes all entities from this collection that satisfy the given predicate.
    ///
    /// > Note: This operation can invalidate the index order of any remaining entities.
    mutating func removeAll(where: (Entity) throws -> Bool) rethrows

    /// Replaces all entities in this collection with those from the given
    /// sequence.
    ///
    /// - Parameters:
    ///   - entities:                 The sequence of entities that will replace
    ///                               the collection's current contents.
    ///
    /// > Note: This operation might not maintain the new entities' index order.
    mutating func replaceAll<S>(_ entities: S) where S : Sequence, S.Element : Entity
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension EntityCollection {

    /// Adds the specified entity to the end of this collection.
    ///
    /// - Parameters:
    ///   - entity:                    The entity to add to the collection.
    ///
    /// > Note: This operation can invalidate the index order of any extant entities.
    public mutating func append(_ entity: Entity)

    /// Adds the specified sequence of entities to the end of this collection,
    /// in order.
    ///
    /// - Parameters:
    ///   - sequence:                 The entities to add to the collection.
    ///
    /// > Note: This operation can invalidate the index order of any extant entities.
    public mutating func append<S>(contentsOf sequence: S) where S : Sequence, S.Element : Entity

    /// Adds the specified entity to this collection directly before the entity
    /// at the given index. If the entity is already located before the index,
    /// the collection will not change.
    ///
    /// - Parameters:
    ///   - entity:                    The entity to add to the collection.
    ///   - index:                     The index of an entity to insert in front
    ///                                of. If `endIndex` is provided, the entity
    ///                                will be appended.
    ///
    /// > Note: This operation can invalidate the index order of any extant entities.
    public mutating func insert(_ entity: Entity, beforeIndex index: Int)

    /// Removes the entity from the collection.
    ///
    /// - Parameters:
    ///   - entity:                    The entity to remove from the collection.
    ///
    /// > Note: This operation can invalidate the index order of any remaining entities.
    public mutating func remove(_ entity: Entity)

    /// Removes all entities from this collection.
    public mutating func removeAll()

    /// Removes all entities from this collection that satisfy the given predicate.
    ///
    /// > Note: This operation can invalidate the index order of any remaining entities.
    public mutating func removeAll(where shouldBeRemoved: (Entity) throws -> Bool) rethrows

    /// Replaces all entities in this collection with those from the given
    /// sequence.
    ///
    /// - Parameters:
    ///   - entities:                 The sequence of entities that will replace
    ///                               the collection's current contents.
    ///
    /// > Note: This operation might not maintain the new entities' index order.
    public mutating func replaceAll<S>(_ entities: S) where S : Sequence, S.Element : Entity
}

/// A structure that wraps all geometric pins an entity owns.
///
/// Access an instance of this structure through the entity property ``Entity/pins``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@MainActor public struct EntityGeometricPins : Sequence {

    /// Obtains a geometric pin the entity owns by name.
    ///
    /// - Parameter name: The name of an existing pin the entity owns.
    /// - Returns: The pin that associates with the name, or `nil` if no pin with a matching name is found.
    @MainActor public subscript(name: String) -> GeometricPin? { get }

    /// Creates and adds a geometric pin to the entity, and returns the entity geometric pin.
    ///
    /// The pin is added to the entity's ``GeometricPinsComponent``.
    ///
    /// - Parameters:
    ///    - name: The name of the pin in the namespace of the owning entity.
    ///    - position: The position of the pin, in local space of the owning entity.
    ///    - orientation: The orientation of the pin, in local space of the owning entity.
    /// - Returns: A `GeometricPin`, identifying the newly added reference frame on the ``Entity``.
    @discardableResult
    @MainActor public func set(named name: String, position: SIMD3<Float> = SIMD3<Float>(0, 0, 0), orientation: simd_quatf = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1)) -> GeometricPin

    /// Creates and adds a geometric pin to the entity, and returns the entity geometric pin.
    ///
    /// The pin is added to the entity's ``GeometricPinsComponent``.
    ///
    /// - Parameters:
    ///    - name: The name of the pin in the namespace of the owning entity.
    ///    - position: The position of the pin, in local space of the reference entity.
    ///    - orientation: The orientation of the pin, in local space of the reference entity.
    ///    - referenceEntity: The entity that specifies the space of input `position` and `orientation`.
    ///                       The input `position` and `orientation` are in the world space when this reference entity is `nil`.
    /// - Returns: A `GeometricPin`, identifying the newly added reference frame on the ``Entity``.
    @discardableResult
    @MainActor public func set(named name: String, position: SIMD3<Float> = SIMD3<Float>(0, 0, 0), orientation: simd_quatf = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1), relativeTo referenceEntity: Entity?) -> GeometricPin

    /// Creates and adds a geometric pin to the entity's skeletal joint, and returns the geometric pin.
    ///
    /// The pin is added to the entity's ``GeometricPinsComponent``.
    ///
    /// - Parameters:
    ///    - name: Name of the `GeometricPin` in the namespace of the owning entity.
    ///    - skeletalJointName: The name of the skeletal joint in the namespace of the owning entity.
    ///    - position: The position of the pin, in local space of the joint.
    ///    - orientation: The orientation of the pin, in local space of the joint.
    /// - Returns: A `GeometricPin`, identifying the newly added reference frame on the ``Entity``.
    @discardableResult
    @MainActor public func set(named name: String, skeletalJointName: String, position: SIMD3<Float> = SIMD3<Float>(0, 0, 0), orientation: simd_quatf = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1)) -> GeometricPin

    /// Removes a geometric pin with the given name from this entity.
    ///
    /// If found, the pin is removed from the entity's ``GeometricPinsComponent``.
    /// There is no effect if no matching ``GeometricPin`` is found.
    ///
    /// - Parameter name: The name of the geometric pin to remove.
    @MainActor public func remove(named name: String)

    /// The total number of pins.
    @MainActor public var count: Int { get }

    /// A Boolean value indicating whether the collection is empty.
    @MainActor public var isEmpty: Bool { get }

    /// An object to iterate over all geometric pins in the collection.
    public struct Iterator : IteratorProtocol {

        /// An individual pin in the collection.
        public typealias Element = GeometricPin

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> EntityGeometricPins.Iterator.Element?
    }

    /// An individual pin in the collection.
    public typealias Element = GeometricPin

    /// Returns an iterator for the sequence.
    @MainActor public func makeIterator() -> EntityGeometricPins.Iterator

    /// The entity where the local frame lives.
    @MainActor public let entity: Entity
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension EntityGeometricPins : Sendable {
}

/// An object that retrieves entities from a scene.
///
/// Use entity queries to iterate through all entities in a RealityKit scene
/// that meet certain criteria. To specify which entities to retrieve, use a
/// ``QueryPredicate``.
///
/// To execute the query, pass it into the scene’s ``RealityKit/Scene/performQuery(_:)``
/// method and then iterate over the results.
///
/// ```swift
/// // Build a query to retrieve all anchor components.
/// let query = EntityQuery(where: .has(AnchorComponent.self)
///
/// // Ask the scene to perform the query and iterate over the returned
/// entities. scene.performQuery(query).forEach { entity in
///     // Make any needed changes to entities.
/// }
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct EntityQuery {

    /// Creates a query that returns all entities in a scene.
    @available(macOS 12.0, iOS 15.0, *)
    public init()

    /// Creates a query that returns all entities in a scene that match specific
    /// criteria.
    ///
    /// - Parameters:
    ///   - predicate: The criteria that specifies the entities to return.
    @available(macOS 12.0, iOS 15.0, *)
    public init(where predicate: QueryPredicate<Entity>)
}

/// A component that scales the amount of light that an entity receives from its environment.
///
/// When rendering a RealityKit scene, you can control how much the environment's
/// lighting affects the virtual objects in your scene, such as the lighting from your
/// real-world surroundings, a virtual environment, or both.
/// Use an `EnvironmentLightingConfigurationComponent` to configure this amount for an entity.
///
/// For example, create an entity that receives no lighting from its environment by setting the weight to `0.0`.
///
/// ```swift
/// let spaceship = try await Entity(named: "spaceship")
/// spaceship.components.set(EnvironmentLightingConfigurationComponent(
///     environmentLightingWeight: 0.0))
/// ```
///
/// - Note: The weight value of the component also affects the lighting of the entity's descendants.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct EnvironmentLightingConfigurationComponent : Component, Equatable {

    /// A value that controls the environment-lighting contribution to an entity's lighting.
    ///
    /// The weight is a floating-point value in the range `[0.0, 1.0]`.
    /// * A value of `1.0` indicates the entity receives the full environment-lighting contribution.
    /// * A value of `0.0` indicates the entity receives no light from its environment. The entity still receives
    /// lighting from other sources, such as directional, point, and spot lights.
    /// * The default value is `1.0`.
    public var environmentLightingWeight: Float

    /// Creates an environment-lighting configuration component.
    ///
    /// - Parameter environmentLightingWeight: A floating-point value in the range `[0.0, 1.0]`,
    /// where `0.0` indicates no environment-lighting contribution and `1.0` indicates full environment-lighting
    /// contribution.
    public init(environmentLightingWeight: Float = 1.0)

    /// Returns a Boolean value that indicates whether two environment-lighting configuration components 
    /// are equal.
    ///
    /// - Parameters:
    ///   - lhs: An environment-lighting configuration component.
    ///   - rhs: Another environment-lighting configuration component.
    public static func == (lhs: EnvironmentLightingConfigurationComponent, rhs: EnvironmentLightingConfigurationComponent) -> Bool
}

/// An environmental resource that contains background and lighting information for a scene.
///
/// RealityKit supports image-based lighting that enables realistic reflections on your scene's 3D
/// content. You can define the look of your scene's background by supplying an environment resource
/// image that determines the general color of the room and location of any spotlights or shadowed areas
/// within the reflection. RealityKit applies the image's characteristics to your scene's reflective content.
///
/// ![Two screenshots depicting the process of applying an environment resource image to a reflective surface in a RealityKit scene. The first screenshot defines the
/// scene's background, which shows a wide angle view of a room with overhead lights. The second screenshot shows a sphere with the image of the room displayed in a
/// reflection.](EnvironmentResource)
///
/// RealityKit checks a bundle for an environment resource by the filename you supply to one of the load functions.
///
/// ### Creating a Skybox Folder
///
/// To add an environment resource to your Xcode project, make a folder with a name that ends in `.skybox` and
/// place a single image inside. The image should be an environment map of equirectangular projection, also
/// known as latitude-longitude projection. Drag the folder into your Xcode project file navigator. In the options
/// pane, choose to create a folder reference (not a group), and add the folder to your app's target(s). At build time,
/// Xcode compiles the image for use as an environment resource and inserts the result into the app bundle.
///
/// RealityKit supports the same input formats as Image I/O, like `.png` and `.jpg`. However, to achieve rich, vibrant
/// lighting, use `.exr` or `.hdr` format, which support a wide dynamic range.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class EnvironmentResource : Resource {

    /// Synchronously loads an environment resource from a bundle.
    ///
    /// Loading an ``EnvironmentResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    ///
    /// If your image file is at the path `Foo.skybox/Bar.exr` in your Xcode project,
    /// use `Bar` for the name parameter.
    ///
    /// To add an environment resource to your Xcode project, see ``realitykit/environmentresource``.
    ///
    /// > Important: This function blocks the calling thread while RealityKit loads the requested resource.
    ///
    /// - Parameters:
    ///   - name:     The image name without the file extension.
    ///   - bundle:   The bundle to search for the resource. Use `nil` to indicate the app’s bundle.
    ///
    /// - Returns: The environment resource loaded from the specified bundle.
    @available(*, noasync, message: "Synchronous loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func load(named name: String, in bundle: Bundle? = nil) throws -> EnvironmentResource

    /// Asynchronously loads an environment resource from a bundle.
    ///
    /// If your image file is at the path `Foo.skybox/Bar.exr` in your Xcode project, use
    /// `Bar` for the name parameter. This function needs to be called with the `async` keyword from an asynchronous context,
    ///  such as from within a <doc://com.apple.documentation/documentation/swift/task> closure.
    ///
    /// To add an environment resource to your Xcode project, see ``realitykit/environmentresource``.
    ///
    /// - Parameters:
    ///   - name:     The image name without the file extension.
    ///   - bundle:   The bundle to search for the resource. Use `nil` to indicate the app’s bundle.
    ///
    /// - Returns: The environment resource loaded from the specified bundle.
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "init(named:in:)")
    @available(iOS, introduced: 13.0, deprecated: 18.0, renamed: "init(named:in:)")
    @available(macCatalyst, introduced: 13.0, deprecated: 18.0, renamed: "init(named:in:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "init(named:in:)")
    @MainActor @preconcurrency public static func loadAsync(named name: String, in bundle: Bundle? = nil) -> LoadRequest<EnvironmentResource>

    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "EnvironmentResource.init(equirectangular:withName:)")
    @available(macOS, unavailable)
    @available(iOS, unavailable, introduced: 18.0, renamed: "EnvironmentResource.init(equirectangular:withName:)")
    @available(macCatalyst, unavailable, introduced: 18.0, renamed: "EnvironmentResource.init(equirectangular:withName:)")
    @MainActor @preconcurrency public static func generate(fromEquirectangular cgImage: CGImage, withName resourceName: String? = nil) throws -> EnvironmentResource

    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "EnvironmentResource.init(equirectangular:withName:)")
    @available(macOS, unavailable, introduced: 15.0, renamed: "EnvironmentResource.init(equirectangular:withName:)")
    @available(iOS, unavailable, introduced: 18.0, renamed: "EnvironmentResource.init(equirectangular:withName:)")
    @available(macCatalyst, unavailable, introduced: 18.0, renamed: "EnvironmentResource.init(equirectangular:withName:)")
    @MainActor @preconcurrency public static func generate(fromEquirectangular cgImage: CGImage, withName resourceName: String? = nil) async throws -> EnvironmentResource
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension EnvironmentResource {

    @MainActor @preconcurrency public convenience init(named name: String, in bundle: Bundle? = nil) async throws

    /// The cube color texture containing environment surrounding details.
    ///
    /// The skybox contains the environment's detailed surroundings as a cube texture, often used to render the background
    /// of a scene.
    /// The skybox texture determines the environment's lighting.
    /// You can assign the skybox texture to a ``ShaderGraphMaterial`` cube texture parameter.
    ///
    /// ```swift
    /// // Load an environment resource.
    /// let env = try await EnvironmentResource(
    ///     named: environmentResourceName, in: Bundle.main)
    ///
    /// // Assign its skybox to a material's cube map texture parameter.
    /// var skyboxCubeMaterial = try await ShaderGraphMaterial(named: materialUSDPath,
    ///                                                        from: sceneResourceName,
    ///                                                        in: contentBundle)
    /// try await skyboxCubeMaterial.setParameter(name: cubeTextureParameterName,
    ///                                           value: .textureResource(env.skybox))
    /// skyboxCubeMaterial.faceCulling = .front
    ///
    /// // Apply to a background sky dome sphere.
    /// let skyDome = await ModelEntity(mesh: .generateSphere(radius: 1E3),
    ///                                 materials: [skyboxCubeMaterial])
    ///
    /// await MainActor.run {
    ///     sceneRootEntity.addChild(skyDome)
    ///
    ///     // Also use the environment resource for lighting.
    ///     let probe = VirtualEnvironmentProbeComponent.Probe(environment: env)
    ///     sceneRootEntity.components.set(VirtualEnvironmentProbeComponent(source: .single(probe)))
    /// }
    /// ```
    ///
    @MainActor @preconcurrency public var skybox: TextureResource { get }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension EnvironmentResource {

    /// Synchronously generates an environment resource from a cube TextureResource.
    ///
    /// Loading an ``EnvironmentResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    ///
    /// Generates an environment resource from a skybox cube texture of the environment.
    /// The created environment shares the input skybox.
    ///
    /// See ``init(cube:options:)-5v70i`` for more details.
    ///
    /// ```swift
    /// // Use compression and high quality options to export optimized resources.
    /// let cube = try await TextureResource(
    ///     cubeFromEquirectangular: image,
    ///     quality: .high,
    ///     options: TextureResource.CreateOptions(semantic: .hdrColor)
    /// )
    ///
    /// let options = EnvironmentResource.CreateOptions(
    ///     samplingQuality: .high,
    ///     specularCubeDimension: cube.width/2,
    ///     compression: .astc(blockSize: .block4x4, quality: .high)
    /// )
    ///
    /// // Create an environment resource from the cube texture.
    /// let environment = try await EnvironmentResource(
    ///     cube: cube, options: EnvironmentResource.CreateOptions(
    ///             samplingQuality: .high,
    ///             specularCubeDimension: cube.width/2,
    ///             compression: .astc(blockSize: .block4x4, quality: .high)
    ///     )
    /// )
    ///
    /// await MainActor.run {
    ///     // Assign the environment to an image based light component.
    ///     let lightEntity = Entity()
    ///     lightEntity.components.set(ImageBasedLightComponent(
    ///         source: .single(environment)
    ///     ))
    ///     ...
    /// }
    /// ```
    ///
    /// - parameter cubeTexture: A skybox cube texture of type `.cubeType` and with `.color` or `.hdrColor` semantics.
    /// - parameter options: A configuration for generating the environment resource.
    ///
    /// - Note: If `.astc` compression is requested and `cubeTexture` is not already
    ///         compressed, RealityKit compresses it.
    ///
    @available(tvOS, unavailable)
    @MainActor @preconcurrency public convenience init(cube cubeTexture: TextureResource, options: EnvironmentResource.CreateOptions) throws

    /// Synchronously creates an environment resource from an equirectangular image.
    ///
    /// Loading an ``EnvironmentResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    ///
    /// - Parameters:
    ///   - cgImage: The source equirectangular (latitude, longitude) image. Use an image where the width is half the height to preserve all details.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    @MainActor @preconcurrency public convenience init(equirectangular cgImage: CGImage, withName resourceName: String? = nil) throws

    /// Asynchronously generates an environment resource from an equirectangular image.
    ///
    /// - Parameters:
    ///   - cgImage: The source equirectangular (latitude, longitude) image. Use an image where the width is half the height to preserve all details.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    @MainActor @preconcurrency public convenience init(equirectangular cgImage: CGImage, withName resourceName: String? = nil) async throws

    /// Asynchrnoously creates an environment resource from a cube texture.
    ///
    /// Generates an environment resource from a skybox cube texture of the environment.
    /// The created environment shares the input skybox.
    ///
    /// - Note: ``CreateOptions/SamplingQuality-swift.enum/high`` and ``CreateOptions/SamplingQuality-swift.enum/veryHigh``,
    ///         along with ``TextureResource/Compression/astc(blockSize:quality:)`` compression options, are only available on macOS.
    ///         Use these options to write optimized scenes for all target platforms when exporting from macOS with ``Entity/write(to:)``.
    ///         Compression options also significantly reduce environmental resource's memory and disk usage.
    ///
    /// ```swift
    /// // Use compression and high quality options to export optimized resources.
    /// let cube = try TextureResource(
    ///     cubeFromEquirectangular: image,
    ///     quality: .high,
    ///     options: TextureResource.CreateOptions(semantic: .color)
    /// )
    ///
    /// let options = EnvironmentResource.CreateOptions(
    ///     samplingQuality: .high,
    ///     specularCubeDimension: cube.width/2,
    ///     compression: .astc(blockSize: .block4x4, quality: .high)
    /// )
    ///
    /// let environment = try EnvironmentResource(
    ///     cube: cube,
    ///     options: EnvironmentResource.CreateOptions(
    ///         samplingQuality: .high,
    ///         specularCubeDimension: cube.width/2,
    ///         compression: .astc(blockSize: .block4x4, quality: .high)
    ///     )
    /// )
    ///
    /// let lightEntity = Entity()
    /// lightEntity.components.set(ImageBasedLightComponent(
    ///     source: .single(environment)
    /// ))
    /// ...
    /// ```
    ///
    /// - parameter cubeTexture: A skybox cube texture of type `.cubeType` and with `.color` or `.hdrColor` semantics.
    /// - parameter options: A configuration for generating the environment resource.
    ///
    /// - Note: If `.astc` compression is requested and `cubeTexture` is not already
    ///         compressed, RealityKit compresses it.
    ///
    @available(tvOS, unavailable)
    @MainActor @preconcurrency public convenience init(cube cubeTexture: TextureResource, options: EnvironmentResource.CreateOptions) async throws
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension EnvironmentResource {

    public typealias Compression = TextureResource.Compression

    /// A type that controls compression, sampling quality, and cubemap dimensions when creating an environment resource.
    ///
    /// The options provide control for balancing memory usage, quality, and processing power
    /// when creating an environment's lighting data.
    public struct CreateOptions : Hashable, Sendable {

        /// An object for controlling the skybox sampling quality for lighting textures.
        public enum SamplingQuality : Hashable, Sendable {

            /// Computes the environment textures with small sampling rates.
            /// Low sampling rates can result in higher noise in high frequency areas
            /// and banding in low frequency gradients.
            case fast

            case normal

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: EnvironmentResource.CreateOptions.SamplingQuality, b: EnvironmentResource.CreateOptions.SamplingQuality) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// The compression applied to environment textures.
        public var compression: EnvironmentResource.Compression

        /// The skybox sampling quality for lighting textures.
        public var samplingQuality: EnvironmentResource.CreateOptions.SamplingQuality

        /// The dimension of the computed specular cubemap for material reflections.
        ///
        /// If `nil`, the environment resource uses the source cubemap's dimensions.
        ///
        /// Use a lower value than that of the cubemap helps to reduce the memory footprint
        /// in scenes where skybox details are not seen through specular reflections.
        ///
        /// - Note: The specular cube dimension is clamped to the source
        /// cubemap's dimensions if it exceeds them.
        public var specularCubeDimension: Int?

        /// Creates a new environment creation options structure.
        ///
        /// - Parameters:
        ///   - samplingQuality: The skybox sampling quality for lighting textures.
        ///   - specularCubeDimension: The dimension of the computed specular cubemap for material reflections.
        ///   - compression: The compression applied to environment textures.
        public init(samplingQuality: EnvironmentResource.CreateOptions.SamplingQuality = .fast, specularCubeDimension: Int? = nil, compression: EnvironmentResource.Compression = .default)

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: EnvironmentResource.CreateOptions, b: EnvironmentResource.CreateOptions) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

/// A type that can be sent as an event.
///
/// RealityKit provides a number of events you can subscribe to to get notified when
/// things happens in a scene. For example, you can subscribe to ``RealityKit/CollisionEvents/Began``
/// to get notified when two objects begin colliding, or ``RealityKit/SceneEvents/Update`` to get notified
/// when the scene redraws.
///
///  ## Subscribe with a closure
///
/// To subscribe to a scene event, import Combine, create a property of type <doc://com.apple.documentation/documentation/combine/cancellable>
/// to maintain a reference to the subscription, then call ``RealityKit/Scene/subscribe(to:on:_:)``
/// or ``RealityKit/Scene/subscribe(to:on:componentType:_:)`` and provide a closure.
///
/// The closure is passed an ``RealityKit/Scene/Event`` object that contains information relevant to the type of event you subscribed to.
///
/// Here's an example of subscribing to the collision begain event and retrieving the two entities involved in the collision:
///
/// ```swift
///  import AppKit
///  import RealityKit
///  import Combine
///
///  class GameViewController: NSViewController {
///
///      @IBOutlet var arView: ARView!
///      var collisionSubscription:Cancellable?
///
///      override func awakeFromNib() {
///         let boxAnchor = try! Experience.loadBox()
///         arView.scene.anchors.append(boxAnchor)
///
///         collisionSubscription = arView.scene.subscribe(
///            to: CollisionEvents.Began.self,
///             on: boxAnchor
///        ) { event in
///            print("collision started")
///            let firstEntity = event.entityA
///            let secondEntity = event.entityB
///            // Take appropriate action...
///         }
///    }
///  }
/// ```
///
///  ## Subscribe using a method
///
/// You can also subscribe to events using a function rather than a closure by using
/// <doc://com.apple.documentation/documentation/combine/publisher/sink(receivecompletion:receivevalue:)>.
/// Here's an example of using a function to respond to that same event:
///
/// ```swift
/// import AppKit
/// import RealityKit
/// import Combine
///
/// class GameViewController: NSViewController {
///
///     @IBOutlet var arView: ARView!
///     var collisionSubscription:Cancellable?
///
///     override func awakeFromNib() {
///         let boxAnchor = try! Experience.loadBox()
///         arView.scene.anchors.append(boxAnchor)
///
///         collisionSubscription = arView.scene.publisher(for: CollisionEvents.Began.self,
///                                                        on:nil).sink(receiveValue: onCollisionBegan)
///     }
///
///     private func onCollisionBegan(_ event:
///                                   CollisionEvents.Began) {
///         print("collision started")
///         let firstEntity = event.entityA
///         let secondEntity = event.entityB
///         // Take appropriate action...
///     }
/// }
/// ```
@available(macOS 10.15, iOS 13.0, *)
public protocol Event : Sendable {
}

/// A type on which events can be published and subscribed.
@available(macOS 10.15, iOS 13.0, *)
public protocol EventSource {
}

/// A subscription to an event.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct EventSubscription {

    /// Cancels the event subscription.
    public func cancel()

    public func subscribe(to scene: Scene)
}

/// Defines a force effect's system, and type specific properties.
///
/// This struct wraps your custom force effect that conforms to ``ForceEffectProtocol`` and
/// provides properties that are common to all force effects.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ForceEffect<ForceEffectType> : ForceEffectBase where ForceEffectType : ForceEffectProtocol {

    /// Creates a ForceEffect struct.
    ///  - Parameters:
    ///    - effect:  Effect specific parameters.
    ///    - strengthScale:  Scales the overall strength of the effect.
    ///    - spatialFalloff: The falloff function parameters used to attenuate the force based on distance from the effect origin.
    ///    - timedFalloff: The falloff function parameters used to attenuate the force based on time.
    ///    - position: The position  of the effect relative to the effect entity's transform.
    ///    - orientation: The orientation of the effect relative to the effect entity's transform.
    ///    - mask: The mask used to select which groups of rigid bodies the effect should be applied to.
    public init(effect: ForceEffectType, strengthScale: Double = 1.0, spatialFalloff: SpatialForceFalloff? = nil, timedFalloff: TimedForceFalloff? = nil, position: SIMD3<Float> = SIMD3<Float>(0, 0, 0), orientation: simd_quatf = simd_quaternion(0, 0, 0, 1), mask: CollisionGroup = .all)

    /// Parameters that can vary for different types.
    public var effect: ForceEffectType

    /// Optional strength falloff based on the spatial bounds of the effect.
    public var spatialFalloff: SpatialForceFalloff?

    /// Optional strength falloff based on the duration of the effect.
    public var timedFalloff: TimedForceFalloff?

    /// Position of the force effect relative to the effect's transform component.
    public var position: SIMD3<Float>

    /// Rotation of the force effect relative to the effect's transform component.
    public var orientation: simd_quatf

    /// A multiplier that scales the strength of the effect.
    public var strengthScale: Float

    /// Controls which collision groups will be affected by this force effect.
    public var mask: CollisionGroup
}

/// The base protocol for the wrapping force effect structure containing
/// common parameters for all force-effects.
///
/// Don't implement this protocol yourself. Create force effects by calling methods on ``ForceEffect``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public protocol ForceEffectBase {

    /// A type that represents the kind of force effect.
    ///
    /// This type underlies the force type of a ``ForceEffect``.
    associatedtype ForceEffectType : ForceEffectProtocol

    /// Custom force effect parameters.
    var effect: Self.ForceEffectType { get }

    /// Optional strength falloff based on the spatial bounds of the effect.
    var spatialFalloff: SpatialForceFalloff? { get }

    /// Optional strength falloff based on the duration of the effect.
    var timedFalloff: TimedForceFalloff? { get }

    /// Position of the force effect relative to the effect's transform component.
    var position: SIMD3<Float> { get }

    /// Rotation of the force effect relative to the effect's transform component.
    var orientation: simd_quatf { get }

    /// A multiplier that scales the strength of the effect.
    var strengthScale: Float { get }

    /// Controls which collision groups will be affected by this force effect.
    var mask: CollisionGroup { get }
}

/// The boundary options for a force effect.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public enum ForceEffectBounds {

    /// A spherical boundary that's centered at the origin of the force effect and has a non-negative radius.
    /// - Parameter radius: A non-negative value that represents the boundary's distance from the force effect's origin, in meters.
    case sphere(radius: Double)
}

/// A component that defines force effects on an entity.
///
/// After an entity gets the `ForceEffectComponent`, the force effects in the component start to play by default.
/// You can set the ``ForceEffectComponent/simulationState-swift.property`` to ``SimulationState-swift.enum/pause`` if you want to play it later.
///
///```swift
/// let entity = Entity()
/// let constantEffect = ForceEffect(effect: ConstantForceEffect(strength: 1, direction: [1, 0, 0]))
/// entity.components.set(ForceEffectComponent(effects: [constantEffect], simulationState: .pause))
///```
///
/// A `ForceEffectComponent` handles one or more ``ForceEffect`` instances, updating them
/// sequentially while the physics system accumulates their forces.
///
/// The center frame of each ``ForceEffect`` coincides with and moves alongisde the entity's position and orientation.
/// To offset this center frame, set ``ForceEffect/position`` and ``ForceEffect/orientation``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ForceEffectComponent : Component {

    /// One or more effects used to simulate forces.
    ///
    /// Forces from each effect will be summed.
    public var effects: [any ForceEffectBase]

    /// Creates a force effect component.
    ///   - Parameters:
    ///     - effects: Array of effects to simulate forces with.
    ///       Forces generated by each effect will be summed.
    ///     - simulationState: The simulation state request, the force effect automatically starts to play by default.
    public init(effects: [any ForceEffectBase], simulationState: ForceEffectComponent.SimulationState = .start)

    /// Creates a force effect component with a single force effect, and automatically plays it.
    ///   - Parameters:
    ///     - effect: The  effect to simulate forces with.
    public init(effect: any ForceEffectBase)

    /// Simulation runtime states.
    public enum SimulationState {

        /// The simulation will start, and its time set to zero.
        /// The simulation will restart if already started.
        case start

        /// The simulation will pause.
        case pause

        /// The simulation will resume, if paused.
        case resume

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ForceEffectComponent.SimulationState, b: ForceEffectComponent.SimulationState) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Used to set the desired state of the simulation.
    public var simulationState: ForceEffectComponent.SimulationState?
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ForceEffectComponent.SimulationState : Equatable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ForceEffectComponent.SimulationState : Hashable {
}

/// A struct that defines the arguments to the custom force effect update closure.
///
/// If you register your custom force effect using a closure, you can access the force effect's property and
/// ``ForceEffectParameters`` from this struct.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ForceEffectEvent<ForceEffectType> where ForceEffectType : ForceEffectProtocol {

    /// The force effect to update.
    public var effect: ForceEffectType

    /// Physics body parameters.
    public var parameters: ForceEffectParameters
}

/// The force effect input data to the effect's update handler or closure.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ForceEffectParameters {

    /// The entity containing the force effect.
    public let entity: Entity

    /// The number of physics bodies to be updated.
    public let physicsBodyCount: Int

    /// The fixed delta time between simulation steps.
    public let fixedDeltaTime: TimeInterval

    /// The amount of time that has elapsed since the force effect was started.
    public let elapsedTime: TimeInterval

    /// The positions of all rigid bodies under the influence of the effect,
    /// or nil if positional information was not requested.
    ///
    /// The position is located at each body's center of mass, relative to the origin of the effect.
    public let positions: UnsafeForceEffectBuffer<SIMD3<Float>>?

    /// The orientations of all rigid bodies under the influence of the effect,
    /// or nil if rotational information was not requested.
    ///
    /// The orientation is relative to the effect's transform.
    public let orientations: UnsafeForceEffectBuffer<simd_quatf>?

    /// The velocities of all rigid bodies under the influence of the effect,
    /// or nil if velocity information was not requested.
    public let velocities: UnsafeForceEffectBuffer<SIMD3<Float>>?

    /// The angular velocities of all rigid bodies under the influence of the effect,
    /// or nil if angular velocity information was not requested.
    public let angularVelocities: UnsafeForceEffectBuffer<SIMD3<Float>>?

    /// The distance from the effect to each rigid body's center of mass,
    /// or nil if distance information was not requested.
    public let distances: UnsafeForceEffectBuffer<Float>?

    /// The mass of each rigid body, or nil if mass information was not requested
    /// or force mode does not require it.
    public let masses: UnsafeForceEffectBuffer<Float>?

    /// The inertia tensor based on the current rigid body's orientation, or nil if
    /// inertia tensor information was not requested.
    public let inertiaTensors: UnsafeForceEffectBuffer<simd_float3x3>?

    /// Sets the force for each rigid body.
    ///
    /// Inside the force effect update function, you are responsible to compute and output the force
    /// by calling this function for each rigid body. If you omit this function for a rigid body, that rigid body
    /// gets zero force from the effect.
    ///   - Parameters:
    ///     - force: The force value.
    ///     - index: The index to the rigid body. The index should be in the range [0, ``ForceEffectParameters/physicsBodyCount``].
    public func setForce(_ force: SIMD3<Float>, index: Int)

    /// Sets the torque for each rigid body.
    ///
    /// Inside the force effect update function, you are responsible to compute and output the torque
    /// by calling this function for each rigid body. If you omit this function for a rigid body, that rigid body
    /// gets zero torque from the effect.
    ///   - Parameters:
    ///     - torque: The torque value.
    ///     - index: The index to the rigid body. The index should be in the range [0, ``ForceEffectParameters/physicsBodyCount``].
    public func setTorque(_ torque: SIMD3<Float>, index: Int)
}

/// A protocol that defines a custom force effect.
///
/// A custom force effect is a function of a set of input rigid body attributes and returns force-like vector quantities.
/// You can declare this custom force effect's input types (``ForceEffectProtocol/parameterTypes-4wuau``) and
/// output types (``ForceEffectProtocol/forceMode``) by conforming to `ForceEffectProtocol`.
///
/// For example, you can declare a custom force effect that depends on rigid bodies' position and mass,
/// and computes acceleration for each rigid body.
///
///```swift
/// struct MyCustomForce : ForceEffectProtocol {
///     var parameterTypes: PhysicsBodyParameterTypes { [.position, .mass] }
///     var forceMode: ForceMode = .acceleration
///     func update(parameters: inout ForceEffectParameters) {
///     }
/// }
///```
///
/// Register your custom force effect to enable the physics system to compute forces affected by rigid bodies.
///
///```swift
/// MyCustomForce.register()
///```
///
/// At each physics update, the ``ForceEffectProtocol/update(parameters:)-52e1i`` method
/// receives the declared inputs from ``ForceEffectParameters``.
/// You can set the output forces for each rigid body with ``ForceEffectParameters/setForce(_:index:)``.
///
/// Sometimes, you may need to access properties from both your custom force effect
/// and the current context while computing forces in the update function.
/// The ``ForceEffectProtocol/register(_:)-1zt9t`` method accepts an optional closure that
/// allows you to capture the necessary properties.
/// If you provide this closure to the register method, the update method is not required.
///
///```swift
/// struct MyCustomForceClosure: ForceEffectProtocol {
///     var forceMode: RealityFoundation.ForceMode = .force
///     var parameterTypes: PhysicsBodyParameterTypes { [.position, .mass] }
///     let customProperty: Double = 1
/// }
///
/// let contextualProperty: Double = 1
///
/// MyCustomForceClosure.register { event in
///     // Access the effect property via `event.effect.customProperty`.
///     // Access the input rigid body attributes via `event.parameters`.
///     // Access the contextual property directly by `contextualProperty`.
/// }
///```
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public protocol ForceEffectProtocol {

    /// The input types to user's custom force computation.
    var parameterTypes: PhysicsBodyParameterTypes { get }

    /// The mode that controls how the physics system interprets the outputs from a user's custom force computation.
    var forceMode: ForceMode { get }

    /// Defines how the custom force effect computes forces at each physics simulation step.
    ///  - Parameters:
    ///    - parameters: On input, the rigid body parameters declared in ``ForceEffectProtocol/parameterTypes``.
    ///    On output, the computed forces and torques.
    func update(parameters: inout ForceEffectParameters)
}

/// Extensions that provide default implementation for custom force effect.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ForceEffectProtocol {

    /// Positions are returned by default to effect handlers.
    public var parameterTypes: PhysicsBodyParameterTypes { get }

    /// Outputs zero forces and torques by default.
    public func update(parameters: inout ForceEffectParameters)

    /// Registers the custom effect.
    ///
    /// If a handler is specified, the physics system calls the handler and ignores the update function.
    ///  - Parameters:
    ///    - updateHandler: a closure that computes custom forces for rigid bodies.
    public static func register(_ updateHandler: ((inout ForceEffectEvent<Self>) -> Void)? = nil)
}

/// Extensions that provide default implementation for codable custom force effect.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ForceEffectProtocol where Self : Decodable, Self : Encodable {

    /// Register the codable custom effect. If a handler is specified, the closure is used to update the effect.
    public static func register(_ updateHandler: ((inout ForceEffectEvent<Self>) -> Void)? = nil)
}

/// The options that control how physics system applies the forces.
///
/// `ForceMode` allows you to customize how the physics system applies the force-like vector quantity that you set via
/// ``ForceEffectParameters/setForce(_:index:)``
/// and ``ForceEffectParameters/setTorque(_:index:)``.
/// For example, ``ForceMode/force`` indicates the vector quantity has the unit of force, which is the most common choice.
/// You can use ``ForceMode/acceleration`` to exert a constant acceleration on rigid bodies regardless of their mass.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public enum ForceMode : Codable, Equatable {

    /// A constant force or torque applied to a body, influencing motion over time.
    ///
    /// The quantity that user sets via ``ForceEffectParameters/setForce(_:index:)``
    /// has the units of mass * distance /  time^2. i.e. a force ( mass * acceleration ).
    /// `force` mode causes a change in acceleration that varies proportionally to a body's mass.
    ///
    /// The quantity that user sets via ``ForceEffectParameters/setTorque(_:index:)``
    /// has the units of mass * distance^2 / time^2.
    /// `force` mode causes a change in angular acceleration that varies proportionally to a body's mass and inertia.
    case force

    /// A direct adjustment to a body's linear or angular acceleration, independent of its mass or inertia.
    ///
    /// The quantity that user sets via ``ForceEffectParameters/setForce(_:index:)``
    /// has the units of distance / time^2.
    /// `acceleration` mode causes a change in acceleration independent of a body's mass.
    ///
    /// The quantity that user sets via ``ForceEffectParameters/setTorque(_:index:)``
    /// has the units of 1 / time^2 or radian / time^2.
    /// `acceleration` mode causes a change in angular acceleration independent of a body's mass or inertia.
    case acceleration

    /// A direct adjustment to a body's linear or angular momentum.
    ///
    /// The quantity that user sets via ``ForceEffectParameters/setForce(_:index:)``
    /// has the units of mass * distance / time.
    /// `impulse` mode causes a change in linear momentum.
    ///
    /// The quantity that user sets via ``ForceEffectParameters/setTorque(_:index:)``
    /// has the units of mass * distance^2 / time.
    /// `impulse` mode causes a change in angular momentum.
    case impulse

    /// A direct adjustment to a body's linear or angular velocity, independent of its mass or inertia.
    ///
    /// The quantity that user sets via ``ForceEffectParameters/setForce(_:index:)``
    /// has the units of distance / time.
    /// `velocity` mode causes a change in velocity independent of a body's mass.
    ///
    /// The quantity that user sets via ``ForceEffectParameters/setTorque(_:index:)``
    /// has the units of 1 / time or radian / time.
    /// `velocity` mode causes a change in angular velocity independent of a body's mass or inertia.
    case velocity

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ForceMode, b: ForceMode) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ForceMode : Hashable {
}

/// An action that starts, stops, or increments by a specific value.
///
/// This action animates a bound parameters value over time. Specifying a ``FromToByAction/from``
/// value represents the animated properties' initial value at the start of the animation. Specifying a ``FromToByAction/to``
/// determines the value of the property at the end of the animation. Specifying a``FromToByAction/by`` adds a value to the
/// properties initial state, which calculates the value at the end of the animation.
///
/// This action exposes ``FromToByAction/TransformMode`` which is used when animating a ``Transform`` property.
/// Use this mode to determine the reference space the property is relative to. For example, ``TransformMode/local`` means
/// the provided transforms are relative to the transform of the bound entity. The only exception is when ``FromToByAction/by`` is
/// specified, this is relative to the space of the starting transform.
///
/// - Note: `FromToByAction` doesn't support ``JointTransforms`` or ``BlendShapeWeights`` types.
///   Use ``FromToByAnimation`` to animate these types.
///
/// ### Creating a from, to, by action to animate an entity's opacity
/// The example below creates an animation which gradually animates the bound  entity's
/// opacity property for five seconds with a linear transition.
/// In this example, the entity starts with opacity at `1.0`.
///
/// ```swift
/// // Create an action that gradually animates a float value
/// // towards `0.0`, with a linear transition.
/// //
/// // This action does not have a `from` value supplied, 
/// // meaning this starts from the default source value.
/// let opacityAction = FromToByAction<Float>(to: 0.0,
///                                           timing: .linear,
///                                           isAdditive: false)
///
/// // A five second animation that plays an animation causing the entity to
/// // gradually animate the `.opacity` property towards `0.0`.
/// //
/// // This makes the entity fade-out.
/// let opacityAnimation = try AnimationResource
///     .makeActionAnimation(for: opacityAction,
///                          duration: 5.0,
///                          bindTarget: .opacity)
///
/// // Play the five second animation on the entity that will fade-out.
/// entity.playAnimation(opacityAnimation)
/// ```
///
/// ### Create a from, to, by action to animate an entity's transform property
/// The example below creates an animation which gradually animates the bound entities
/// transform property for five seconds with a linear transition.
///
/// ```swift
/// // Create a transform to start animating from.
/// let startTransform = Transform(translation: [0.0, 2.0, 0.0])
///
/// // Create a transform to animate towards.
/// let endTransform = Transform(translation: [0.0, -2.0, 0.0])
///
/// // Create an action that gradually animates a transform value.
/// //
/// // This starts `from` a specified value, and animates towards
/// // a specified `to` value.
/// //
/// // The bound entity will move in the space relative to its parent.
/// let transformAction = FromToByAction<Transform>(from: startTransform,
///                                                 to: endTransform,
///                                                 mode: .parent,
///                                                 timing: .linear,
///                                                 isAdditive: false)
///
/// // A five second animation that plays an animation causing 
/// // the entity to gradually move from a specific start, and end transform
/// let transformAnimation = try AnimationResource
///     .makeActionAnimation(for: transformAction,
///                          duration: 5.0,
///                          bindTarget: .transform)
///
/// // Play the five second animation on the entity that will cause it to move.
/// entity.playAnimation(transformAnimation)
/// ```
///
/// - Note: The default source value is the base value of the of animated property. If
///         multiple animations target the property, then the framework observes the
///         output of the previous animation as the subsequent animation's default
///         source value.
///
/// - Important: This action animates various bound properties, for example ``BindTarget/transform`` on the bound entity.
///              Ensure a correct bind target is supplied when creating the animation.
///
/// - Note: For more information on the combination of inputs this action supports see ``FromToByAnimation``.
///
/// - Important: If you do not provide values for any of the `from`, `to`, and `by` parameters,
///   the animation stays at the default source value.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct FromToByAction<Value> : EntityAction, Codable where Value : AnimatableData {

    /// The state of the animated property before the animation starts.
    ///
    /// When the value is `nil`, the system uses the default source value.
    public let from: Value?

    /// The state of the animated property after the animation ends.
    ///
    /// When the value is `nil`, the system uses the default source value.
    public let to: Value?

    /// The amount that the animated property changes during the animation.
    public let by: Value?

    /// A timing function that controls the progress of the animation.
    public var timingFunction: AnimationTimingFunction

    /// Options available to determine the space the bound entity should be relative to.
    ///
    /// The ``FromToByAction`` structure accepts this enumeration as an
    /// initializer argument when the ``FromToByAction`` value is a ``Transform`` type.
    public enum TransformMode : Equatable, Codable {

        /// The provided transforms are relative to the bound entities parent transform.
        ///
        /// - Note: This is the usual space for entity transforms, and their animations to operate in.
        case parent

        /// The provided transforms are relative to the transform of the bound entity.
        case local

        /// The provided transform is relative to the scene, in world space.
        case scene

        /// The provided transforms are relative to the resolved entities transform.
        case relative(to: ActionEntityResolution)

        /// Default transform mode used by the specializations which use transform mode.
        public static var `default`: FromToByAction<Value>.TransformMode { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: FromToByAction<Value>.TransformMode, b: FromToByAction<Value>.TransformMode) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// A Boolean value that indicates whether the animation system additively blends the action's output with the base value.
    public var isAdditive: Bool

    /// Creates a new action that interpolates towards a specified final value.
    ///
    /// `from` → `to` or `defaultSource` → `to`
    ///
    /// - Parameters:
    ///    - from: Value set at the start of the animation, or `nil` to use the default source.
    ///    - to: Value set at the end of the animation.
    ///    - timing: Controls the progress of the animation.
    ///    - isAdditive: A Boolean value that indicates whether the animation system additively blends
    ///                  the action's output with the base value.
    public init(from: Value? = nil, to: Value, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false)

    /// Creates a new action that interpolates towards a specified value, which
    /// is relative to the starting value.
    ///
    /// `from` → `from + by` or `defaultSource` → `defaultSource + by`
    ///
    /// - Parameters:
    ///   - from: Value set at the start of the animation, or `nil` to use the default source.
    ///   - by: Value relative to the initial value to determine the final value.
    ///   - timing: Controls the progress of the animation.
    ///   - isAdditive: Specifies whether you can additively blend the output from the action's animation.
    public init(from: Value? = nil, by: Value, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false)

    /// Creates a new from to by action to animate
    /// from a specified value, towards the defaultSource value.
    ///
    /// `from` → `defaultSource`
    ///
    /// - Parameters:
    ///   - from: Value set at the start of the animation.
    ///   - timing: Controls the progress of the animation.
    ///   - isAdditive: Specifies whether you can additively blend the output from the action's animation.
    public init(from: Value, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false)

    /// Creates a new from to by action to animate towards a final value.
    /// The starting value is determined by adding the inverse of `by` to the
    /// specified final value.
    ///
    /// `to - by` → `to`
    ///
    /// - Parameters:
    ///   - to: Value set at the end of the animation.
    ///   - by: Value used to determine the starting value, relative to the end value.
    ///   - timing: Controls the progress of the animation.
    ///   - isAdditive: Specifies whether you can additively blend the output from the action's animation.
    public init(to: Value, by: Value, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false)

    /// Specifies whether you can play this action in reverse in order to undo prior operations.
    public let isReversible: Bool

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public let animatedValueType: (any AnimatableData.Type)?

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension FromToByAction where Value == Transform {

    /// Determines the entities transform ``FromToByAction/from`` and ``FromToByAction/to`` are relative to.
    ///
    /// - Note: The expection to this mode is `by`. This property is relative to the starting value,
    ///         Set this to `nil` if only `by` is specified.
    public var mode: FromToByAction<Transform>.TransformMode? { get }

    /// Creates a new action that interpolates towards a specified final transform.
    ///
    /// `defaultSource` → `to` or `defaultSource` → `to`
    ///
    /// - Parameters:
    ///   - from: Transform set at the start of the animation, or `nil` to use the default source.
    ///   - to: Transform set at the end of the animation.
    ///   - mode: Determines what space the transforms are relative to.
    ///   - timing: Controls the progress of the animation.
    ///   - isAdditive: Specifies whether you can additively blend the output from the action's animation.
    public init(from: Value? = nil, to: Value, mode: FromToByAction<Value>.TransformMode = .default, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false)

    /// Creates a new action that interpolates from a specified starting transform
    /// towards a specified transform, which is relative to the start. Alternatively, interpolates
    /// towards the default source if `by` is not supplied.
    ///
    /// `from` → `from + by` or `from` → `defaultSource`
    ///
    /// - Parameters:
    ///   - from: Transform set at the start of the animation.
    ///   - by: Transform which is used to increment the starting transform. Used to determine the final transform we animate towards.
    ///         Set this to `nil` to animate towards the defaultSource transform.
    ///   - mode: Determines what space the transforms are relative to.
    ///   - timing: Controls the progress of the animation.
    ///   - isAdditive: Specifies whether you can additively blend the output from the action's animation.
    public init(from: Value, by: Value? = nil, mode: FromToByAction<Value>.TransformMode = .default, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false)

    /// Creates a action to animate towards a final value.
    /// The starting value is determined by adding the inverse of `by` to the
    /// specified final value.
    ///
    /// `to - by` → `to`
    ///
    /// - Parameters:
    ///   - to: Value set at the end of the animation.
    ///   - by: Value used to determine the starting value, relative to the end value.
    ///   - mode: Determines what space the transforms are relative to.
    ///   - timing: Controls the progress of the animation.
    ///   - isAdditive: Specifies whether you can additively blend the output from the action's animation.
    public init(to: Value, by: Value, mode: FromToByAction<Value>.TransformMode = .default, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false)

    /// Creates a new action to animate from
    /// the deaultSource by a transform relative to the starting transform.
    ///
    /// `defaultSource` → `defaultSource + by`
    ///
    /// - Parameters:
    ///   - by: Transform which is used to increment the starting transform. Used to determine the final transform we animate towards.
    ///   - timing: Controls the progress of the animation.
    ///   - isAdditive: Specifies whether you can additively blend the output from the action's animation.
    public init(by: Value, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension FromToByAction {

    public enum DecodingErrors : Error {

        case unsupportedValueType

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: FromToByAction<Value>.DecodingErrors, b: FromToByAction<Value>.DecodingErrors) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new instance from a decoder.
    ///
    /// Throws an error if reading from `decoder` fails, or if the data is
    /// corrupted or otherwise invalid.
    ///
    /// - Parameters:
    ///   - decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Writes the action data into an encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container. This function throws an
    /// <doc://com.apple.documentation/documentation/swift/error> if any values
    /// are invalid for the given encoder’s format.
    ///
    /// - Parameters:
    ///   - encoder:  The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension FromToByAction.DecodingErrors : Equatable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension FromToByAction.DecodingErrors : Hashable {
}

/// An animation that starts, stops, or increments by a specific value.
///
/// To animate an entity or scene, this structure gradually changes a
/// parameter's value over time. You can specify a _from_ value, which
/// represents the animated property's initial value at the beginning of the
/// animation. You can also specify a _to_ value, which determines the value of
/// the property at the end of the animation. Alternatively, you can set a _by_
/// value. The framework adds the _by_ value to the property's initial state to
/// calculate the value at the end of the animation.
///
/// To specify the property that this struct animates, define `bindTarget` in
/// the intializer,
///
/// ``FromToByAnimation/init(name:from:to:by:duration:timing:isAdditive:bindTarget:blendLayer:repeatMode:fillMode:trimStart:trimEnd:trimDuration:offset:delay:speed:)``.
///
/// ### Configure the animation inputs
///
/// This animation supports varying input combinations, which exhibit the
/// following behavior. When you specify:
///
/// - term A _from_ and _to_ value: The animation interpolates between _from_
/// and _to_, and ignores the _by_ value.
/// - term A _from_ and _by_ value: The
/// animation interpolates between _from_ and the sum of _from_ and _by_.
/// - term Only a _from_ value: The animation interpolates between _from_ and the
/// default source value.
/// - term Only a _to_ value: The animation interpolates
/// between the default source value and _to_.
/// - term A _to_ and _by_ value: The
/// animation starts at _by_ subtracted from _to _and completes at _to_.
/// - term Only a _by_ value: The animation interpolates between the default source
/// value and the sum of default source value and _by_.
/// - term No _from_, _to_, or _by_ value: The animation interpolates between
/// the default source value and the default target value.
///
/// The default source value is the base value of the of animated property. If
/// multiple animations target the property, then the framework observes the
/// output of the previous animation as the subsequent animation's default
/// source value. The default target value is the base value of the animated
/// property.
@available(macOS 12.0, iOS 15.0, *)
public struct FromToByAnimation<Value> : AnimationDefinition where Value : AnimatableData {

    /// A textual name for the animation.
    public var name: String

    /// The order in which the framework composites the animation.
    ///
    /// The framework applies multiple animations on the same target in
    /// ascending order of this property’s value. Animations in a lower layer
    /// run before animations in a higher layer. Animations that share the same
    /// value apply in the order that they execute.
    public var blendLayer: Int32

    /// A textual name that identifies the particular property that animates.
    ///
    /// The property name is a key path. For more information on key paths, see
    /// <doc://com.apple.documentation/documentation/swift/swift_standard_library/key-path_expressions>.
    public var bindTarget: BindTarget

    /// An option that determines which data displays outside of the normal
    /// duration.
    ///
    /// This property determines what to display when the framework samples the
    /// animation outside of the range defined by its underlying duration. The
    /// animation applies this property when:
    ///
    /// - Playback progresses toward, but hasn't yet reached, a nonzero
    /// ``AnimationDefinition/offset``. - A range determined by
    /// ``AnimationDefinition/trimStart``, ``AnimationDefinition/trimEnd``, or
    /// ``AnimationDefinition/trimDuration`` exceeds the animation's underlying
    /// duration.
    public var fillMode: AnimationFillMode

    /// A Boolean value that indicates whether the animation blends additively
    /// with concurrent animations.
    public var isAdditive: Bool

    /// An option that determines the animation’s pace over time.
    ///
    /// Depending on the option you pick, the animation's progress moves at
    /// varying speeds along its duration.
    public var timing: AnimationTimingFunction

    /// The time, in seconds, at which the animation plays.
    ///
    /// This property is `nil` by default, which plays the animation with `time`
    /// = `0`. If you set a value, the animation edits the duration according to
    /// the specified beginning time.
    ///
    /// If you set a negative value for this property, the duration increases
    /// and the additional animation data fills in based on the
    /// ``FromToByAnimation/fillMode`` you choose.
    public var trimStart: TimeInterval?

    /// The time, in seconds, at which the animation stops.
    ///
    /// This property is `nil` by default, which plays the animation until
    /// `time` = ``FromToByAnimation/duration``. If you set a value, the
    /// animation edits the duration according to the specified ending time.
    public var trimEnd: TimeInterval?

    /// An optional duration that overrides the calculated duration.
    ///
    /// The framework calculates ``FromToByAnimation/duration``, but you can set
    /// this property to override it. This property is `nil` by default, which
    /// indicates that the animation stops after one play that spans
    /// ``FromToByAnimation/duration``.
    ///
    /// If you set a value for this property and both
    /// ``FromToByAnimation/trimStart`` and ``FromToByAnimation/trimEnd`` are
    /// `nil`, the animation observes this property as an edited duration.
    ///
    /// A value greater than ``FromToByAnimation/duration`` causes the animation
    /// to repeat, applying the characteristics defined by
    /// ``FromToByAnimation/repeatMode``. Assign this property
    /// <doc://com.apple.documentation/documentation/swift/double/1849607-greatestfinitemagnitude>
    /// to repeat indefinitely.
    public var trimDuration: TimeInterval?

    /// The time, in seconds, at which the animation begins within the duration.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no offset.
    ///
    /// If you set a value for this property, the animation plays immediately,
    /// beginning at the specified time.
    public var offset: TimeInterval

    /// An amount of time that elapses before the animation plays.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no delay. If you set a value for this property, the animation plays from
    /// its start time after the specified delay lapses.
    ///
    /// During the delayed time, the animation doesn't update. However, to fill
    /// the delayed time with some portion of animation, set a negative
    /// ``FromToByAnimation/trimStart`` instead and choose a
    /// ``FromToByAnimation/fillMode`` that displays the desired portion of
    /// animation.
    public var delay: TimeInterval

    /// A factor that increases or decreases the animation’s rate of playback.
    ///
    /// The default value is `1.0`, which doesn’t alter the animation’s
    /// duration. A value of `2.0` indicates that the duration is half the
    /// normal rate. A value of `0.5` indicates that the duration is twice the
    /// normal rate. Negative values play the animation in reverse.
    ///
    /// This property doesn’t affect the animation’s
    /// ``FromToByAnimation/delay``.
    public var speed: Float

    /// An option that determines how the animation repeats.
    ///
    /// If you call ``FromToByAnimation/trimmed(start:end:duration:)`` with a
    /// `start` or `end` that lies outside of the timeline defined by
    /// ``FromToByAnimation/duration``, the animation fills the additional
    /// playback by applying this property.
    public var repeatMode: AnimationRepeatMode

    /// The total playback time of the animation.
    ///
    /// The framework sets a value for this property depending on the underlying
    /// animation data and the specified ``AnimationView/speed``.
    ///
    /// You can override the default duration by defining
    /// ``FromToByAnimation/trimStart``, ``FromToByAnimation/trimEnd``, or
    /// ``FromToByAnimation/trimDuration``.
    public var duration: TimeInterval

    /// Creates an animation that interpolates between two values for a property
    /// of the target entity.
    ///
    /// - Parameters:
    ///   - name: A unique name for the animation.
    ///
    ///   - from: The state of the animated property before the animation starts.
    ///
    ///   - to: The state of the animated property after the animation ends.
    ///
    ///   - by: An amount that increments the animated property during the animation.
    ///
    ///   - duration: The total playback time.
    ///
    ///   - timing: An option that determines the animation’s pace over time.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     blends additively with concurrent animations.
    ///
    ///   - bindTarget: A textual name that identifies the particular property
    ///     that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation
    ///     into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - trimStart: The time, in seconds, at which the animation plays.
    ///
    ///   - trimEnd: The time, in seconds, at which the animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that elapses before the animation plays.
    ///
    ///   - speed: A factor that increases or decreases the animation’s rate of playback.
    public init(name: String = "", from: Value? = nil, to: Value? = nil, by: Value? = nil, duration: TimeInterval = 1.0, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false, bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)
}

@available(macOS 12.0, iOS 15.0, *)
extension FromToByAnimation where Value == Float {

    public var fromValue: Float?

    public var toValue: Float?

    public var byValue: Float?
}

@available(macOS 12.0, iOS 15.0, *)
extension FromToByAnimation where Value == Double {

    public var fromValue: Double?

    public var toValue: Double?

    public var byValue: Double?
}

@available(macOS 12.0, iOS 15.0, *)
extension FromToByAnimation where Value == SIMD2<Float> {

    public var fromValue: SIMD2<Float>?

    public var toValue: SIMD2<Float>?

    public var byValue: SIMD2<Float>?
}

@available(macOS 12.0, iOS 15.0, *)
extension FromToByAnimation where Value == SIMD3<Float> {

    public var fromValue: SIMD3<Float>?

    public var toValue: SIMD3<Float>?

    public var byValue: SIMD3<Float>?
}

@available(macOS 12.0, iOS 15.0, *)
extension FromToByAnimation where Value == SIMD4<Float> {

    public var fromValue: SIMD4<Float>?

    public var toValue: SIMD4<Float>?

    public var byValue: SIMD4<Float>?
}

@available(macOS 12.0, iOS 15.0, *)
extension FromToByAnimation where Value == simd_quatf {

    public var fromValue: simd_quatf?

    public var toValue: simd_quatf?

    public var byValue: simd_quatf?
}

@available(macOS 12.0, iOS 15.0, *)
extension FromToByAnimation where Value == Transform {

    public var fromValue: Transform?

    public var toValue: Transform?

    public var byValue: Transform?
}

@available(macOS 12.0, iOS 15.0, *)
extension FromToByAnimation where Value == JointTransforms {

    /// Joint names that define the joints in the skeletal pose.
    public var jointNames: [String]

    public var fromValue: JointTransforms?

    public var toValue: JointTransforms?

    public var byValue: JointTransforms?

    /// A Boolean value that indicates whether that animation interpolates
    /// changes to the target’s size.
    public var isScaleAnimated: Bool

    /// A Boolean value that indicates whether the animation interpolates
    /// rotational changes.
    public var isRotationAnimated: Bool

    /// A Boolean value that indicates whether the animation interpolates
    /// changes to the target object’s position.
    public var isTranslationAnimated: Bool

    /// Creates an animation that interpolates between two configurations of the
    /// given joints.
    ///
    /// - Parameters:
    ///   - jointNames: The names of the joints in the animated skeletal pose.
    ///
    ///   - name: A unique name for the animation.
    ///
    ///   - isScaleAnimated: A Boolean value that indicates whether that animation
    ///     interpolates changes to the target’s size.
    ///
    ///   - isRotationAnimated: A Boolean value that indicates whether that
    ///     animation interpolates rotational changes.
    ///
    ///   - isTranslationAnimated: A Boolean value that indicates whether that
    ///     animation interpolates changes to the target object’s position.
    ///
    ///   - from: The state of the target object’s joints before the animation starts.
    ///
    ///   - to: The state of the target object’s joints after the animation finishes.
    ///
    ///   - by: An amount that increments the animated joints during the animation.
    ///
    ///   - duration: The total playback time.
    ///
    ///   - timing: An option that determines the animation’s pace over time.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     blends additively with concurrent animations.
    ///
    ///   - bindTarget: A textual name that identifies the particular property that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - trimStart: The optional time, in seconds, at which the animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that elapses before the animation plays.
    ///
    ///   - speed: A factor that increases or decreases the animation’s rate of playback.
    public init(jointNames: [String], name: String = "", isScaleAnimated: Bool = true, isRotationAnimated: Bool = true, isTranslationAnimated: Bool = true, from: Value? = nil, to: Value? = nil, by: Value? = nil, duration: TimeInterval = 1.0, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false, bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension FromToByAnimation where Value == BlendShapeWeights {

    /// Weight names that define the weights for the blend shape.
    public var weightNames: [String]

    public var fromValue: BlendShapeWeights?

    public var toValue: BlendShapeWeights?

    public var byValue: BlendShapeWeights?

    /// Creates an animation that blends between a configuration of blend targets.
    ///
    /// - Parameters:
    ///   - weightNames: The names of the weights in the animated blend shape.
    ///
    ///   - name: A unique name for the animation.
    ///
    ///   - from: The state of the target object’s weights before the animation starts.
    ///
    ///   - to: The state of the target object’s weights after the animation finishes.
    ///
    ///   - by: An amount that increments the animated weights during the animation.
    ///
    ///   - duration: The total playback time.
    ///
    ///   - timing: An option that determines the animation’s pace over time.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     blends additively with concurrent animations.
    ///
    ///   - bindTarget: A textual name that identifies the particular property that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation
    ///     into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - trimStart: The optional time, in seconds, at which the animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that elapses before the animation plays.
    ///
    ///   - speed: A factor that increases or decreases the animation’s rate of playback.
    public init(weightNames: [String], name: String = "", from: Value? = nil, to: Value? = nil, by: Value? = nil, duration: TimeInterval = 1.0, timing: AnimationTimingFunction = .linear, isAdditive: Bool = false, bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)
}

/// A structure that identifies a local transform relative to an entity or entity's animating skeletal joint.
///
/// A geometric pin has a base transform and allows an optional offset relative to the base transform.
/// The base transform is only available when the pin attaches to an entity.
/// When a geometric pin does not attach to any entity (i.e. `GeometricPin/entity` is `nil`),
/// the pin is just a floating local transform relative to some space to be defined.
/// The pin's query function such as
/// `GeometricPin/position` or `GeometricPin/orientation` returns the local offset in this case.
///
/// After a geometric pin has attached to an entity, or `GeometricPin/entity` is not `nil`, the base transform may be available.
/// If you construct a geometric pin with a generic name, the base transform resolves to the transform of the pin's owning entity.
/// If you construct a geometric pin with a skeletal joint name, the base transform resolves to the current transform
/// of the skeletal joint with the matching joint name.
/// When the base transform is available, the pin's query function such as `GeometricPin/position` or `GeometricPin/orientation` returns the base transform with the offset applied.
///
/// You can attach a pin to an entity by creating a `GeometricPin`, adding it to a ``GeometricPinsComponent``, and finally setting
/// the ``GeometricPinsComponent`` to an `Entity`.
///
/// ```swift
/// let pin = GeometricPin(named: "genericPin")
/// let skeletalJointPin = GeometricPin(named: "animatingPin", skeletalJointName: "hand")
/// var pinsComponent = GeometricPinsComponent()
/// pinsComponent.set(pin)
/// pinsComponent.set(skeletalJointPin)
/// let entity = Entity()
/// entity.components.set(pinsComponent)
/// ```
///
/// Another way to attach a pin is to add the `GeometricPin` to the ``Entity/pins`` collection directly.
///
/// ```swift
/// let entity = Entity()
/// let pin = entity.pins.set(named: "genericPin")
/// let skeletalJointPin = entity.pins.set(named: "animatingPin", skeletalJointName: "hand")
/// ```
///
/// Note that when adding a geometric pin the API does not validate the skeletal joint name. The validation only happens
/// when the base transform is evaluating, for example during the call to `GeometricPin/position` or `GeometricPin/orientation`.
/// If the skeletal joint name does not match any valid skeletal joint, those query functions return `nil`.
///
/// Each geometric pin has a unique name to identify itself from other pins on an entity.
/// You can use the subscript operator to retrieve a pin.
///
/// ```swift
/// // To retrieve the skeletal joint pin in the previous snippet:
/// let retrievedPin = pinsComponent["animatingPin"]
/// ```
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct GeometricPin : Hashable {

    /// Creates a geometric pin that identifies a local position and orientation.
    ///
    /// - Parameters:
    ///    - name: Name of the `GeometricPin` in the namespace of the owning entity.
    ///    - offsetPosition: Adjustment of the `GeometricPin` position in the local coordinate frame.
    ///    - offsetOrientation: Adjustment of the `GeometricPin` orientation in the local coordinate frame.
    public init(named name: String, offsetPosition: SIMD3<Float> = SIMD3<Float>(0, 0, 0), offsetOrientation: simd_quatf = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1))

    /// Creates a geometric pin that attaches to a skeletal joint.
    ///
    /// The current animated joint transform defines the position and orientation of the pin.
    ///
    /// - Parameters:
    ///    - name: Name of the `GeometricPin` in the namespace of the owning entity.
    ///    - skeletalJointName: Name of the skeletal joint that this pin attaches to.
    ///    - offsetPosition: Adjustment of the `GeometricPin` position in the coordinate frame of the joint.
    ///    - offsetOrientation: Adjustment of the `GeometricPin` orientation in the coordinate frame of the joint.
    public init(named name: String, skeletalJointName: String, offsetPosition: SIMD3<Float> = SIMD3<Float>(0, 0, 0), offsetOrientation: simd_quatf = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1))

    /// Calculates and returns the current position of the pin relative to the pin's owning entity, adjusted by the optional offset position.
    ///
    /// If the pin is on a skeletal joint but there is no skeletal joint matching the given skeletal joint name, this property returns `nil`.
    @MainActor public var position: SIMD3<Float>? { get }

    /// Calculates and returns the current orientation of the pin relative to the pin's owning entity, adjusted by the optional offset orientation.
    ///
    /// If the pin is on a skeletal joint but there is no skeletal joint matching the given skeletal joint name, this property returns `nil`.
    @MainActor public var orientation: simd_quatf? { get }

    /// Calculates and returns the current position of the pin relative to a reference entity, adjusted by the optional offset position.
    ///
    /// - Parameter referenceEntity: Reference `Entity` which defines the frame of reference for the returned position.
    ///                              Can be `nil`, which is equivalent to "world space".
    @MainActor public func position(relativeTo referenceEntity: Entity?) -> SIMD3<Float>?

    /// Calculates and returns the current orientation of the pin relative to a reference entity, adjusted by the optional offset position.
    ///
    /// - Parameter referenceEntity: Reference `Entity` which defines the frame of reference for the returned orientation.
    ///                              Can be `nil`, which is equivalent to "world space".
    @MainActor public func orientation(relativeTo referenceEntity: Entity?) -> simd_quatf?

    /// The entity where the local frame lives.
    weak public var entity: Entity? { get }

    /// The name of the pin.
    ///
    /// Each ``GeometricPins`` for an``Entity``
    /// have unique names. Adding a pin with the same name as another
    /// overrides the duplicate.
    public var name: String

    /// Offset from the pin's base position.
    ///
    /// If a pin has a generic name, this offset is relative to the pin's owning entity's position.
    /// If a pin is on a skeletal joint, this offset is relative to the skeletal joint's current position.
    /// By default this offset is the zero position vector.
    public var offsetPosition: SIMD3<Float>

    /// Offset from the pin's base orientation.
    ///
    /// If a pin has a generic name, this offset is relative to the pin's owning entity's orientation.
    /// If a pin is on a skeletal joint, this offset is relative to the skeletal joint's current orientation.
    /// By default this offset is the identity rotation.
    public var offsetOrientation: simd_quatf

    /// Returns a Boolean that indicates whether the pins are equal.
    /// - Parameters:
    ///   - lhs: A pin to compare.
    ///   - rhs: Another pin to compare.
    public static func == (lhs: GeometricPin, rhs: GeometricPin) -> Bool

    /// Hashes the essential components of the pin by feeding them into the
    /// hash function.
    ///
    /// - Parameters:
    ///   - hasher: The hash function to use when combining the components of the
    ///     pin.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A component that stores a sequence of geometric pins.
///
/// Add, inspect, and remove geometric pins that belong to the entity that owns
/// an instance of `GeometricPinsComponent` by accessing its
/// ``Entity/pins`` property.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct GeometricPinsComponent : Component {

    /// Creates a geometric pins component with an empty sequence of pins.
    public init()

    /// The sequence of geometric pins the component owns.
    public var pins: Set<GeometricPin> { get }

    /// Retrieves the pin by its name.
    ///
    /// - Parameter name: The name of the pin to look up.
    public subscript(name: String) -> GeometricPin? { get }

    /// Removes the pin associated with the name.
    ///
    /// - Parameter name: The name of the pin to remove.
    @discardableResult
    public mutating func removePin(named name: String) -> GeometricPin?

    /// Adds a pin to the collection.
    ///
    /// If the pin's name already exists in the collection, the new value replaces the existing one.
    /// - Parameter geometricPin: The pin to add or update.
    public mutating func set(pin: GeometricPin)
}

/// A component that controls an entity's grounding shadow.
///
/// A grounding shadow is an effect that makes an entity look like it has a light source directly above it. You can add a grounding shadow to any entity that has a
/// ``ModelComponent`` in its component set by adding a grounding shadow
/// component to the entity's ``Entity/components`` property.
///
/// ```swift
/// if let model = try? await ModelEntity(named: "tv_retro") {
///     let shadowComponent = GroundingShadowComponent(castsShadow: true)
///     model.components.set(shadowComponent)
/// }
/// ```
///
/// | Without shadow | With shadow |
/// |:-:|:-:|
/// | ![A screenshot of a vintage-style TV near the floor of a kitchen scene, which doesn't cast a shadow onto the floor.](groundingshadowcomponent-tv-off) | ![A screenshot of a vintage-style TV near the floor of a kitchen scene, which casts a shadow onto the floor.](groundingshadowcomponent-tv-on) |
///
/// You need to add the grounding shadow component to each entity you want to
/// apply the effect to, because the grounding shadow component doesn't apply to
/// hierarchies.
///
/// - Note: Neither virtual nor physical light sources affect grounding shadows.
///
/// ### Receiving Shadows
///
/// By default, all entity models with a grounding shadow component can cast
/// a shadow onto any other model entities in the scene.
/// However, you can configure an entity to opt out of receiving shadows from
/// other entities by setting a grounding shadow component's ``GroundingShadowComponent/receivesShadow`` property to `false` and adding
/// that component to the entity that's opting out.
///
/// ```swift
/// let tvShadow = GroundingShadowComponent(castsShadow: true)
/// tvShadow.receivesShadow = false
/// tv.components.set(tvShadow)
/// ```
///
/// Alternatively, you can create a new grounding shadow component instance that
/// opts out of receiving shadows by passing `false` to the `receivesShadow`
/// parameter of the
/// ``GroundingShadowComponent/init(castsShadow:receivesShadow:)`` initializer.
///
/// ```swift
/// let robotShadow = GroundingShadowComponent(castsShadow: true,
///                                            receivesShadow: false)
/// robot.components.set(robotShadow)
/// ```
///
/// | Receiving shadows | Not receiving shadows |
/// |:-:|:-:|
/// | ![A screenshot of a vintage toy robot on a vintage TV set in a RealityKit scene where the robot casts a shadow onto both the TV that it's standing on, and onto own body.](groundingshadowcomponent-tv-robot-receive-on) | ![A screenshot of a vintage toy robot on a vintage TV set in a RealityKit scene where the robot doesn't cast a shadow on any entity in the scene, including itself.](groundingshadowcomponent-tv-robot-receive-off)
///
/// RealityKit generates grounding shadows from the perspective of another
/// entity that receives the first entity's shadow. One-sided geometry only
/// casts a shadow if its facets face the entity that receives the shadow,
/// which typically means they face downward. Make each 2D object cast a
/// grounding shadow by applying a material that disables face culling, or by
/// replacing it with a watertight mesh.
@available(visionOS 1.0, iOS 18.0, macOS 15.0, *)
public struct GroundingShadowComponent : Component {

    /// A Boolean value that indicates whether an entity casts a shadow onto
    /// other model entities in the scene.
    public var castsShadow: Bool

    /// Creates a grounding shadow component.
    ///
    /// - Parameter castsShadow: A Boolean that indicates whether an entity
    /// with the component casts a shadow onto other model entities in the scene.
    ///
    /// By default, the component makes an entity receive grounding shadows from
    /// other model entities in the scene.
    public init(castsShadow: Bool)
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension GroundingShadowComponent {

    /// A Boolean value that indicates whether an entity with the grounding
    /// shadow component receives grounding shadows from other model entities.
    public var receivesShadow: Bool

    /// Creates a grounding shadow component by configuring whether its entity
    /// receives shadows from other model entities with the component.
    ///
    /// - Parameters:
    ///    - castsShadow: A Boolean value that indicates whether the component's
    ///    entity casts a shadow on the environment and other model entities.
    ///    - receivesShadow: A Boolean value that indicates whether the
    ///    component's entity receives shadows from other model entities.
    ///
    /// This initializer is an alternative to ``init(castsShadow:)``, which
    /// creates a component that, by default, configures an entity to receive
    /// grounding shadows from other model entities in the scene.
    public init(castsShadow: Bool, receivesShadow: Bool)
}

@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
extension GroundingShadowComponent {

    /// Describes the behavior of an entity's grounding shadow when it's near
    /// physical objects.
    public enum FadeBehaviorNearPhysicalObjects {

        /// The default grounding shadow behavior for the device's platform.
        ///
        /// In visionOS, the default case is equivalent to ``fade`` when the
        /// the system can detect the entity represents a UI; otherwise,``constant``.
        ///
        /// In iOS, the default case is equivalent to ``constant``.
        case `default`

        /// A grounding shadow behavior that fades when an entity is near
        /// physical objects.
        ///
        /// On iOS devices without LiDAR, the option is equivalent to ``constant``.
        case fade

        /// A grounding shadow behavior that doesn't fade when an entity is near
        /// physical objects.
        case constant

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: GroundingShadowComponent.FadeBehaviorNearPhysicalObjects, b: GroundingShadowComponent.FadeBehaviorNearPhysicalObjects) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Configures the grounding shadow's fade behavior when the entity is near
    /// physical objects.
    public var fadeBehaviorNearPhysicalObjects: GroundingShadowComponent.FadeBehaviorNearPhysicalObjects

    /// Creates a grounding shadow component by configuring whether its entity
    /// receives shadows and its fade behavior near physical objects.
    ///
    /// - Parameters:
    ///    - castsShadow: A Boolean value that indicates whether the component's
    ///    entity casts a shadow on the environment and other model entities.
    ///    - receivesShadow: A Boolean value that indicates whether the
    ///    component's entity receives shadows from other model entities.
    ///    - fadeBehaviorNearPhysicalObjects: A fade behavior for the entity's
    ///    shadow when the entity is near physical objects.
    public init(castsShadow: Bool, receivesShadow: Bool, fadeBehaviorNearPhysicalObjects: GroundingShadowComponent.FadeBehaviorNearPhysicalObjects)
}

@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
extension GroundingShadowComponent.FadeBehaviorNearPhysicalObjects : Equatable {
}

@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
extension GroundingShadowComponent.FadeBehaviorNearPhysicalObjects : Hashable {
}

/// An interface that enables anchoring of virtual content to a real-world
/// object in an AR scene.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasAnchoring : Entity {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasAnchoring {

    /// The component that describes how the virtual content is anchored to the
    /// real world.
    @available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
    @MainActor @preconcurrency public var anchoring: AnchoringComponent

    /// The identifier of the AR anchor with which the anchor entity is
    /// associated, or `nil` if it isn’t currently anchored.
    @available(visionOS, deprecated, message: "Anchor Identifier is not supported on xrOS")
    @MainActor @preconcurrency public var anchorIdentifier: UUID? { get }

    /// Changes the entity’s anchoring, preserving either the world transform or
    /// the local transform.
    ///
    /// - Parameters:
    ///   - target: Describes how the entity should be anchored in AR.
    ///
    ///   - preservingWorldTransform: A Boolean you set to `true` to preserve the
    ///     current world space position, or `false` to use the position relative to
    ///     the previous anchor for the new anchor.
    @available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
    @available(visionOS, deprecated, message: "reanchor(:preservingWorldTransform:) is not supported on xrOS")
    @MainActor @preconcurrency public func reanchor(_ target: AnchoringComponent.Target, preservingWorldTransform: Bool = true)
}

/// An interface used for ray casting and collision detection.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasCollision : HasTransform {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasCollision {

    /// The collision component that gives the entity the ability to participate
    /// in collision simulations.
    @MainActor @preconcurrency public var collision: CollisionComponent?
}

/// An interface that defines a directional light source component.
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
@MainActor @preconcurrency public protocol HasDirectionalLight : HasTransform {
}

@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
extension HasDirectionalLight {

    /// A directional light component for the entity.
    @MainActor @preconcurrency public var light: DirectionalLightComponent

    /// The shadow settings for a directional light.
    ///
    /// Set this value to `nil` to remove shadows.
    @MainActor @preconcurrency public var shadow: DirectionalLightComponent.Shadow?
}

/// An interface that provides access to a parent entity and child entities.
///
/// All entities automatically adopt this protocol because the ``Entity`` base
/// class does. This adoption gives all entities a collection of methods for
/// managing the hierarchy.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasHierarchy : Entity {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasHierarchy {

    /// The parent entity.
    ///
    /// An entity has at most one parent entity. If an entity isn’t part of a
    /// hierarchy, or if it is a root entity, the ``HasHierarchy/parent``
    /// property is `nil`.
    ///
    /// Use the ``HasHierarchy/setParent(_:preservingWorldTransform:)`` method
    /// to change an entity’s parent. Use the
    /// ``HasHierarchy/removeFromParent(preservingWorldTransform:)`` method to
    /// remove the parent. These methods automatically update the corresponding
    /// ``HasHierarchy/children`` collections of the new and old parent.
    @MainActor @preconcurrency public var parent: Entity? { get }

    /// Attaches the entity as a child to the specified entity.
    ///
    /// Attaching an entity to a new parent automatically detaches it from its
    /// old parent.
    ///
    /// The ``HasHierarchy/children`` collections of both the old and new parent
    /// are automatically updated as well.
    ///
    /// - Parameters:
    ///   - parent: The new parent entity. Use `nil` to detach the entity from its
    ///     current parent.
    ///
    ///   - preservingWorldTransform: A Boolean that you set to `true` to preserve
    ///     the entity’s world transform, or `false` to preserve its relative
    ///     transform. Use `true` when you want a model to keep its effective
    ///     location and size within a scene.
    ///
    /// > Important: On visionOS, only use `preservingWorldTransform` when
    /// > moving an entity within the same `AnchorEntity`, `ImmersiveSpace` or
    /// > SwiftUI `WindowGroup` hierarchy. Moving entities across these
    /// > hierarchy boundaries while `preservingWorldTransform` is set to
    /// > `true`, is not supported.
    @MainActor @preconcurrency public func setParent(_ parent: Entity?, preservingWorldTransform: Bool = false)

    /// The child entities that the entity manages.
    ///
    /// An entity can have any number of child entities.
    ///
    /// Use the ``HasHierarchy/addChild(_:preservingWorldTransform:)`` method to
    /// add a child to an entity. Use the
    /// ``HasHierarchy/removeChild(_:preservingWorldTransform:)`` method to
    /// remove one from an entity. These methods automatically update the
    /// ``HasHierarchy/parent`` properties of the child entities.
    @MainActor @preconcurrency public var children: Entity.ChildCollection

    /// Adds the given entity to the collection of child entities.
    ///
    /// See the ``HasHierarchy`` protocol’s definition of
    /// ``HasHierarchy/addChild(_:preservingWorldTransform:)`` for more
    /// information.
    ///
    /// - Parameters:
    ///   - entity:
    ///
    ///   - preservingWorldTransform: A Boolean that you set to `true` to preserve
    ///     the entity’s world transform, or `false` to preserve its relative
    ///     transform. Use `true` when you want a model to keep its effective
    ///     location and size within a scene.
    @MainActor @preconcurrency public func addChild(_ entity: Entity, preservingWorldTransform: Bool = false)

    /// Removes the given child from the entity.
    ///
    /// See the ``HasHierarchy`` protocol’s definition of
    /// ``HasHierarchy/removeChild(_:preservingWorldTransform:)`` for more
    /// information.
    ///
    /// - Parameters:
    ///   - entity:
    ///
    ///   - preservingWorldTransform: A Boolean that you set to `true` to preserve
    ///     the entity’s world transform, or `false` to preserve its relative
    ///     transform. Use `true` when you want a model to keep its effective
    ///     location and size within a scene.
    @MainActor @preconcurrency public func removeChild(_ entity: Entity, preservingWorldTransform: Bool = false)

    /// Removes the entity from its current parent or from the scene if it is a
    /// root entity.
    ///
    /// This method behaves like the
    /// ``HasHierarchy/setParent(_:preservingWorldTransform:)`` method with a
    /// value of `nil` for the `parent` parameter, except that method has no
    /// effect on root entities. A root entity is one that is stored in a
    /// scene’s ``Scene/anchors`` collection.
    ///
    /// The ``HasHierarchy/children`` collections of any modified parent
    /// entities are automatically updated as well.
    ///
    /// - Parameters:
    ///   - preservingWorldTransform: A Boolean that you set to `true` to preserve
    ///     the entity’s world transform, or `false` to preserve its relative
    ///     transform. Use `true` when you want a model to keep its effective
    ///     location and size within a scene.
    @MainActor @preconcurrency public func removeFromParent(preservingWorldTransform: Bool = false)
}

/// An interface that provides meshes and materials to define the visual
/// appearance of an entity.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasModel : HasTransform {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasModel {

    /// The model component for the entity.
    @MainActor @preconcurrency public var model: ModelComponent?

    /// Configures the debug visualization of this model.
    @available(macOS 11.0, iOS 14.0, *)
    @MainActor @preconcurrency public var modelDebugOptions: ModelDebugOptionsComponent?
}

@available(macOS 10.15, iOS 13.0, *)
extension HasModel {

    /// The names of all the joints in the model entity.
    @MainActor @preconcurrency public var jointNames: [String] { get }

    /// The relative joint transforms of the model entity.
    ///
    /// Call ``RealityKit/BodyTrackedEntity/jointNames`` to determine the name and order of the joints.
    ///
    /// - Note: Active animations may override the joint transforms set using this property.
    @MainActor @preconcurrency public var jointTransforms: [Transform]
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension HasModel {

    /// The blend shape weights in the model entity.
    @MainActor @preconcurrency public var blendWeights: [[Float]]

    /// The names of the weights on each blend shape in the model entity.
    @MainActor @preconcurrency public var blendWeightNames: [[String]] { get }
}

/// An interface that enables you to configure a virtual camera that you can use
/// to define the rendering perspective when you’re not in an AR session.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasPerspectiveCamera : HasTransform {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasPerspectiveCamera {

    /// A camera component for the perspective camera entity.
    @MainActor @preconcurrency public var camera: PerspectiveCameraComponent
}

/// An interface that combines the physics body and physics motion interfaces.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasPhysics : HasPhysicsBody, HasPhysicsMotion {
}

/// An interface that enables physics simulations based on the rules of
/// Newtonian mechanics.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasPhysicsBody : HasCollision {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasPhysicsBody {

    /// Applies a force to the physics body at its center of mass.
    ///
    /// The physics simulator applies the added force until the end of the frame
    /// interval. To continue exerting the force after that time, add the force
    /// again with another call to the method. Handle the ``SceneEvents/Update``
    /// event to receive an indication of when the frame interval ends. For an
    /// app that renders at 60 frames per second (fps), this event occurs about
    /// once per 16 milliseconds.
    ///
    /// - Parameters:
    ///   - force: A force in newtons.
    ///
    ///   - referenceEntity: The reference entity that defines the coordinate
    ///     space in which `force` is defined.
    @MainActor @preconcurrency public func addForce(_ force: SIMD3<Float>, relativeTo referenceEntity: Entity?)

    /// Applies a force to the physics body at the specified position.
    ///
    /// The physics simulator applies the added force until the end of the frame
    /// interval. To continue exerting the force after that time, add the force
    /// again with another call to the method. Handle the ``SceneEvents/Update``
    /// event to receive an indication of when the frame interval ends. For an
    /// app that renders at 60 frames per second (fps), this event occurs about
    /// once per 16 milliseconds.
    ///
    /// - Parameters:
    ///   - force: A force in newtons.
    ///
    ///   - position: The position at which to apply the force.
    ///
    ///   - referenceEntity: The reference entity that defines the coordinate
    ///     space in which `position` and `force` are defined.
    @MainActor @preconcurrency public func addForce(_ force: SIMD3<Float>, at position: SIMD3<Float>, relativeTo referenceEntity: Entity?)

    /// Applies a torque to the physics body at its center of mass.
    ///
    /// The physics simulator applies the added torque until the end of the
    /// frame interval. To continue exerting the torque after that time, add the
    /// torque again with another call to the method. Handle the
    /// ``SceneEvents/Update`` event to receive an indication of when the frame
    /// interval ends. For an app that renders at 60 frames per second (fps),
    /// this event occurs about once per 16 milliseconds.
    ///
    /// - Parameters:
    ///   - torque: A torque in newton meters per radian.
    ///
    ///   - referenceEntity: The reference entity that defines the coordinate
    ///     space in which `torque` is defined.
    @MainActor @preconcurrency public func addTorque(_ torque: SIMD3<Float>, relativeTo referenceEntity: Entity?)

    /// Clears all forces previously added to the physics body.
    @MainActor @preconcurrency public func clearForcesAndTorques()

    /// Applies an impulse to the physics body at its center of mass.
    ///
    /// - Parameters:
    ///   - impulse: An impulse in newton seconds.
    ///
    ///   - referenceEntity: The reference entity that defines the coordinate
    ///     space in which `impulse` is defined.
    @MainActor @preconcurrency public func applyLinearImpulse(_ impulse: SIMD3<Float>, relativeTo referenceEntity: Entity?)

    /// Applies an angular (torque) impulse to the physics body at its center of
    /// mass.
    ///
    /// - Parameters:
    ///   - impulse: An angular impulse in kilogram square meters per second.
    ///
    ///   - referenceEntity: The reference entity that defines the coordinate
    ///     space in which `impulse` is defined.
    @MainActor @preconcurrency public func applyAngularImpulse(_ impulse: SIMD3<Float>, relativeTo referenceEntity: Entity?)

    /// Applies an impulse to the physics body at the specified position.
    ///
    /// - Parameters:
    ///   - impulse: An impulse in newton seconds.
    ///
    ///   - position: The position at which to apply the impulse.
    ///
    ///   - referenceEntity: The reference entity that defines the coordinate
    ///     space in which `position` and `impulse` are defined.
    @MainActor @preconcurrency public func applyImpulse(_ impulse: SIMD3<Float>, at position: SIMD3<Float>, relativeTo referenceEntity: Entity?)
}

@available(macOS 10.15, iOS 13.0, *)
extension HasPhysicsBody {

    /// A component that is used for physics simulations of the model entity in
    /// accordance with the laws of Newtonian mechanics.
    @MainActor @preconcurrency public var physicsBody: PhysicsBodyComponent?
}

@available(macOS 10.15, iOS 13.0, *)
extension HasPhysicsBody {

    /// Resets the position and velocities of the simulated physics body.
    ///
    /// Call this method to change the transform applied to a body by physics
    /// simulation. This only matters for dynamic rigid bodies, with a
    /// ``PhysicsBodyComponent/mode`` of ``PhysicsBodyMode/dynamic``. This is
    /// the only kind of body that’s affected by physics simulations. For all
    /// others, modify the entity’s ``HasTransform/transform`` property
    /// directly.
    ///
    /// Conversely, directly modifying the transform of a dynamic body has no
    /// effect because the physics simulation overwrites it on every frame.
    ///
    /// - Parameters:
    ///   - transform: The new transform to inject into the dynamic physics
    ///     simulation of the entity.
    ///
    ///   - recursive: Apply the reset to child entities.
    @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
    @MainActor @preconcurrency public func resetPhysicsTransform(_ transform: Transform, recursive: Bool = true)

    /// Resets the position, orientation, and velocities of the simulated
    /// physics body.
    ///
    /// Call this method only for dynamic rigid bodies, with a
    /// ``PhysicsBodyComponent/mode`` of ``PhysicsBodyMode/dynamic``. This is
    /// the only kind of body that’s affected by physics simulations. For all
    /// others, modify the entity’s transform property directly.
    ///
    /// Conversely, directly modifying the transform of a dynamic body has no
    /// effect because the physics simulation overwrites it on every frame.
    ///
    /// - Parameters:
    ///   - recursive: Apply the reset to all descendant entities.
    @MainActor @preconcurrency public func resetPhysicsTransform(recursive: Bool = true)
}

/// An interface that provides velocity properties for physics simulations.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasPhysicsMotion : Entity {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasPhysicsMotion {

    /// The physics motion component used by physics simulations of the model
    /// entity.
    @MainActor @preconcurrency public var physicsMotion: PhysicsMotionComponent?
}

/// An interface that defines a point light source component.
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
@MainActor @preconcurrency public protocol HasPointLight : HasTransform {
}

@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
extension HasPointLight {

    /// A point light component for the entity.
    @MainActor @preconcurrency public var light: PointLightComponent
}

/// A specification that detects and reacts to features of the physical
/// environment.
@available(iOS 13.4, macCatalyst 14.0, *)
@MainActor @preconcurrency public protocol HasSceneUnderstanding : Entity {
}

@available(iOS 13.4, macCatalyst 14.0, *)
extension HasSceneUnderstanding {

    /// An entity component that detects and reacts to features of the physical
    /// environment.
    @MainActor @preconcurrency public var sceneUnderstanding: SceneUnderstandingComponent { get }
}

/// An interface that defines a spot light source component.
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
@MainActor @preconcurrency public protocol HasSpotLight : HasTransform {
}

@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
extension HasSpotLight {

    /// A spotlight component for the entity.
    @MainActor @preconcurrency public var light: SpotLightComponent

    /// The shadow for the spotlight.
    ///
    /// Set this property to `nil` to remove shadows for the light. Set it to an
    /// instance of ``SpotLightComponent/Shadow`` to create shadows.
    @MainActor @preconcurrency public var shadow: SpotLightComponent.Shadow?
}

/// An interface that enables an entity to be synchronized between processes and
/// networked applications.
///
/// All entities automatically adopt this protocol because the ``Entity`` base
/// class does. This adoption gives all entities a ``SynchronizationComponent``
/// instance, and a collection of methods for manipulating the component, that
/// you use to manage ownership of the entity.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasSynchronization : Entity {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasSynchronization {

    /// The entity’s synchronization component.
    @MainActor @preconcurrency public var synchronization: SynchronizationComponent?

    /// A Boolean that indicates whether the calling process owns the entity.
    ///
    /// The calling process owns the entity if the value is `true`.
    @MainActor @preconcurrency public var isOwner: Bool { get }

    /// Requests ownership of the entity.
    ///
    /// Requesting ownership isn’t guaranteed to succeed.
    ///
    /// - Parameters:
    ///   - timeout: A time in seconds to wait before giving up.
    ///
    ///   - callback: A closure that the method calls when the request completes
    ///     or times out.
    @MainActor @preconcurrency public func requestOwnership(timeout: TimeInterval = 15, _ callback: @escaping (_ failure: SynchronizationComponent.OwnershipTransferCompletionResult) -> Void)

    /// Calls the given closure in a way such that component changes that the
    /// closure makes don’t trigger synchronization.
    ///
    /// Use this method to make local changes that don’t affect remote peers,
    /// like aligning a billboard component to face the local camera.
    ///
    /// Using this method doesn’t permanently prevent changes from being
    /// synchronized. If you modify the same components immediately before the
    /// call to ``HasSynchronization/withUnsynchronized(_:)``, or anytime
    /// afterward, the changes are synchronized.
    ///
    /// If the local peer doesn’t own the associated entity, changes that the
    /// remote owner makes continue to synchronize, overwriting local,
    /// unsynchronized changes.
    ///
    /// - Parameters:
    ///   - changes: A closure that the method calls while suppressing
    ///     synchronization triggers.
    @MainActor @preconcurrency public func withUnsynchronized(_ changes: () -> Void)
}

/// An interface that enables manipulating the scale, rotation, and translation
/// of an entity.
///
/// All entities automatically adopt this protocol because the ``Entity`` base
/// class does. This adoption gives all entities a ``Transform`` component, and
/// a collection of methods for manipulating the component, that you use to
/// position the entity in space.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public protocol HasTransform : Entity {
}

@available(macOS 10.15, iOS 13.0, *)
extension HasTransform {

    /// The transform of an entity relative to its parent.
    ///
    /// For an ``AnchorEntity`` instance, the transform is relative to the AR
    /// anchor.
    @MainActor @preconcurrency public var transform: Transform

    /// The scale of the entity relative to its parent.
    ///
    /// This value is the entity’s scale relative to its parent. To get the
    /// actual scale of the entity in the scene, use
    /// ``HasTransform/scale(relativeTo:)``, passing `nil` as the reference
    /// entity.
    ///
    /// This is the same as the ``Transform/scale`` value on the
    /// ``HasTransform/transform``.
    @MainActor @preconcurrency public var scale: SIMD3<Float>

    /// Gets the scale of an entity relative to the given entity.
    ///
    /// - Parameters:
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    @MainActor @preconcurrency public func scale(relativeTo referenceEntity: Entity?) -> SIMD3<Float>

    /// Sets the scale factor of the entity relative to the given reference
    /// entity.
    ///
    /// - Parameters:
    ///   - scale: A new scale factor, relative to `referenceEntity`.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    @MainActor @preconcurrency public func setScale(_ scale: SIMD3<Float>, relativeTo referenceEntity: Entity?)

    /// The position of the entity relative to its parent.
    ///
    /// This value is the entity’s position relative to its parent. To get the
    /// world-space position of the entity in the scene, use
    /// ``HasTransform/position(relativeTo:)``, passing `nil` as the reference
    /// entity.
    ///
    /// This is the same as the ``Transform/translation`` value on the
    /// ``HasTransform/transform``.
    @MainActor @preconcurrency public var position: SIMD3<Float>

    /// Gets the position of an entity relative to the given entity.
    ///
    /// - Parameters:
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The position of the entity relative to `referenceEntity`.
    @MainActor @preconcurrency public func position(relativeTo referenceEntity: Entity?) -> SIMD3<Float>

    /// Sets the position of the entity relative to the given reference entity.
    ///
    /// - Parameters:
    ///   - position: A new position, relative to `referenceEntity`.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    @MainActor @preconcurrency public func setPosition(_ position: SIMD3<Float>, relativeTo referenceEntity: Entity?)

    /// The rotation of the entity relative to its parent.
    ///
    /// This value is the entity’s rotation relative to its parent. To get the
    /// world-space orientation of the entity, use
    /// ``HasTransform/orientation(relativeTo:)``, passing `nil` as the
    /// reference entity.
    ///
    /// This is the same as the ``Transform/rotation`` value on the
    /// ``HasTransform/transform``.
    @MainActor @preconcurrency public var orientation: simd_quatf

    /// Gets the orientation of an entity relative to the given entity.
    ///
    /// - Parameters:
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The orientation of the entity relative to `referenceEntity`.
    @MainActor @preconcurrency public func orientation(relativeTo referenceEntity: Entity?) -> simd_quatf

    /// Sets the orientation of the entity relative to the given reference
    /// entity.
    ///
    /// - Parameters:
    ///   - orientation: A new orientation, relative to `referenceEntity`.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    @MainActor @preconcurrency public func setOrientation(_ orientation: simd_quatf, relativeTo referenceEntity: Entity?)

    /// Gets the 4 x 4 transform matrix of an entity relative to the given
    /// entity.
    ///
    /// - Parameters:
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The transform of the entity relative to `referenceEntity`.
    @MainActor @preconcurrency public func transformMatrix(relativeTo referenceEntity: Entity?) -> float4x4

    /// Sets the transform of the entity relative to the given reference entity
    /// using a 4x4 matrix representation.
    ///
    /// The ``Transform`` component can’t represent all transforms that a
    /// general 4x4 matrix can represent. Setting a ``HasTransform/transform``
    /// using a 4x4 matrix is therefore a lossy event that might result in
    /// certain transformations, like shear, being dropped.
    ///
    /// - Parameters:
    ///   - transform: A 4x4 transform matrix, given relative to `referenceEntity`.
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    @MainActor @preconcurrency public func setTransformMatrix(_ transform: float4x4, relativeTo referenceEntity: Entity?)

    /// Converts a position from the local space of a reference entity to the
    /// local space of the entity on which you called this method.
    ///
    /// - Parameters:
    ///   - position: The position specified relative to `referenceEntity`.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The position given in the local space of the entity.
    @MainActor @preconcurrency public func convert(position: SIMD3<Float>, from referenceEntity: Entity?) -> SIMD3<Float>

    /// Converts a direction vector from the local space of a reference entity
    /// to the local space of the entity on which you called this method.
    ///
    /// - Parameters:
    ///   - direction: The direction vector specified relative to `referenceEntity`.
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The direction vector given in the local space of the entity.
    @MainActor @preconcurrency public func convert(direction: SIMD3<Float>, from referenceEntity: Entity?) -> SIMD3<Float>

    /// Converts a normal vector from the local space of a reference entity to
    /// the local space of the entity on which you called this method.
    ///
    /// - Parameters:
    ///   - normal: A vector perpendicular to a surface at a point, specified
    ///     relative to specified relative to `referenceEntity`.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The normal vector given in the local space of the entity.
    @MainActor @preconcurrency public func convert(normal: SIMD3<Float>, from referenceEntity: Entity?) -> SIMD3<Float>

    /// Converts the scale, rotation, and position of a transform from the local
    /// space of a reference entity to the local space of the entity on which
    /// you called this method.
    ///
    /// - Parameters:
    ///   - transform: The transform specified relative to `referenceEntity`.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The transform given in the local space of the entity.
    @MainActor @preconcurrency public func convert(transform: Transform, from referenceEntity: Entity?) -> Transform

    /// Converts a position from the local space of the entity on which you
    /// called this method to the local space of a reference entity.
    ///
    /// - Parameters:
    ///   - position: The position given in the local space of the entity.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The position specified relative to `referenceEntity`.
    @MainActor @preconcurrency public func convert(position: SIMD3<Float>, to referenceEntity: Entity?) -> SIMD3<Float>

    /// Converts a direction vector from the local space of the entity on which
    /// you called this method to the local space of a reference entity.
    ///
    /// - Parameters:
    ///   - direction: The direction vector given in the local space of the entity.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The direction vector specified relative to `referenceEntity`.
    @MainActor @preconcurrency public func convert(direction: SIMD3<Float>, to referenceEntity: Entity?) -> SIMD3<Float>

    /// Converts a normal vector from the local space of the entity on which you
    /// called this method to the local space of a reference entity.
    ///
    /// - Parameters:
    ///   - normal: A vector perpendicular to a surface at a point, given in the
    ///     local space of the entity.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The normal vector specified relative to `referenceEntity`.
    @MainActor @preconcurrency public func convert(normal: SIMD3<Float>, to referenceEntity: Entity?) -> SIMD3<Float>

    /// Converts the scale, rotation, and position of a transform from the local
    /// space of the entity on which you called this method to the local space
    /// of a reference entity.
    ///
    /// - Parameters:
    ///   - transform: The transform given in the local space of the entity.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    /// - Returns: The transform specified relative to `referenceEntity`.
    @MainActor @preconcurrency public func convert(transform: Transform, to referenceEntity: Entity?) -> Transform

    /// Positions and orients the entity to look at a target from a given
    /// position.
    ///
    /// You can use this method on any entity, but it’s particularly useful for
    /// orienting cameras and lights to aim at a particular point in space.
    ///
    /// - Parameters:
    ///   - target: The target position to look at.
    ///
    ///   - position: The new position of the entity.
    ///
    ///   - upVector: The up direction of the entity after moving.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set this to
    /// `nil` to indicate world space.
    @MainActor @preconcurrency public func look(at target: SIMD3<Float>, from position: SIMD3<Float>, upVector: SIMD3<Float> = SIMD3<Float>(0, 1, 0), relativeTo referenceEntity: Entity?)

    /// Positions and orients the entity such that it looks at certain target from a give position.
    ///
    /// - Parameters:
    ///   - target:           The target position to look at.
    ///   - position:         The new position of the entity.
    ///   - upVector:         The *up* direction of the entity.
    ///   - referenceEntity:  The reference entity which defines the frame of reference.
    ///                         Can be `nil`, which is equivalent to "world space".
    ///   - forward:          Use default forward (.negativeZ).
    ///                         Can be set to .positiveZ for non-camera entities
    ///
    /// This function moves the entity to the specified `position`. It rotates the entity such that
    /// the forward direction is pointing towards `target`. It further makes sure that entity's *up*
    /// direction aligns with the specified `upVector`.
    ///
    /// - Note: This method can be used for non-camera entities.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public func look(at target: SIMD3<Float>, from position: SIMD3<Float>, upVector: SIMD3<Float> = SIMD3<Float>(0, 1, 0), relativeTo referenceEntity: Entity?, forward: Entity.ForwardDirection = .negativeZ)

    /// Moves an entity instantly to a new location given by a transform.
    ///
    /// - Parameters:
    ///   - transform: A ``Transform`` instance that indicates the new location.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    @MainActor @preconcurrency public func move(to transform: Transform, relativeTo referenceEntity: Entity?)

    /// Moves an entity instantly to a new location given by a 4x4 matrix.
    ///
    /// - Parameters:
    ///   - transform: A 4x4 matrix that indicates the new location.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    @MainActor @preconcurrency public func move(to transform: float4x4, relativeTo referenceEntity: Entity?)

    /// Moves an entity over a period of time to a new location given by a
    /// transform.
    ///
    /// Animating the scale of an entity to 0 will cause a subsequent inverse
    /// of the entity's transform to return NaN values.  Developers may consider animating
    /// the scale of an entity to a small non-zero value. When the move completes, the
    /// entity can then be hidden or removed if applicable to the use case.
    ///
    /// - Parameters:
    ///   - target: A ``Transform`` instance that indicates the new location.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    ///   - duration: The time in seconds over which the move should occur.
    ///
    ///   - timingFunction: A timing function that controls the progress of the
    ///     animation.
    ///
    /// - Returns: An ``AnimationPlaybackController`` instance that you use to
    ///     control the animation playback.
    @discardableResult
    @MainActor @preconcurrency public func move(to target: Transform, relativeTo referenceEntity: Entity?, duration: TimeInterval, timingFunction: AnimationTimingFunction = .default) -> AnimationPlaybackController

    /// Moves an entity over a period of time to a new location given by a 4x4
    /// matrix.
    ///
    /// - Parameters:
    ///   - target: A 4x4 matrix that indicates the new location.
    ///
    ///   - referenceEntity: The entity that defines a frame of reference. Set
    ///     this to `nil` to indicate world space.
    ///
    ///   - duration: The time in seconds over which the move should occur.
    ///
    ///   - timingFunction: A timing function that controls the progress of the
    ///     animation.
    ///
    /// - Returns: An ``AnimationPlaybackController`` instance that you use to
    /// control the animation playback.
    @discardableResult
    @MainActor @preconcurrency public func move(to target: float4x4, relativeTo referenceEntity: Entity?, duration: TimeInterval, timingFunction: AnimationTimingFunction = .default) -> AnimationPlaybackController

    /// Computes a bounding box for the entity in the specified space,
    /// optionally including child entities.
    ///
    /// The method has complexity `O(n)`, where `n` is the number of entities in
    /// the hierarchy.
    ///
    /// - Parameters:
    ///   - recursive: A Boolean that you set to `true` to incorporate the bounds
    ///     of all descendants.
    ///
    ///   - referenceEntity: An entity that defines a frame of reference. Set to
    ///     `nil` to indicate world space.
    ///
    ///   - excludeInactive: A Boolean that you set to `true` to exclude inactive
    ///     entities.
    ///
    /// - Returns: The bounding box.
    @MainActor @preconcurrency public func visualBounds(recursive: Bool = true, relativeTo referenceEntity: Entity?, excludeInactive: Bool = false) -> BoundingBox
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension HasTransform {

    /// Moves and rotates the entity by a transformation from the origin pin to the target pin.
    ///
    /// - Parameter originPin: The `GeometricPin` to align. It should be one of the pins on the entity.
    /// - Parameter targetPin: The `GeometricPin` to align to.
    /// - Returns: Transformation matrix that has been applied to the `Entity`,
    ///            in the frame or reference of the parent of the `Entity`. If either pin doesn't exist, returns `nil`.
    ///
    @discardableResult
    @MainActor @preconcurrency public func align(_ originPin: GeometricPin, to targetPin: GeometricPin) -> float4x4?
}

/// A component that applies a visual effect to a hierarchy of entities when a person looks at or selects an entity.
///
/// Add a HoverEffectComponent to an entity to convey the entity can receive gestures or to separate parts that can be interacted with independently.
///
/// - Note: On visionOS, you hover over an entity by looking at or directly touching it. On other platforms, you hover over an entity by moving your mouse cursor over it.
///
/// - Important: Entities also need to have an ``InputTargetComponent`` and ``CollisionComponent`` to receive hover effects.
///
/// ```swift
/// let boxSize = SIMD3<Float>(0.5, 0.1, 0.05)
///
/// let modelComponent = ModelComponent(
///     mesh: MeshResource.generateBox(size: boxSize),
///     materials: [SimpleMaterial(color: .black, roughness: 0.5, isMetallic: false)]
/// )
/// let collisionComponent = CollisionComponent(
///     shapes: [ShapeResource.generateBox(size: boxSize)]
/// )
/// let inputTargetComponent = InputTargetComponent()
/// let hoverEffectComponent = HoverEffectComponent()
///
/// let entityA = Entity()
/// entityA.components.set([modelComponent, collisionComponent, inputTargetComponent, hoverEffectComponent])
/// ```
/// The example code above produces the following scene.
/// @Video(
///     source:hovereffectcomponent-scene-default-effect-1,
///     alt: "A video of a living room scene with 1 3D black rectangle in the center of it. The rectangle starts glowing with a feathered effect that moves around slowly."
/// )
///
/// ### Hierarchical behavior
/// The `HoverEffectComponent` applies its effect to an entity's entire hierarchy, which means that all the entity's descendent entities inherit the effect when a person looks at (or selects) an entity.
///
/// ```swift
/// let boxSize = SIMD3<Float>(0.5, 0.1, 0.05)
///
/// // Create a black box model, a matching collision component, and an input target component.
/// let modelComponent = ModelComponent(
///     mesh: MeshResource.generateBox(size: boxSize),
///     materials: [SimpleMaterial(color: .black, roughness: 0.5, isMetallic: false)]
/// )
/// let collisionComponent = CollisionComponent(
///     shapes: [ShapeResource.generateBox(size: boxSize)]
/// )
/// let inputTargetComponent = InputTargetComponent()
///
/// // Create a default hover effect component.
/// let hoverEffectComponent = HoverEffectComponent()
///
/// let entityA = Entity()
/// entityA.components.set([modelComponent, collisionComponent, inputTargetComponent])
///
/// let entityB = entityA.clone(recursive: true)
/// let entityC = entityB.clone(recursive: true)
///
/// // B is a child of A.
/// entityA.addChild(entityB)
/// // C is a child of B.
/// entityB.addChild(entityC)
///
/// // Place B above its parent, A.
/// entityB.position.y = 0.1
/// // Place C above its parent, B.
/// entityC.position.y = 0.1
///
/// entityA.components.set(hoverEffectComponent)
/// ```
///
/// In this example only the highest entity in the hierarchy has a `HoverEffectComponent`. Activating this hover effect causes all of its children to display the same effect.
///
/// @Video(
///     source:hovereffectcomponent-scene-default-effect-3,
///     alt: "A video of a living room scene with three black rectangles arranged in a column. All three of the rectangles start glowing with a feathered effect that moves around slowly."
/// )
///
/// ### Styles
///
/// You can customize the visual effect of the `HoverEffectComponent` through the use of styles.
///
/// The ``SpotlightHoverEffectStyle`` represents a feathered effect that follows the hover location on the entity. This is the default effect RealityKit uses if you create a `HoverEffectComponent` with the default initializer, ``init()``. You can customize the color and strength of this effect by passing values into the ``SpotlightHoverEffectStyle`` constructor.
///
/// ``` swift
/// let hoverComponent = HoverEffectComponent(.spotlight(
///     HoverEffectComponent.SpotlightHoverEffectStyle(
///         color: .green, strength: 2.0
///     )
/// ))
/// ```
///
/// @Video(
///     source: hovereffectcomponent-spotlight,
///     alt: "A screen recording of a living room with a black rectangle in the center of it. The rectangle begins to glow with a faint green feathered effect that moves around slowly."
/// )
///
/// The ``HighlightHoverEffectStyle`` applies a uniform glow to the entity
/// in addition to the feathered effect from the ``SpotlightHoverEffectStyle``.
/// You can customize the color and strength of this effect by passing values into the
/// ``HighlightHoverEffectStyle`` constructor.
///
/// ``` swift
/// let hoverComponent = HoverEffectComponent(.highlight(
///     HoverEffectComponent.HighlightHoverEffectStyle(
///         color: .green, strength: 2.0
///     )
/// ))
/// ```
/// @Video(
///     source: hovereffectcomponent-highlight,
///     alt: "A screen recording of a living room with a black rectangle in the center of it. The rectangle begins to glow with a bright green feathered effect."
/// )
///
/// ### Opacity functions
///
/// Customize how a `HoverEffectComponent` presents on a partially or fully transparent material with the following opacity functions:
/// - term ``HoverEffectComponent/OpacityFunction/full``: An opacity function that causes the effect to draw at full opacity regardless of opacity of the base material. This is the default opacity function.
/// - term ``HoverEffectComponent/OpacityFunction/mask``: An opacity function that draws the hover effect at full opacity when the entity's base material opacity is greater than `0.05`, and fades out the hover effect with the entity's base material when its opacity is equal to or less than `0.05`.
/// - term ``HoverEffectComponent/OpacityFunction/blend``: An opacity function that draws the hover effect with an opacity that's equal to the product of the entity's base material and the shader's output.
/// @Row{
///     @Column{
///         `.full`
///         @Video(
///             source: hovereffectcomponent-opacityfunction-full,
///             alt: "A screen recording of a living room with a partially transparent green rectangle in the center of it. The green rectangle fades in to full opacity and becomes darker before fading out again and becoming partially transparent."
///         )
///     }
///     @Column{
///         `.mask`
///         @Video(
///             source: hovereffectcomponent-opacityfunction-mask,
///             alt: "A screen recording of an empty living room. After a short delay a partially transparent green rectangle appears in the middle of the living room. The rectangle slowly fades in to become fully opaque before it fades out to be partially transparent and then disappears entirely."
///         )
///     }
///     @Column{
///         `.blend`
///         @Video(
///             source: hovereffectcomponent-opacityfunction-blend,
///             alt: "A screen recording of an empty living room. After a short delay a green rectangle slowly fades in and then fades back out."
///         )
///     }
/// }
///
/// - Note: Opacity functions can't be applied to `HoverEffectComponents` that use ``ShaderHoverEffectInputs``.
/// ### Shader inputs
///
/// Pass ``ShaderHoverEffectInputs`` to the `HoverEffectComponent`
/// constructor with ``HoverEffect-swift.struct/shader(_:)``
/// to activate the `Hover State` Shader Graph node in a ``ShaderGraphMaterial``.
/// Apply the ``ShaderGraphMaterial`` to the entity's ``ModelComponent`` when using this effect.
///
/// ``` swift
/// let boxSize = SIMD3<Float>(0.5, 0.1, 0.05)
///
/// let customMaterial = try! await ShaderGraphMaterial(
///    named: "/Root/HoverEffectComponentDemo",
///    from: Bundle.main.url(forResource: "DemoScene", withExtension: "usda")!
/// )
///
/// let entity = ModelEntity(
///     mesh: MeshResource.generateBox(size: boxSize),
///     materials: [customMaterial]
/// )
///
/// // ...
///
/// let hoverComponent = HoverEffectComponent(.shader(
///     HoverEffectComponent.ShaderHoverEffectInputs(
///         fadeInDuration: 1.0, fadeOutDuration: 1.0
///     )
/// ))
/// entity.components.set(hoverComponent)
/// ```
///
/// This shader graph represents a red and blue effect that interpolates between each color using a sine wave.
///
/// @Image(
///     source: hovereffectcomponent-shader-graph,
///     alt: "A screenshot of an app window with a shader graph visible. The shader graph represents a red and blue effect that interpolates between each color using a sine wave. On the bottom right is a purple cube representing the effect halfway between red and blue."
/// )
///
/// Hovering over the entity displays the following effect.
///
/// @Video(
///     source: hovereffectcomponent-shader,
///     alt: "A screen recording of a living room with a single black rectangle in the middle of the room. The rectangle fades to a red color and back to black several times, and then stops at black."
/// )
///
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct HoverEffectComponent : Component {

    /// An effect that applies when a person looks at or directly touches the entity.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    public struct HoverEffect {

        /// Returns a hover effect that displays a feathered spotlight on the entity where the current hover location is.
        ///
        /// - Parameter style: A ``SpotlightHoverEffectStyle`` instance that allows you to customize various aspects of this hover effect.
        public static func spotlight(_ style: HoverEffectComponent.SpotlightHoverEffectStyle) -> HoverEffectComponent.HoverEffect

        /// Returns a hover effect style that uniformly highlights the entity and also applies a feathered spotlight effect.
        ///
        /// - Parameter style: A ``HighlightHoverEffectStyle`` instance that allows you to customize various aspects of this hover effect.
        public static func highlight(_ style: HoverEffectComponent.HighlightHoverEffectStyle) -> HoverEffectComponent.HoverEffect

        /// Returns a hover effect style that applies hover state data to a custom shader that applies to the entity's model.
        ///
        /// The custom shader can be either MaterialX or ``CustomMaterial``.
        ///
        /// - Warning: This style doesn't display anything without an appropriate custom shader.
        ///
        /// - Parameter inputs: A ``ShaderHoverEffectInputs`` instance that allows you to customize various aspects of this hover effect.
        public static func shader(_ inputs: HoverEffectComponent.ShaderHoverEffectInputs) -> HoverEffectComponent.HoverEffect
    }

    /// The current hover effect of the hover effect component.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    public var hoverEffect: HoverEffectComponent.HoverEffect

    /// The blending technique options a hover effect applies to its entity's base material.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    public enum OpacityFunction : Hashable, Sendable {

        /// Applies an opaque hover effect and ignores the opacity of the entity's base material.
        ///
        /// In this example, a rounded black rectangle continuously transitions between transparent and fully opaque. Applying a green highlight hover effect with the full opacity function to the rectangle draws the effect with full opacity and ignores the opacity of the rectangle.
        /// @Video(
        ///     source: hovereffectcomponent-opacityfunction-full,
        ///     alt: "A screen recording of a living room with a partially transparent green rectangle in the center of it. The green rectangle fades in to full opacity and becomes darker before fading out again and becoming partially transparent."
        /// )
        case full

        /// Applies a hover effect with full opacity when the opacity of the entity's base material is greater than five percent.
        ///
        /// The hover effect fades out with the base material when its opacity is less than `0.05`. In this example, a rounded black rectangle continuously transitions between transparent and fully opaque. Applying a green highlight hover effect to the rectangle only displays the hover effect when the rectangle is at least slightly opaque. The hover effect doesn't draw when the rectangle is transparent.
        /// @Video(
        ///     source: hovereffectcomponent-opacityfunction-mask,
        ///     alt: "A screen recording of an empty living room. After a short delay a partially transparent green rectangle appears in the middle of the living room. The rectangle slowly fades in to become fully opaque before it fades out to be partially transparent and then disappears entirely."
        /// )
        case mask

        /// Draws the hover effect with an opacity that's equal to the product of the entity's base material and the shader's output.
        ///
        /// In this example a rounded black rectangle continuously transitions between transparent and fully opaque. Applying a green highlight hover effect with a blend opacity function to the rectangle causes the hover effect to smoothly transition between transparent and fully opaque.
        /// @Video(
        ///     source: hovereffectcomponent-opacityfunction-blend,
        ///     alt: "A screen recording of an empty living room. After a short delay a green rectangle slowly fades in and then fades back out."
        /// )
        case blend

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: HoverEffectComponent.OpacityFunction, b: HoverEffectComponent.OpacityFunction) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A type that configures the visual aspects of a spotlight hover effect for an entity.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    public struct SpotlightHoverEffectStyle : Equatable {

        /// The default style applies a white spotlight glow at the hover location.
        public static let `default`: HoverEffectComponent.SpotlightHoverEffectStyle

        /// A floating-point value that represents the intensity of the effect.
        ///
        /// The `strength` has a default value of `1.0`.
        /// Higher values increase the intensity of the effect, making it more prominent,
        /// while lower values decrease it.
        /// Set this value to `0.0` to stop the effect from displaying.
        public var strength: Float

        /// The blending technique the hover effect applies to the entity's base material.
        ///
        /// The property's default value is ``HoverEffectComponent/OpacityFunction/full``.
        public var opacityFunction: HoverEffectComponent.OpacityFunction

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: HoverEffectComponent.SpotlightHoverEffectStyle, b: HoverEffectComponent.SpotlightHoverEffectStyle) -> Bool
    }

    /// A type that configures the visual aspects of a highlight hover effect for an entity
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    public struct HighlightHoverEffectStyle : Equatable {

        /// The default style applies a white uniform glow to the affect entity as well as a white spotlight glow at the hover location
        public static let `default`: HoverEffectComponent.HighlightHoverEffectStyle

        /// A floating-point value that represents the intensity of the effect.
        ///
        ///  Defaults to 1.0.
        ///
        ///  Higher values increase the intensity of the effect and make it more prominent while lower values decrease it. Setting this to 0.0 stops the effect from displaying.
        public var strength: Float

        /// The blending technique the hover effect applies to the entity's base material.
        ///
        /// The property's default value is ``HoverEffectComponent/OpacityFunction/full``.
        public var opacityFunction: HoverEffectComponent.OpacityFunction

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: HoverEffectComponent.HighlightHoverEffectStyle, b: HoverEffectComponent.HighlightHoverEffectStyle) -> Bool
    }

    /// A type that configures the visual aspects of a hover effect that applies a custom material
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    public struct ShaderHoverEffectInputs : Equatable {

        /// The default style initializes the fade-in and fade-out durations to match the durations of the default spotlight.
        public static let `default`: HoverEffectComponent.ShaderHoverEffectInputs

        /// The time it takes in seconds for the effect to fade in.
        ///
        /// Maximum value allowed is 10 seconds.
        public var fadeInDuration: TimeInterval

        /// The time it takes in seconds for the effect to fade out.
        ///
        /// Maximum value allowed is 10 seconds.
        public var fadeOutDuration: TimeInterval

        public init(fadeInDuration: TimeInterval, fadeOutDuration: TimeInterval)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: HoverEffectComponent.ShaderHoverEffectInputs, b: HoverEffectComponent.ShaderHoverEffectInputs) -> Bool
    }

    /// Creates a hover effect component with a default spotlight effect.
    public init()

    /// Creates a hover effect component with a particular
    /// visualization effect.
    ///
    /// - Parameters:
    ///   - hoverEffect: A hover effect that defines
    ///     the visualization of this component.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    public init(_ hoverEffect: HoverEffectComponent.HoverEffect)
}

/// A component that allows you to procedurally animate a skeletal model using a full body inverse kinematics solver.
///
/// Video games and live productions use inverse kinematics (IK) solvers to procedurally adapt the animation of
/// virtual characters to the environment and the person using the experience. Full body IK solvers produce more life like
/// motion due to each demand affecting the whole body.
///
/// Use `IKComponent` to create and control a full body iterative IK solver for your character. The solver procedurally
/// adjusts the pose of your character to the demands you set. This component also maintains the state of the entity's
/// IK solvers within the overall skeletal animation system.
///
/// ### Create a solver
/// Define an inverse kinematics rig for the skeleton of the model you want to animate and generate an immutable
/// resource containing it. Create a new component value with the resource.
///
/// ```swift
/// // Load a model containing a skeletal mesh.
/// let armEntity = try await Entity(named: "Arm")
///
/// // Fetch the skeleton from the model's MeshResource.
/// guard let meshResource = entity.components[ModelComponent.self]?.mesh else {
///     fatalError("No mesh found")
/// }
///
/// let modelSkeleton = meshResource.contents.skeletons[0]
///
/// // Start with the default rig instance for the skeleton without any constraints.
/// var rig = try IKRig(for: modelSkeleton)
///
/// // This is a good place to change default rig level settings. For example, reducing
/// // the maximum solver iterations reduces the performance cost of the solve but can
/// // increase error in reaching the demands.
/// rig.maxIterations = 30
///
/// // Refine joint settings.
/// rig.joints["root/arm_joint/forearm_joint"]?.fkWeightPerAxis = .zero
///
/// // Define the joint constraints for the rig.
/// rig.constraints = [
///     // A point constraint is a standard term for a position demand. 
///     // See ``IKRig/Constraint/point(named:on:positionWeight:)``
///     .point(named: "base_constraint", on: "root/arm_joint", positionWeight: [5.0, 5.0, 5.0]),
///     // A parent constraint is a standard term for both position and orientation demands as
///     // a single transformation. See ``IKRig/Constraint/parent(named:on:positionWeight:orientationWeight:)``
///     .parent(named: "end_constraint", on: "root/arm_joint/forearm_joint/hand_joint",
///             positionWeight: [4.0, 4.0, 4.0]),
/// ]
///
/// // Make a resource containing the rig.
/// let resource = try IKResource(rig: rig)
///
/// // Add the component to the entity using the new resource.
/// armEntity.components.set(IKComponent(resource: resource))
/// ```
///
/// ### Update settings and demands
/// The initialized component provides update objects matching the structure of the rig. The update objects expose limited set of
/// parameters and the ability to set the constraint demands that can be adjusted each frame.
///
/// The forward kinematics (FK) demand is not set in this component. The solver uses the animation pose stored in
/// the ``SkeletalPosesComponent``.
///
/// ```swift
/// // Get the IK component value with the current constraint targets.
/// var component = armEntity.components[IKComponent.self]!
///
/// // Compute new demands. In this case a position animated along a circle.
/// let x = 0.1 * sin(elapsedTime)
/// let y = 0.1 * cos(elapsedTime)
///
/// // Set the new demands and update other relevant settings.
/// component.solvers[0].constraints["end_constraint"]!.target.translation = [x, y, 0]
/// component.solvers[0].constraints["end_constraint"]!.animationOverrideWeight.position = 1.0
///
/// // Set the updated component value for the updates to be applied to the solver instance.
/// armEntity.components.set(component)
/// ```
///
/// Use a chained call in cases where only a single setting or demand is updated.
/// ```swift
/// armEntity.components[IKComponent.self]!.solvers[0].constraints["end_constraint"]!
///     .animationOverrideWeight.position = 1.0
/// ```
///
/// - Note: Any value updates won't be reflected until the modified ``IKComponent`` is set on the ``Entity``.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct IKComponent : Component {

    /// Reference to the resource describing the desired inverse kinematics setup.
    /// - Note: There is one engine tick delay between setting new resource and the change reflected in `solvers`.
    public var resource: IKResource?

    /// The currently active solvers.
    /// - Note: One engine update is needed for an update of the resource to be reflected in this collection.
    public var solvers: IKComponent.SolverCollection

    /// Creates a new component value referencing the specified resource.
    /// - Parameter resource: The resource with the desired IK rig for the new solver.
    public init(resource: IKResource?)

    /// The update stage object that lets you read and update the current settings of a single solver instance.
    ///
    /// The settings this object exposes are the runtime editable values on the solver instance itself,
    /// the solver joints and constraints. For the full list of settings adjustable during creation, see ``IKRig``.
    public class Solver : Identifiable {

        /// The solver instance identifier type.
        public struct ID : Hashable, Equatable {

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: IKComponent.Solver.ID, b: IKComponent.Solver.ID) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// The solver instance identifier.
        public var id: IKComponent.Solver.ID { get }

        /// The maximum number of iterations the solver is allowed to do per frame.
        ///
        /// If the pose satisfies all of the demands using less iterations, the solve stops early.
        ///
        /// The initial value is from the respective ``IKRig/maxIterations``.
        /// - Note: Values of `0` or less, result in the constant output of the last solved pose.
        public var maxIterations: Int

        /// The solver global forward kinematics demand's weight.
        ///
        /// Multiplied with the per-joint per-axis forward kinematics weight ``IKComponent/Joint/fkWeightPerAxis``.
        ///
        /// The initial value is from the respective ``IKRig/globalFkWeight``.
        public var globalFkWeight: Float

        /// Enqueues a solver reset call that executes before the next solve.
        ///
        /// Resets the solver to its rest pose. Useful if the source animation or constraint demands change significantly.
        public func reset()

        /// The collection of all of the joint update stage objects of the solver instance.
        ///
        /// The order matches the order in the rig ``IKRig/joints``.
        public var joints: IKComponent.JointCollection

        /// The collection of all of the constraint update stage objects of the solver instance.
        ///
        /// The order matches the order in the rig ``IKRig/constraints``.
        public var constraints: IKComponent.ConstraintCollection
    }

    /// The update stage object that lets you read and update the current settings of a single joint in an IK solver.
    ///
    /// The settings this object exposes are the runtime editable values of a solver joint.
    /// Initial values are set in ``IKRig/Joint``.
    public class Joint : Identifiable {

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        public typealias ID = IKRig.Joint.ID

        /// The identifier of this joint.
        ///
        /// Matches the value of the joint in the rig ``IKRig/Joint/id-swift.property``.
        final public let id: IKComponent.Joint.ID

        /// The name of the joint.
        public var name: String { get }

        /// The per-axis weight of the source animation demand on the joint.
        ///
        /// This value is in the closed range `[0, 1]`, where `0` means no influence, and `1` is the
        /// maximum influence.
        public var fkWeightPerAxis: SIMD3<Float>

        /// The per-axis rotational stiffness of the joint.
        ///
        /// A joint with higher stiffness will rotate less to reach demands.
        ///
        /// This value is in the closed range `[0, 1]`, where `0` means the joint is free to rotate,
        /// and `1` allows no movement.
        public var rotationStiffness: SIMD3<Float>
    }

    /// The update stage object that lets you read and update the current settings of a single constraint in an IK solver.
    ///
    /// The settings this object exposes are the runtime editable values of the solver constraint.
    /// Initial values are set in ``IKRig/Constraint``.
    public class Constraint : Identifiable {

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        public typealias ID = IKRig.Constraint.ID

        /// Flags for the different demands types that can be active in a single constraint.
        public struct DemandOptions : OptionSet {

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public let rawValue: UInt

            /// Creates a new option set from the given raw value.
            ///
            /// This initializer always succeeds, even if the value passed as `rawValue`
            /// exceeds the static properties declared as part of the option set. This
            /// example creates an instance of `ShippingOptions` with a raw value beyond
            /// the highest element, with a bit mask that effectively contains all the
            /// declared static members.
            ///
            ///     let extraOptions = ShippingOptions(rawValue: 255)
            ///     print(extraOptions.isStrictSuperset(of: .all))
            ///     // Prints "true"
            ///
            /// - Parameter rawValue: The raw value of the option set to create. Each bit
            ///   of `rawValue` potentially represents an element of the option set,
            ///   though raw values may include bits that are not defined as distinct
            ///   values of the `OptionSet` type.
            public init(rawValue: UInt)

            /// The type of the elements of an array literal.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias ArrayLiteralElement = IKComponent.Constraint.DemandOptions

            /// The element type of the option set.
            ///
            /// To inherit all the default implementations from the `OptionSet` protocol,
            /// the `Element` type must be `Self`, the default.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias Element = IKComponent.Constraint.DemandOptions

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias RawValue = UInt
        }

        /// ID of the constraint, that is unique within the solver instance.
        final public let id: IKComponent.Constraint.ID

        /// The name of the constraint as defined in the rig.
        public var name: String { get }

        /// The identifier of the constrained rig joint.
        public var jointID: IKComponent.Joint.ID { get }

        /// The set of the active demands of the constraint.
        public var demands: IKComponent.Constraint.DemandOptions { get }

        /// The packed targets for the positional and orientational demands in model space.
        public var target: Transform

        /// The offset applied on top of the target transform before the solve.
        public var offset: Transform

        /// The point demand which the look-at constraint uses to generate a new orientation demand.
        ///
        /// The position is in model space. The computed demand overrides the rotation part of ``target``.
        public var lookAtTargetPosition: SIMD3<Float>

        /// The blending weights between the FK demand and the your target per demand type.
        ///
        /// Each demand uses either the value you set using ``target`` and ``lookAtTargetPosition``, or computes one from the FK demand pose. These weights control the blending between the two.
        ///
        /// The values are in the closed range `[0, 1]`, where a weight value of `0` means the constraint demands
        /// are computed from the FK demand, and a weight value of `1` means that ``target`` is used. All values
        /// in-between represent linear blend of the two. Default values are 0.
        public var animationOverrideWeight: (position: Float, rotation: Float)
    }

    /// Ordered dictionary like container with fixed size.
    ///
    /// Supports subscripting by index, element's identifier or element's name.
    public struct SolverCollection : Collection, Sequence {

        /// A type representing the sequence's elements.
        public typealias Element = IKComponent.Solver

        /// Accesses the element with the specified identifier.
        ///
        /// The following set scenarios are ignored:
        ///  * Setting nil
        ///  * Setting element with different id, e.g. `collection[ID(2)]?.id = ID(3)
        ///  * Setting element with id not in the set
        /// - Parameter id: The identifier of the requested element.
        public subscript(id: IKComponent.SolverCollection.Element.ID) -> IKComponent.SolverCollection.Element?

        /// The number of elements in the collection.
        public var count: Int { get }

        /// A Boolean value indicating whether the collection is empty.
        public var isEmpty: Bool { get }

        /// Returns a Boolean value that indicates whether the collection contains an element with a specific identifier.
        /// - Parameter id: The identifier of the element to look up.
        public func contains(_ id: IKComponent.SolverCollection.Element.ID) -> Bool

        /// Updates the element with identifier matching the new value.
        /// - Parameter newValue: The new value to store.
        /// - Returns: The previous value if the identifier was found, nil otherwise.
        @discardableResult
        public mutating func set(_ newValue: IKComponent.SolverCollection.Element) -> IKComponent.SolverCollection.Element?

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = Int

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: IKComponent.SolverCollection.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: IKComponent.SolverCollection.Index { get }

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: IKComponent.SolverCollection.Index) -> IKComponent.SolverCollection.Element

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after: IKComponent.SolverCollection.Index) -> IKComponent.SolverCollection.Index

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol {

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> IKComponent.SolverCollection.Element?

            /// The type of element traversed by the iterator.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias Element = IKComponent.SolverCollection.Element
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> IKComponent.SolverCollection.Iterator

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Indices = DefaultIndices<IKComponent.SolverCollection>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias SubSequence = Slice<IKComponent.SolverCollection>
    }

    /// Ordered dictionary like container with fixed size.
    ///
    /// Supports subscripting by index, element's identifier or element's name.
    public struct JointCollection : Collection, Sequence {

        /// A type representing the sequence's elements.
        public typealias Element = IKComponent.Joint

        /// Accesses the element with the specified identifier.
        ///
        /// The following set scenarios are ignored:
        ///  * Setting nil
        ///  * Setting element with different id, e.g. `collection[ID(2)]?.id = ID(3)
        ///  * Setting element with id not in the set
        /// - Parameter id: The identifier of the requested element.
        public subscript(id: IKComponent.JointCollection.Element.ID) -> IKComponent.JointCollection.Element?

        /// Accesses the element with the specified name.
        ///
        /// Has the same setter restrictions as ``IKComponent/JointCollection/subscript(id:)``
        /// - Parameter name: The name of the requested element.
        public subscript(name: String) -> IKComponent.JointCollection.Element?

        /// The number of elements in the collection.
        public var count: Int { get }

        /// A Boolean value indicating whether the collection is empty.
        public var isEmpty: Bool { get }

        /// Returns a Boolean value that indicates whether the collection contains an element with a specific identifier.
        /// - Parameter id: The identifier of the element to look up.
        public func contains(_ id: IKComponent.JointCollection.Element.ID) -> Bool

        /// Updates the element with identifier matching the new value.
        /// - Parameter newValue: The new value to store.
        /// - Returns: The previous value if the identifier was found, nil otherwise.
        @discardableResult
        public mutating func set(_ newValue: IKComponent.JointCollection.Element) -> IKComponent.JointCollection.Element?

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = Int

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: IKComponent.JointCollection.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: IKComponent.JointCollection.Index { get }

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: IKComponent.JointCollection.Index) -> IKComponent.JointCollection.Element

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after: IKComponent.JointCollection.Index) -> IKComponent.JointCollection.Index

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol {

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> IKComponent.JointCollection.Element?

            /// The type of element traversed by the iterator.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias Element = IKComponent.JointCollection.Element
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> IKComponent.JointCollection.Iterator

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Indices = DefaultIndices<IKComponent.JointCollection>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias SubSequence = Slice<IKComponent.JointCollection>
    }

    /// Ordered dictionary like container with fixed size.
    ///
    /// Supports subscripting by index, element's identifier or element's name.
    public struct ConstraintCollection : Collection, Sequence {

        /// A type representing the sequence's elements.
        public typealias Element = IKComponent.Constraint

        /// Accesses the element with the specified identifier.
        ///
        /// The following set scenarios are ignored:
        ///  * Setting nil
        ///  * Setting element with different id, e.g. `collection[ID(2)]?.id = ID(3)
        ///  * Setting element with id not in the set
        /// - Parameter id: The identifier of the requested element.
        public subscript(id: IKComponent.ConstraintCollection.Element.ID) -> IKComponent.ConstraintCollection.Element?

        /// Accesses the element with the specified name.
        ///
        /// Has the same setter restrictions as ``IKComponent/ConstraintCollection/subscript(id:)``
        /// - Parameter name: The name of the requested element.
        public subscript(name: String) -> IKComponent.ConstraintCollection.Element?

        /// The number of elements in the collection.
        public var count: Int { get }

        /// A Boolean value indicating whether the collection is empty.
        public var isEmpty: Bool { get }

        /// Returns a Boolean value that indicates whether the collection contains an element with a specific identifier.
        /// - Parameter id: The identifier of the element to look up.
        public func contains(_ id: IKComponent.ConstraintCollection.Element.ID) -> Bool

        /// Updates the element with identifier matching the new value.
        /// - Parameter newValue: The new value to store.
        /// - Returns: The previous value if the identifier was found, nil otherwise.
        @discardableResult
        public mutating func set(_ newValue: IKComponent.ConstraintCollection.Element) -> IKComponent.ConstraintCollection.Element?

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = Int

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: IKComponent.ConstraintCollection.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: IKComponent.ConstraintCollection.Index { get }

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: IKComponent.ConstraintCollection.Index) -> IKComponent.ConstraintCollection.Element

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after: IKComponent.ConstraintCollection.Index) -> IKComponent.ConstraintCollection.Index

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol {

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> IKComponent.ConstraintCollection.Element?

            /// The type of element traversed by the iterator.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias Element = IKComponent.ConstraintCollection.Element
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> IKComponent.ConstraintCollection.Iterator

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Indices = DefaultIndices<IKComponent.ConstraintCollection>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias SubSequence = Slice<IKComponent.ConstraintCollection>
    }
}

/// A reference counted immutable resource which contains one or more inverse kinematics solver rigs.
///
/// Use this resource with an ``IKComponent``.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public class IKResource : Resource {

    /// Getter for the deserialized resource contents as a collection of solver definitions.
    public var solverDefinitions: [IKSolverDefinition] { get }

    /// Creates a new resource instance for a single solver using the given rig and an automatic solver identifier.
    /// - Parameter rig: The inverse kinematics rig to be serialised into the resource.
    /// - Throws: Validation errors for the given rig structure.
    public convenience init(rig: IKRig) throws
}

/// A full body inverse kinematics rig definition for a single skeleton.
///
/// Describes the skeleton, its tuning, and the active constraints for the solver instance.
///
/// ### Balance of demands' weights in a full body solver
///
/// The full body solver calculates the final pose by balancing the various demands based on their assigned weights.
/// This process ensures that each demand, ranging from forward kinematics (FK) demands to constraints on joint
/// movement, affects the pose proportionally to its importance.
///
/// The solver reads the FK demands from the ``SkeletalPosesComponent``. As such these demands are either
/// a playing animation for the model, or just a static pose.
///
/// All demands have an element specific weight, and some have a global rig weight. The rig weights influence
/// the overall rig, while element weights adjust individual aspects of the model.
///
/// The table below provides detailed mappings of these weights to their respective demand types.
/// | Demand type             | Rig weight                                  | Element weight                                                 |
/// | ---------------------------- | ----------------------------------------- | ------------------------------------------------------------- |
/// | FK demands       | ``globalFkWeight``          | ``Joint/fkWeightPerAxis``                   |
/// | Joint rotation limits     | ``globalLimitsWeight`` | ``Joint/LimitsDefinition/weight`` |
/// | Constraint position    | Not applicable | ``Constraint/IKPositionDemand/weight`` |
/// | Constraint orientation | Not applicable | ``Constraint/IKOrientationDemand/weight`` |
///
/// - Note: While constraints do not have rig weight, they have blending weight between automatic and custom
///   targets. See ``IKComponent/Constraint/animationOverrideWeight`` for more information.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct IKRig {

    /// The maximum number of iterations the solver is allowed to do per frame.
    ///
    /// If the pose satisfies all of the demands using less iterations, the solve stops early.
    ///
    /// - Note: Values of `0` or less, result in the constant output of the last solved pose.
    public var maxIterations: Int

    /// The solver global weight for the forward kinematics demands.
    ///
    /// This weight is a multiplier for each joint's ``Joint/fkWeightPerAxis``.
    ///
    /// The recommended value range is the closed range `[0, 1]`, where `0` means no FK demands influence,
    /// and `1` is no rig level modification.
    public var globalFkWeight: Float

    /// The solver global weight for the joint rotation limits.
    ///
    /// This weight is a multiplier for each joint's ``Joint/LimitsDefinition/weight``.
    ///
    /// The recommended value range is the closed range `[0, 1]`, where `0` means no limits influence,
    /// and `1` is no rig level modification.
    public var globalLimitsWeight: Float

    /// A collection of all of the rig's joint settings.
    public var joints: IKRig.JointCollection

    /// A collection of all of the rig's constraint settings.
    public var constraints: IKRig.ConstraintsCollection

    /// Creates an inverse kinematics rig definition for the provided skeleton.
    /// - Parameter skeleton: The rig skeleton.
    public init(for skeleton: MeshResource.Skeleton) throws

    /// A definition of a rig joint and its IK solver settings.
    public struct Joint : Identifiable {

        /// The identity type for a joint in a rig.
        /// - Note: Stable only during the lifetime of the containing process.
        public struct ID : Hashable, Equatable {

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: IKRig.Joint.ID, b: IKRig.Joint.ID) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Creates a joint with the provided base elements.
        /// - Parameters:
        ///     - name: The name of the new joint.
        ///     - parentID: The name of the parent joint if there is one.
        ///     - restTransform: The offset of this joint from its parent (local space).
        public init(name: String, parentID: IKRig.Joint.ID? = nil, restTransform: Transform = .identity)

        /// The identifier of the joint.
        public var id: IKRig.Joint.ID { get }

        /// The name of the joint.
        public let name: String

        /// The identifier of the parent joint if there is one.
        public var parentID: IKRig.Joint.ID?

        /// The local space transformation of the joint in the solver's rest pose.
        public var restTransform: Transform

        /// A boolean value that sets whether the solver rotates the joint.
        ///
        /// Leaf hierarchies that do not need to be directly constrained can be deactivated to reduce
        /// the compute cost of the solver.
        public var active: Bool

        /// The per-axis weight of the FK demand on the joint.
        ///
        /// Values are in the closed range `[0, 1]`, where `0` means no influence, and `1` is maximum influence.
        public var fkWeightPerAxis: SIMD3<Float>

        /// The per-axis rotational stiffness of the joint.
        ///
        /// A joint with higher stiffness rotates less to reach demands.
        ///
        /// Values are in the closed range `[0, 1]`, where `0` means free to rotate, and `1` is no movement.
        public var rotationStiffness: SIMD3<Float>

        /// The per-axis rotation limits of the joint.
        public var limits: IKRig.Joint.LimitsDefinition?

        /// A definition of joint rotation limits.
        ///
        /// Limit angles are defined as relative to the rest pose.
        /// - Important: The minimum angles need to be less than the maximum angles.
        public struct LimitsDefinition {

            public enum Axis {

                case x

                case y

                case z

                /// Returns a Boolean value indicating whether two values are equal.
                ///
                /// Equality is the inverse of inequality. For any values `a` and `b`,
                /// `a == b` implies that `a != b` is `false`.
                ///
                /// - Parameters:
                ///   - lhs: A value to compare.
                ///   - rhs: Another value to compare.
                public static func == (a: IKRig.Joint.LimitsDefinition.Axis, b: IKRig.Joint.LimitsDefinition.Axis) -> Bool

                /// Hashes the essential components of this value by feeding them into the
                /// given hasher.
                ///
                /// Implement this method to conform to the `Hashable` protocol. The
                /// components used for hashing must be the same as the components compared
                /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
                /// with each of these components.
                ///
                /// - Important: In your implementation of `hash(into:)`,
                ///   don't call `finalize()` on the `hasher` instance provided,
                ///   or replace it with a different instance.
                ///   Doing so may become a compile-time error in the future.
                ///
                /// - Parameter hasher: The hasher to use when combining the components
                ///   of this instance.
                public func hash(into hasher: inout Hasher)

                /// The hash value.
                ///
                /// Hash values are not guaranteed to be equal across different executions of
                /// your program. Do not save hash values to use during a future execution.
                ///
                /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
                ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
                ///   The compiler provides an implementation for `hashValue` for you.
                public var hashValue: Int { get }
            }

            /// The weight of the joint rotation limit demand.
            ///
            /// The value is in the closed range `[0, 1]`, where `0` means no influence, and `1` is maximum
            /// correction.
            public var weight: Float

            /// The axis around which the bone twists.
            public var boneAxis: IKRig.Joint.LimitsDefinition.Axis

            /// The negative delta from the rest pose per-axis in radians.
            public var minimumAngles: SIMD3<Float>

            /// The positive delta from the rest pose per-axis in radians.
            public var maximumAngles: SIMD3<Float>

            /// Creates a joint limits definition.
            ///
            /// - Important: The minimum angles need to be less than the maximum angles.
            ///
            /// - Parameters:
            ///   - weight: The weight of the joint rotation limit demand.
            ///   - boneAxis: The axis around which the bone twists.
            ///   - minimumAngles: The negative delta from the rest pose per-axis in radians.
            ///   - maximumAngles: The positive delta from the rest pose per-axis in radians.
            public init(weight: Float = 1.0, boneAxis: IKRig.Joint.LimitsDefinition.Axis = .x, minimumAngles: SIMD3<Float> = [-2.0 * .pi, -2.0 * .pi, -2.0 * .pi], maximumAngles: SIMD3<Float> = [2.0 * .pi, 2.0 * .pi, 2.0 * .pi])
        }
    }

    /// A definition of a rig constraint.
    ///
    /// Each constraint can have its position and orientation demands enabled individually.
    public struct Constraint : Identifiable {

        /// The identity type for a constraint in a rig.
        /// - Note: Stable only during the lifetime of the containing process.
        public struct ID : Hashable, Equatable {

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: IKRig.Constraint.ID, b: IKRig.Constraint.ID) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// The identifier of the constraint.
        public var id: IKRig.Constraint.ID { get }

        /// The name of the constraint.
        ///
        /// - Important: Each constraint needs a unique name within a rig.
        public var name: String

        /// The name of the constrained joint.
        public var jointName: String

        /// A constraint target offset.
        ///
        /// The constraints adds this offset on top of its target. Useful for cases where the target comes from a binding.
        public var offset: Transform

        /// The settings of the positional demand.
        public var positionDemand: IKRig.Constraint.IKPositionDemand?

        /// The settings of the orientational demand.
        public var orientationDemand: IKRig.Constraint.IKOrientationDemand?

        /// A definition of a positional demand.
        public struct IKPositionDemand {

            /// Creates a positional demand with default settings.
            public init()

            /// Describes the acting modes of positional demands.
            ///
            /// See ``IKComponent/Constraint/animationOverrideWeight`` for the actual target
            /// compute logic.
            public enum Mode {

                /// A mode which uses the set position target.
                ///
                /// You can use this in cases like a wrist joint that needs to be at a set position.
                case reach

                /// A mode which pulls the joint in the direction of the set position target.
                ///
                /// You can use this in cases like a knee joint being pulled forward for bend direction control.
                case poleVector

                /// Returns a Boolean value indicating whether two values are equal.
                ///
                /// Equality is the inverse of inequality. For any values `a` and `b`,
                /// `a == b` implies that `a != b` is `false`.
                ///
                /// - Parameters:
                ///   - lhs: A value to compare.
                ///   - rhs: Another value to compare.
                public static func == (a: IKRig.Constraint.IKPositionDemand.Mode, b: IKRig.Constraint.IKPositionDemand.Mode) -> Bool

                /// Hashes the essential components of this value by feeding them into the
                /// given hasher.
                ///
                /// Implement this method to conform to the `Hashable` protocol. The
                /// components used for hashing must be the same as the components compared
                /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
                /// with each of these components.
                ///
                /// - Important: In your implementation of `hash(into:)`,
                ///   don't call `finalize()` on the `hasher` instance provided,
                ///   or replace it with a different instance.
                ///   Doing so may become a compile-time error in the future.
                ///
                /// - Parameter hasher: The hasher to use when combining the components
                ///   of this instance.
                public func hash(into hasher: inout Hasher)

                /// The hash value.
                ///
                /// Hash values are not guaranteed to be equal across different executions of
                /// your program. Do not save hash values to use during a future execution.
                ///
                /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
                ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
                ///   The compiler provides an implementation for `hashValue` for you.
                public var hashValue: Int { get }
            }

            /// The mode of the positional demand.
            public var mode: IKRig.Constraint.IKPositionDemand.Mode

            /// The number of joints to be influenced by this demand.
            ///
            /// The count starts from the constrained joint and continues up the chain to the skeleton's root.
            /// - Note: A depth of `0` disables the constraint, while negative values are treated as `Int.max`
            public var influenceDepthMaxJointCount: Int

            /// The per-axis weight this demand has on the pose.
            /// - Note: Values of `0` or less remove the demand influence.
            public var weight: SIMD3<Float>
        }

        /// A definition of an orientational demand.
        public struct IKOrientationDemand {

            /// Creates an orientational demand with default settings.
            public init()

            /// Describes the acting modes of an orientation demand.
            public enum Mode {

                /// A mode which uses the set rotation target.
                ///
                /// ### Demand target
                /// - term Source: The model space orientation of the constrained joint from the FK demands pose.
                /// - term Target: The rotation component of ``IKComponent/Constraint/target``.
                ///
                /// The rotation weight of ``IKComponent/Constraint/animationOverrideWeight`` determines how
                /// the rotation target is calculated:
                /// - A weight of **`0`** uses the `Source`.
                /// - A weight of **`1`** uses the `Target`.
                /// - A weight **between `0` and `1`** results in a spherical linear interpolation
                ///   between the `Source` and `Target`.
                case orientation

                /// A mode which computes the rotation target as additive look-at.
                ///
                /// ### Demand target
                /// - term Source: The model space orientation of the constrained joint from the FK demands pose.
                /// - term Target: The model space orientation aligning the associated `targetAxis` with the
                ///   direction from the current model space joint position to
                ///   ``IKComponent/Constraint/lookAtTargetPosition``.
                /// - term Delta: The rotation difference between `Source` and `Target`.
                ///
                /// The rotation weight of ``IKComponent/Constraint/animationOverrideWeight`` determines how much
                /// of the `Delta` is added to the `Source`.
                ///
                /// - Parameter targetAxis: The unit vector from the joint to the look-at target defined in the
                ///   local space of the constrained joint.
                case additiveLookAt(targetAxis: SIMD3<Float>)

                /// A mode which computes the rotation target as absolute look-at.
                ///
                /// ### Demand target
                /// - term Source: The model space orientation of the constrained joint from the FK demands pose.
                /// - term Target: The model space orientation aligning the associated `targetAxis` with the
                ///   direction from the current model space joint position to
                ///   ``IKComponent/Constraint/lookAtTargetPosition``.
                ///
                /// The rotation weight of ``IKComponent/Constraint/animationOverrideWeight`` determines how
                /// the rotation target is calculated:
                /// - A weight of **`0`** uses the `Source`.
                /// - A weight of **`1`** uses the `Target`.
                /// - A weight **between `0` and `1`** results in a spherical linear interpolation between the
                ///   `Source` and `Target`.
                ///
                /// - Parameter targetAxis: The unit vector from the joint to the look-at target defined in the
                ///   model space of the entity.
                case absoluteLookAt(targetAxis: SIMD3<Float>)
            }

            /// The mode of the orientational demand.
            public var mode: IKRig.Constraint.IKOrientationDemand.Mode

            /// The number of joints to be influenced by this demand.
            ///
            /// The count starts from the constrained joint and continues up the chain to the skeleton's root.
            /// - Note: A depth of `0` disables the constraint, while negative values are treated as `Int.max`
            public var influenceDepthMaxJointCount: Int

            /// The per-axis weight this demand has on the pose.
            /// - Note: Values of `0` or less remove the demand influence.
            public var weight: SIMD3<Float>
        }

        /// Creates a constraint with only a positional demand.
        /// - Parameters:
        ///     - name: The rig unique name of the constraint
        ///     - jointName: The name of the joint to constrain.
        ///     - positionWeight: The weight of the position demand.
        public static func point(named name: String, on jointName: String, positionWeight: SIMD3<Float> = [1, 1, 1]) -> IKRig.Constraint

        /// Creates a constraint with only an orientation demand.
        /// - Parameters:
        ///     - name: The rig unique name of the constraint
        ///     - jointName: The name of the joint to constrain.
        ///     - orientationWeight: The weight of the orientation demand.
        public static func orient(named name: String, on jointName: String, orientationWeight: SIMD3<Float> = [1, 1, 1]) -> IKRig.Constraint

        /// Creates a constraint with both a positional and an orientational demands.
        /// - Parameters:
        ///     - name: The rig unique name of the constraint
        ///     - jointName: The name of the joint to constrain.
        ///     - positionWeight: The weight of the position demand.
        ///     - orientationWeight: The weight of the orientation demand.
        public static func parent(named name: String, on jointName: String, positionWeight: SIMD3<Float> = [1, 1, 1], orientationWeight: SIMD3<Float> = [1, 1, 1]) -> IKRig.Constraint

        /// Creates a constraint with only an orientational demand in additive look-at mode.
        /// - Parameters:
        ///     - name: The rig unique name of the constraint
        ///     - jointName: The name of the joint to constrain.
        ///     - targetAxis: The axis from the constrained joint to look-at target position in the local space
        ///       of the joint.
        ///     - orientationWeight: The weight of the orientation demand.
        /// - Seealso: `IKOrientationDemand.Mode.additiveLookAt`
        public static func lookAtAdditive(named name: String, on jointName: String, lookingAlong targetAxis: SIMD3<Float>, orientationWeight: SIMD3<Float> = [1, 1, 1]) -> IKRig.Constraint

        /// Creates a constraint with only an orientational demand in absolute look-at mode.
        /// - Parameters:
        ///     - name: The rig unique name of the constraint
        ///     - jointName: The name of the joint to constrain.
        ///     - targetAxis: The axis from the constrained joint to look-at target position in the model space
        ///       of the entity.
        ///     - orientationWeight: The weight of the orientation demand.
        /// - Seealso: `IKOrientationDemand.Mode.absoluteLookAt`
        public static func lookAtAbsolute(named name: String, on jointName: String, lookingAlong targetAxis: SIMD3<Float>, orientationWeight: SIMD3<Float> = [1, 1, 1]) -> IKRig.Constraint
    }

    /// Ordered dictionary-like container with a fixed size.
    ///
    /// Supports subscripting by index, element's identifier or element's name.
    public struct JointCollection : Collection, Sequence {

        /// A type representing the sequence's elements.
        public typealias Element = IKRig.Joint

        /// Accesses the element with the specified identifier.
        ///
        /// The following set scenarios are ignored:
        ///  * Setting nil
        ///  * Setting element with different id, e.g. `collection[ID(2)]?.id = ID(3)
        ///  * Setting element with id not in the set
        /// - Parameter id: The identifier of the requested element.
        public subscript(id: IKRig.JointCollection.Element.ID) -> IKRig.JointCollection.Element?

        /// Accesses the element with the specified name.
        /// - Parameter name: The name of the requested element.
        public subscript(name: String) -> IKRig.JointCollection.Element?

        /// Calls the provided closure on each element in the hierarchy rooted at the named joint.
        /// - Parameters:
        ///     - rootJointName: The name of the root of the hierarchy.
        ///     - inclusive: Flag to include the root joint in the update list.
        ///     - update: Closure to update the joints in-place.
        /// - Note: If the root joint is not found, the closure is not executed.
        public mutating func forEach(descendantOf rootJointName: String, inclusive: Bool = false, update: (inout IKRig.JointCollection.Element) -> Void)

        /// The number of elements in the collection.
        public var count: Int { get }

        /// A Boolean value indicating whether the collection is empty.
        public var isEmpty: Bool { get }

        /// Returns a Boolean value that indicates whether the collection contains an element with
        /// a specific identifier.
        /// - Parameter id: The identifier of the element to look up.
        public func contains(_ id: IKRig.JointCollection.Element.ID) -> Bool

        /// Updates the element with identifier matching the provided value's identifier.
        ///
        /// If an element with the provided identifier is not contained - does nothing.
        /// - Parameter newValue: The new element value to store.
        /// - Returns: The previous element value if the identifier exists, `nil` otherwise.
        @discardableResult
        public mutating func set(_ newValue: IKRig.JointCollection.Element) -> IKRig.JointCollection.Element?

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = Int

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: IKRig.JointCollection.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: IKRig.JointCollection.Index { get }

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: IKRig.JointCollection.Index) -> IKRig.JointCollection.Element

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after: IKRig.JointCollection.Index) -> IKRig.JointCollection.Index

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol {

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> IKRig.JointCollection.Element?

            /// The type of element traversed by the iterator.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias Element = IKRig.JointCollection.Element
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> IKRig.JointCollection.Iterator

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Indices = DefaultIndices<IKRig.JointCollection>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias SubSequence = Slice<IKRig.JointCollection>
    }

    /// Ordered dictionary-like container.
    ///
    /// Supports subscripting by index, element's identifier or element's name.
    public struct ConstraintsCollection : Collection, Sequence, ExpressibleByArrayLiteral {

        /// A type representing the sequence's elements.
        public typealias Element = IKRig.Constraint

        /// Creates a collection with the provided constraints.
        /// - Param elements: The array of constraints in the new collection.
        public init(_ elements: [IKRig.ConstraintsCollection.Element])

        /// Accesses the element with the specified name.
        ///
        /// - Note: Set `nil` to remove the element with matching name.
        /// - Parameter name: The name of the requested element.
        public subscript(name: String) -> IKRig.ConstraintsCollection.Element?

        /// Accesses the element with the specified identifier.
        ///
        /// - Note: Set `nil` to remove the element with matching identifier.
        /// - Parameter id: The identifier of the requested element.
        public subscript(id: IKRig.ConstraintsCollection.Element.ID) -> IKRig.ConstraintsCollection.Element?

        /// The number of elements in the collection.
        public var count: Int { get }

        /// A Boolean value indicating whether the collection is empty.
        public var isEmpty: Bool { get }

        /// Returns a Boolean value that indicates whether the collection contains an element with
        /// a specific identifier.
        /// - Parameter id: The identifier of the element to look up.
        public func contains(_ id: IKRig.ConstraintsCollection.Element.ID) -> Bool

        /// Updates the element with identifier matching the provided value's identifier.
        ///
        /// If an element with the provided identifier is not contained, adds a new one.
        /// - Parameter newValue: The new element value to store.
        /// - Returns: The previous element value if the identifier exists, `nil` otherwise.
        @discardableResult
        public mutating func set(_ newValue: IKRig.ConstraintsCollection.Element) -> IKRig.ConstraintsCollection.Element?

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = Int

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: IKRig.ConstraintsCollection.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: IKRig.ConstraintsCollection.Index { get }

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: IKRig.ConstraintsCollection.Index) -> IKRig.ConstraintsCollection.Element

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after: IKRig.ConstraintsCollection.Index) -> IKRig.ConstraintsCollection.Index

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol {

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> IKRig.ConstraintsCollection.Element?

            /// The type of element traversed by the iterator.
            @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
            public typealias Element = IKRig.ConstraintsCollection.Element
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> IKRig.ConstraintsCollection.Iterator

        /// The type of the elements of an array literal.
        public typealias ArrayLiteralElement = IKRig.ConstraintsCollection.Element

        /// Creates an instance initialized with the given elements.
        public init(arrayLiteral elements: IKRig.ConstraintsCollection.Element...)

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Indices = DefaultIndices<IKRig.ConstraintsCollection>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias SubSequence = Slice<IKRig.ConstraintsCollection>
    }
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension IKRig.Joint.LimitsDefinition.Axis : Equatable {
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension IKRig.Joint.LimitsDefinition.Axis : Hashable {
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension IKRig.Constraint.IKPositionDemand.Mode : Equatable {
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension IKRig.Constraint.IKPositionDemand.Mode : Hashable {
}

/// A container describing a solver instance.
///
/// Adds unique identifier for each solver instance as the rig can be reused.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct IKSolverDefinition : Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = Int

    /// The identifier of the solver instance.
    public let id: IKSolverDefinition.ID

    /// The solver's rig definition.
    public var rigDefinition: IKRig

    /// Creates a solver definition for with a unique solver identifier and a rig.
    /// - Parameters:
    ///   - id: The identifier the solver instance is using.
    ///         Use a unique value for each ID in the resource.
    ///   - rig: The solver rig.
    public init(id: IKSolverDefinition.ID, rig: IKRig)
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct ImageBasedLightComponent : Component, Equatable {

    public enum Source {

        case none

        case single(EnvironmentResource)

        /// Blending between 2 IBLs. The Float is in [0; 1]:
        /// 0 will use the first IBL and 1 will use the second.
        case blend(EnvironmentResource, EnvironmentResource, Float)
    }

    /// Image(s) of the lighting environment
    public var source: ImageBasedLightComponent.Source

    /// Whether the IBL inherit the rotation of the Entity
    public var inheritsRotation: Bool

    /// The intensity value of the probe
    /// An intensityExponent of 0 means using the diffuse/specular intensities as-is
    /// Otherwise the intensity is multiplied by 2^intensityExponent
    public var intensityExponent: Float

    public init(source: ImageBasedLightComponent.Source, intensityExponent: Float = 0)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ImageBasedLightComponent, rhs: ImageBasedLightComponent) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct ImageBasedLightReceiverComponent : Component, Equatable {

    public var imageBasedLight: Entity

    public init(imageBasedLight: Entity)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ImageBasedLightReceiverComponent, b: ImageBasedLightReceiverComponent) -> Bool
}

/// An action that applies an impulse to the physics body at its center of mass when
/// played as an animation.
///
/// This action requires a ``CollisionComponent`` and ``PhysicsBodyComponent`` with the
/// ``PhysicsBodyComponent/mode`` set to
/// ``PhysicsBodyMode/dynamic``.
/// Without these settings, the impulse has no effect on the entity.
///
/// The example below creates an animation which applies an impulse to the entity after five seconds.
///
/// ```swift
/// // Create an action to apply an impulse, forcing the object to move upwards.
/// let impulseAction = ImpulseAction(linearImpulse: [0, 1, 0])
///
/// // Create a small positive duration value.
/// let duration: TimeInterval = 1 / 30.0
///
/// // Create an animation for the action, which will start playing
/// // after five seconds.
/// let impulseAnimation = try AnimationResource
///     .makeActionAnimation(for: impulseAction,
///                          duration: duration,
///                          delay: 5.0)
///
/// // Play the sequence animation that will play the actions.
/// entity.playAnimation(impulseAnimation)
/// ```
///
/// - Important: This action does not directly animate a bound property, such as ``BindTarget/transform``.
///
/// - Tip: This action performs instantaneously, consider supplying a small positive duration value when creating the animation.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ImpulseAction : EntityAction, Codable {

    /// The entity that the impulse acts upon.
    public var targetEntity: ActionEntityResolution

    /// An impulse in newton seconds (in physics simulation space).
    public var linearImpulse: SIMD3<Float>

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public var animatedValueType: (any AnimatableData.Type)? { get }

    /// Creates a new impulse action.
    ///
    /// - Parameters:
    ///    - targetEntity: The entity that the impulse acts upon.
    ///    - linearImpulse: The impulse in newton seconds (in physics simulation space).
    public init(targetEntity: ActionEntityResolution = .sourceEntity, linearImpulse: SIMD3<Float> = [0, 1, 0])

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A component that gives an entity the ability to receive system input.
///
/// This component should be added to an entity to inform the system that it should be treated as
/// a target for input handling. It can be customized to require only specific forms of input like direct
/// or indirect interactions. By default the component is configured to handle all forms of input on the system.
///
/// The hit testing shape that defines the entity's interactive entity is defined by the `CollisionComponent`.
/// To configure an entity for input but avoid any sort of physics-related processing, add an `InputTargetComponent`
/// and `CollisionComponent`, but disable the `CollisionComponent` for collision detection, for example:
///
/// ```
/// // Enable the entity for input.
/// myEntity.components.set(InputTargetComponent())
///
/// // Create a collision component with an empty group and mask.
/// var collision = CollisionComponent(shapes: [.generateSphere(radius: 0.1)])
/// collision.filter = CollisionFilter(group: [], mask: [])
/// myEntity.components.set(collision)
/// ```
///
/// `InputTargetComponent` behaves hierarchically, so if it is added to an entity that has
/// descendants with `CollisionComponent`s, those shapes will be used for input handling.
/// The `isEnabled` flag can be used to override this behavior by adding the `InputTargetComponent`
/// to a descendant and setting `isEnabled` to false.
///
/// `InputTargetComponent`'s `allowedInputTypes` property allows the entity to only receive
/// the provided types of input. This property also propagates down the hierarchy, but if a descendant
/// also has an `InputTargetComponent` defined, its `allowedInputTypes` property overrides
/// the value provided by the ancestor.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct InputTargetComponent : Component, Equatable {

    /// Whether the component's entity is enabled for input.
    public var isEnabled: Bool

    /// The set of input types this component's entity can receive.
    public var allowedInputTypes: InputTargetComponent.InputType

    /// A type of input that the `InputTargetComponent`'s entity can receive.
    public struct InputType : OptionSet {

        /// All forms of input that target content by querying proximity from the input device
        /// to the content.
        public static let direct: InputTargetComponent.InputType

        /// All forms of input that target content using an indirect targeting mechanism.
        public static let indirect: InputTargetComponent.InputType

        /// All forms of input.
        public static let all: InputTargetComponent.InputType

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: UInt32)

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: UInt32

        /// The type of the elements of an array literal.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias ArrayLiteralElement = InputTargetComponent.InputType

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias Element = InputTargetComponent.InputType

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias RawValue = UInt32
    }

    /// Creates a new instance of an `InputTargetComponent` with a set of `allowedInputTypes`
    /// that define what kinds of input the component's entity can receive.
    public init(allowedInputTypes: InputTargetComponent.InputType = .all)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: InputTargetComponent, b: InputTargetComponent) -> Bool
}

/// A bind target for framework-provided properties.
///
/// This structure defines a bind path for the ``BindTarget/internal(_:)`` case.
/// As a reference to framework properties, this bind target hides its path. You
/// can, however, store and assign instances of this structure.
@available(macOS 12.0, iOS 15.0, *)
public struct InternalBindPath {
}

/// A set of animatable transform values for joints that collectively represent
/// a single skeletal pose.
///
/// This structure provides a template that informs an animation on how to animate a
/// character. The resulting movement bases on
/// the _from_ (``FromToByAnimation/fromValue-6msd``)
/// , _to_ (``FromToByAnimation/toValue-813jk``)
/// , or _by_ values (``FromToByAnimation/byValue-3bp3q``) you
/// supply for a ``FromToByAnimation``. The animation determines which joints take
/// on the movement through its ``FromToByAnimation/jointNames`` property.
///
/// ## Animate an Entity's Skeleton
///
/// The following code moves the joints of a 3D asset by specifying the joint,
/// `joint1`, beginning, and ending values.
///
/// ```swift
/// // Define the joint's pose at the start of the animation.
/// let fromTransforms: [Transform] = [Transform(scale: SIMD3<Float>(1, 2, 3), rotation: simd_quatf(ix: 5.0, iy: 6.0, iz: 7.0, r: 8.0), translation: SIMD3<Float>(10, 20, 30))]
/// let fromPose = JointTransforms(fromTransforms)
///
/// // Define the joint's pose at the end of the animation.
/// let toTransforms: [Transform] = [Transform(scale: SIMD3<Float>(10, 20, 30), rotation:
/// simd_quatf(ix: 50.0, iy: 60.0, iz: 70.0, r: 80.0), translation:
/// SIMD3<Float>(100, 200, 300)) ]
/// let toPose = JointTransforms(toTransforms)
///
/// // Indicate that the animation applies to the joint named 'joint1'.
/// let jointNames = ["joint1"]
///
/// // Configure the animation specifics.
/// var fromToBy = FromToByAnimation<JointTransforms>()
/// fromToBy.name = "anim"
/// fromToBy.blendLayer = 100
/// fromToBy.duration = 10.0
/// fromToBy.fillMode = .forwards
/// fromToBy.jointNames = jointNames
/// fromToBy.fromValue = fromPose
/// fromToBy.toValue = toPose
/// fromToBy.bindTarget = .transform
///
/// // Generate a resource from the animation.
/// let animationResource = fromToBy.create()
/// ```
///
/// To run the animation on an entity and animate the joints, call
/// `playAnimation(_:transitionDuration:startsPaused:)`. Optionally, you can
/// control the animation's playback by storing the returned controller object.
///
/// ```swift
/// // Play the animation on an entity.
/// let entity = AnchorEntity(...)
/// let controller = entity.playAnimation(animationResource)
///
/// // Optionally control playback using the returned controller.
/// controller.pause()
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct JointTransforms : BidirectionalCollection, MutableCollection, ExpressibleByArrayLiteral, Equatable, AnimatableData {

    /// A position of an individual joint transform in the collection.
    public typealias Index = Int

    /// An individual joint transform in the collection.
    public typealias Element = Transform

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = Transform

    /// Initializes a collection of animatable transforms for a single skeletal
    /// pose.
    public init()

    /// Initializes a collection of animatable transforms using the argument
    /// elements for a single skeletal pose.
    ///
    /// - Parameters:
    ///   - elements: A comma-delimited list of transforms, which define position,
    ///     rotation, and scale data for the joints.
    public init(arrayLiteral elements: Transform...)

    /// Initializes a collection of transforms of a specific type for a single
    /// skeletal pose.
    ///
    /// - Parameters:
    ///   - transforms: An array of position, rotation, and scale data for the joints.
    public init<S>(_ transforms: S) where S : Sequence, S.Element == Transform

    /// Accesses a single joint transform in the collection at the given index.
    ///
    /// For more on accessing elements by index, see
    /// <doc://com.apple.documentation/documentation/swift/array/1540606-subscript>.
    public subscript(index: JointTransforms.Index) -> Transform

    /// An index to the first joint transform in the collection.
    ///
    /// For more on the sequence's beginning index, see
    /// <doc://com.apple.documentation/documentation/swift/array/1541237-startindex>.
    public var startIndex: JointTransforms.Index { get }

    /// An index to the last joint transform in the collection.
    ///
    /// For more more on the sequence's final index, see
    /// <doc://com.apple.documentation/documentation/swift/array/1539310-endindex>.
    public var endIndex: JointTransforms.Index { get }

    /// Returns the position in the sequence of the joint that follows the given
    /// position.
    ///
    /// For more on calculating indices, see
    /// <doc://com.apple.documentation/documentation/swift/array/1787306-index>.
    public func index(after i: JointTransforms.Index) -> JointTransforms.Index

    /// Returns the position in the sequence of the joint that preceeds the
    /// given position.
    ///
    /// For more on calculating indices, see
    /// <doc://com.apple.documentation/documentation/swift/array/1782301-index>.
    public func index(before i: JointTransforms.Index) -> JointTransforms.Index

    /// Returns a Boolean value that indicates whether two collections of joints
    /// are equal.
    ///
    /// - Parameters:
    ///   - lhs: The collection of joints on the left side of the operator.
    ///
    ///   - rhs: The collection of joints on the right side of the operator.
    ///
    /// - Returns: Returns `true` if the two collections of joints are equal.
    /// Otherwise, returns `false`.
    public static func == (lhs: JointTransforms, rhs: JointTransforms) -> Bool

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias Indices = DefaultIndices<JointTransforms>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias Iterator = IndexingIterator<JointTransforms>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias SubSequence = Slice<JointTransforms>
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension JointTransforms : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

/// A resource loader that acts as a publisher.
@available(macOS, introduced: 10.15, deprecated: 15.0)
@available(iOS, introduced: 13.0, deprecated: 18.0)
@available(macCatalyst, introduced: 13.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 1.0)
public class LoadRequest<Output> : Publisher {

    /// The kind of errors this publisher might publish.
    ///
    /// Use `Never` if this `Publisher` does not publish errors.
    public typealias Failure = Error

    /// The result of the load operation.
    ///
    /// A load operation can have the following results:
    /// - `success(Output)` ... The load operation has completed successfully.
    /// -  `failure(Error)` ... The load operation failed.
    /// - `nil` ... The load operation is still in progress.
    public var result: Result<Output, any Error>? { get }

    public func subscribe<S>(_ subscriber: S) where Output == S.Input, S : Subscriber, S.Failure == any Error

    /// Attaches the specified subscriber to this publisher.
    ///
    /// Implementations of ``Publisher`` must implement this method.
    ///
    /// The provided implementation of ``Publisher/subscribe(_:)-4u8kn``calls this method.
    ///
    /// - Parameter subscriber: The subscriber to attach to this ``Publisher``, after which it can receive values.
    public func receive<S>(subscriber: S) where Output == S.Input, S : Subscriber, S.Failure == any Error
}

/// A container for vertex data that you can use to create and update meshes using your own format.
///
/// Use `LowLevelMesh` when you want to bring your own vertex format to RealityKit
/// or update your data frequently.
/// To update your data in `LowLevelMesh`, you can either use Swift for CPU processing,
/// or Metal Compute Shaders for GPU processing.
///
/// - Note: Use ``MeshDescriptor`` for a simpler alternative to `LowLevelMesh`.
///         For information on loading a model from a USD or Reality file,
///         see <doc:loading-entities-from-a-file>.
///
/// Express your vertex by creating a ``LowLevelMesh/Descriptor-swift.struct`` that describes
/// your layout, along with the required index and vertex capacities.
/// This descriptor is similar to
/// <doc://com.apple.documentation/documentation/metal/mtlvertexdescriptor>,
/// with additional semantics that make the data available in your shaders.
///
/// To use `LowLevelMesh`, first define your own vertex structure, either in a Metal header
/// or using a Swift structure:
///
/// ```swift
/// struct MyVertex {
///     var position: SIMD3<Float> = .zero
///     var color: UInt32 = .zero
/// }
/// ```
///
/// Next, describe your structure to `LowLevelMesh` by creating a list of vertex attributes and a vertex layout.
/// This description informs `LowLevelMesh` how to represent the vertex data in memory:
///
/// ```swift
/// extension MyVertex {
///     static var vertexAttributes: [LowLevelMesh.Attribute] = [
///         .init(semantic: .position, format: .float3, offset: MemoryLayout<Self>.offset(of: \.position)!),
///         .init(semantic: .color, format: .uchar4Normalized_bgra, offset: MemoryLayout<Self>.offset(of: \.color)!)
///     ]
///
///     static var vertexLayouts: [LowLevelMesh.Layout] = [
///         .init(bufferIndex: 0, bufferStride: MemoryLayout<Self>.stride)
///     ]
///
///     static var descriptor: LowLevelMesh.Descriptor {
///         var desc = LowLevelMesh.Descriptor()
///         desc.vertexAttributes = MyVertex.vertexAttributes
///         desc.vertexLayouts = MyVertex.vertexLayouts
///         desc.indexType = .uint32
///         return desc
///     }
/// }
/// ```
///
/// Create a ``LowLevelMesh/Descriptor-swift.struct`` and `LowLevelMesh`,
/// and assign your mesh data and parts:
///
/// ```swift
/// func triangleMesh() throws -> LowLevelMesh {
///     var desc = MyVertex.descriptor
///     desc.vertexCapacity = 3
///     desc.indexCapacity = 3
///
///     let mesh = try LowLevelMesh(descriptor: desc)
///
///     mesh.withUnsafeMutableBytes(bufferIndex: 0) { rawBytes in
///         let vertices = rawBytes.bindMemory(to: MyVertex.self)
///         vertices[0] = MyVertex(position: [-1, -1, 0], color: 0xFF00FF00)
///         vertices[1] = MyVertex(position: [ 1, -1, 0], color: 0xFFFF0000)
///         vertices[2] = MyVertex(position: [ 0,  1, 0], color: 0xFF0000FF)
///     }
///
///     mesh.withUnsafeMutableIndices { rawIndices in
///         let indices = rawIndices.bindMemory(to: UInt32.self)
///         indices[0] = 0
///         indices[1] = 1
///         indices[2] = 2
///     }
///
///     let meshBounds = BoundingBox(min: [-1, -1, 0], max: [1, 1, 0])
///     mesh.parts.replaceAll([
///         LowLevelMesh.Part(
///             indexCount: 3,
///             topology: .triangle,
///             bounds: meshBounds
///         )
///     ])
///
///     return mesh
/// }
/// ```
/// 
/// To finish, create a ``MeshResource`` from the `LowLevelMesh`, and add it to a ``ModelComponent``.
/// You can then add this model to any ``Entity`` in your scene:
///
/// ```swift
/// func triangleEntity() throws -> Entity {
///     let lowLevelMesh = try triangleMesh()
///     let resource = try MeshResource(from: lowLevelMesh)
///
///     let modelComponent = ModelComponent(mesh: resource, materials: [UnlitMaterial()])
///
///     let entity = Entity()
///     entity.name = "Triangle"
///     entity.components.set(modelComponent)
///     entity.scale *= 0.1
///     return entity
/// }
/// ```
///
/// The low-level mesh creates a triangular shape in your RealityKit scene:
///
/// ![A screenshot of an isosceles triangle, floating in a kitchen scene. The triangle appears light gray in color.](lowlevelmesh-triangle-unlit)
///
/// The ``MeshResource`` retains a reference to the `LowLevelMesh`,
/// reflecting any changes when the renderer updates.
@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
@MainActor public class LowLevelMesh {

    /// Designates the intended usage of a vertex attribute.
    ///
    /// RealityKit consults the vertex semantic when interpreting the data in your ``LowLevelMesh``.
    /// For example, an attribute with the semantic value of ``LowLevelMesh/VertexSemantic/position``
    /// determines the position of a vertex.
    public enum VertexSemantic {

        /// The semantic for vertex position data.
        case position

        /// The semantic for per-vertex color data.
        case color

        /// The semantic for surface normal data.
        case normal

        /// The semantic for surface tangent vector data.
        case tangent

        /// The semantic for surface bitangent vector data.
        case bitangent

        /// The semantic for the first UV channel, also known as UV0.
        ///
        /// RealityKit's standard materials, such as ``UnlitMaterial`` and ``PhysicallyBasedMaterial``,
        /// interpret `uv0` as a texture coordinate.
        /// However, your shaders can use this semantic for any data.
        case uv0

        /// The semantic for the second UV channel, also known as UV1.
        ///
        /// A shader can access this generic data.
        case uv1

        /// The semantic for the third UV channel, also known as UV2.
        ///
        /// A shader can access this generic data.
        case uv2

        /// The semantic for the fourth UV channel, also known as UV3.
        ///
        /// A shader can access this generic data.
        case uv3

        /// The semantic for the fifth UV channel, also known as UV4.
        ///
        /// A shader can access this generic data.
        case uv4

        /// The semantic for the sixth UV channel, also known as UV5.
        ///
        /// A shader can access this generic data.
        case uv5

        /// The semantic for the seventh UV channel, also known as UV6.
        ///
        /// A shader can access this generic data.
        case uv6

        /// The semantic for the eighth UV channel, also known as UV7.
        ///
        /// A shader can access this generic data.
        case uv7

        /// The semantic that doesn't specify the role of the vertex.
        ///
        /// A geometry modifier can't read this vertex's attribute,
        /// but it can denote attributes for other purposes.
        case unspecified

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: LowLevelMesh.VertexSemantic, b: LowLevelMesh.VertexSemantic) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An object that determines how to store vertex attribute data in memory and map it to
    /// RealityKit shader attributes.
    public struct Attribute {

        /// Creates an attribute for a low-level mesh.
        public init(semantic: LowLevelMesh.VertexSemantic, format: MTLVertexFormat, layoutIndex: Int = 0, offset: Int)

        /// The semantic of the vertex attribute, which describes how you want RealityKit to interpret the attribute.
        ///
        /// RealityKit consults the vertex semantic when interpreting the data in your ``LowLevelMesh``.
        /// For example, an attribute with the semantic value of ``LowLevelMesh/VertexSemantic/position``
        /// uses to determine the position of a vertex.
        public var semantic: LowLevelMesh.VertexSemantic

        /// The format of the vertex attribute.
        ///
        /// When reading from a geometry modifier or surface shader,
        /// the value converts to its runtime representation
        /// using Metal's standard rules.
        ///
        /// For details about Metal's standard rules, see
        /// <doc://com.apple.documentation/documentation/metal/mtlvertexattributedescriptor/1516081-format>.
        public var format: MTLVertexFormat

        /// The location of an attribute in vertex data, determined by the byte offset 
        /// from the start of the vertex data.
        public var offset: Int

        /// The index of the layout that contains this attribute.
        ///
        /// The index refers to an entry in ``LowLevelMesh/Descriptor-swift.struct/vertexLayouts``.
        public var layoutIndex: Int
    }

    /// An object that describes a set of attributes that share a buffer index, offset,
    /// and stride.
    ///
    /// Applications typically express their types using contiguous or interleaved (strided) memory.
    ///
    /// If you interleave your data (meaning that you represent it with a structure),
    /// use one `Layout` object where ``bufferStride`` is equal to
    /// `MemoryLayout<Type>.stride()`.
    ///
    /// If you store your attributes separately, use one `Layout` per attribute.
    public struct Layout {

        public init(bufferIndex: Int, bufferOffset: Int = 0, bufferStride: Int)

        /// The index of the buffer to use for this layout. 
        ///
        /// Most usage scenarios only use one buffer.
        /// Use a buffer index that is less than
        /// ``LowLevelMesh/Descriptor-swift.struct/vertexBufferCount``.
        public var bufferIndex: Int

        /// The byte offset into the buffer for the first byte of this layout.
        public var bufferOffset: Int

        /// The distance, in bytes, between consecutive vertices for attributes using this layout.
        public var bufferStride: Int
    }

    /// An object that describes the data format and layout of the buffers in a low-level mesh.
    public struct Descriptor {

        /// Creates a descriptor for a low-level mesh.
        /// 
        /// To create a new ``LowLevelMesh``, first create a `Descriptor`
        /// object and set its property values,
        /// then use that `Descriptor` with ``LowLevelMesh/init(descriptor:)``.
        ///
        /// - Parameters:
        ///   - vertexCapacity: The maximum number of vertices the system can store in the mesh.
        ///   - vertexAttributes: The attributes of the vertices.
        ///   - vertexLayouts: The layouts for the vertex buffers.
        ///   - indexCapacity: The maximum number of vertices the system can store in a single buffer.
        ///   - indexType: The index type to use for the mesh.
        public init(vertexCapacity: Int = 0, vertexAttributes: [LowLevelMesh.Attribute] = [Attribute](), vertexLayouts: [LowLevelMesh.Layout] = [Layout](), indexCapacity: Int = 0, indexType: MTLIndexType = MTLIndexType.uint32)

        /// The maximum number of separate buffers the system supports.
        ///
        /// For optimal performance, most applications use one buffer.
        public static let maxVertexBufferCount: Int

        /// The number of buffers this descriptor uses.
        ///
        /// This value derives from the maximum `bufferIndex` each layout specifies
        /// in ``vertexLayouts``.
        public var vertexBufferCount: Int { get }

        /// The number of vertices to allocate space for.
        public var vertexCapacity: Int

        /// An array that describes the vertex input attributes to a vertex function.
        public var vertexAttributes: [LowLevelMesh.Attribute]

        /// The list of layouts.
        ///
        /// You assign a layout for each vertex attribute with ``LowLevelMesh/Attribute/layoutIndex``.
        public var vertexLayouts: [LowLevelMesh.Layout]

        /// The number of indices to allocate space for.
        ///
        /// You can specify ranges of indices to display dynamically with ``LowLevelMesh/parts``.
        public var indexCapacity: Int

        /// The data type of the indices that the index buffer stores.
        public var indexType: MTLIndexType
    }

    /// An object that describes a range of primitives to display, and their material index.
    public struct Part {

        /// Creates a low-level mesh part.
        ///
        /// - Parameters:
        ///   - indexOffset: The offset, in bytes, of the first index.
        ///   - indexCount: The number of indices to use for this part.
        ///   - topology: The geometric primitive to use when rendering this part.
        ///   - materialIndex: The material index this part associates with.
        ///   - bounds: The model-space bounding box of the part.
        public init(indexOffset: Int = 0, indexCount: Int = 0, topology: MTLPrimitiveType = .triangle, materialIndex: Int = 0, bounds: BoundingBox)

        /// The offset, in bytes, of the first index.
        public var indexOffset: Int

        /// The number of indices to use for this part.
        public var indexCount: Int

        /// The geometric primitive to use when rendering this part.
        public var topology: MTLPrimitiveType

        /// The material index this part associates with.
        public var materialIndex: Int

        /// The model-space bounding box of this part.
        ///
        /// RealityKit uses this bounding box for culling the mesh against the active camera.
        ///
        /// Take care to maintain the bounds of each mesh part so that it completely contains the part's geometry.
        /// Otherwise, RealityKit may not render your meshes correctly.
        public var bounds: BoundingBox
    }

    /// The definition of the structure of this low-level mesh.
    @MainActor final public let descriptor: LowLevelMesh.Descriptor

    /// The capacity of the index buffer, measured in indices.
    ///
    /// This value is equivalent to ``LowLevelMesh/Descriptor-swift.struct/indexCapacity``.
    @MainActor public var indexCapacity: Int { get }

    /// The capacity of the vertex buffer, measured in vertices.
    ///
    /// This value is equivalent to ``LowLevelMesh/Descriptor-swift.struct/vertexCapacity``.
    @MainActor public var vertexCapacity: Int { get }

    /// An object that holds a mutable collection low-level mesh parts.
    public struct PartsCollection {
    }

    /// A mutable collection of parts.
    ///
    /// The parts of a ``LowLevelMesh`` object specify how to interpret the index buffer.
    /// You can also use `parts` to customize the material index and primitive type.
    @MainActor public var parts: LowLevelMesh.PartsCollection

    /// Constructs a low-level mesh from a descriptor.
    ///
    /// - Parameter descriptor: An object that defines the structure of the low-level mesh.
    /// - Throws: If the descriptor is invalid or if you do not successfully allocate its memory.
    @MainActor public init(descriptor: LowLevelMesh.Descriptor) throws

    /// Retrieves a Metal vertex buffer at the specified index, for GPU reading.
    ///
    /// - Parameters:
    ///   - index: The index of the buffer to read.
    ///     Use a value that is less than ``LowLevelMesh/Descriptor/vertexBufferCount``.
    ///   - commandBuffer: The <doc://com.apple.documentation/documentation/metal/mtlcommandbuffer> you intend
    ///     to use for reading.
    ///     RealityKit waits for the command buffer to complete before discarding the buffer.
    @MainActor public func read(bufferIndex index: Int, using commandBuffer: any MTLCommandBuffer) -> any MTLBuffer

    /// Retrieves a Metal vertex buffer you can use to replace the contents of the specified buffer
    /// on the GPU using Metal.
    ///
    /// The buffer's contents are in an uninitialized state.
    ///
    /// - Parameters:
    ///   - index: The index of the buffer to modify.
    ///     Use a value that is less than ``LowLevelMesh/Descriptor/vertexBufferCount``.
    ///   - commandBuffer: The <doc://com.apple.documentation/documentation/metal/mtlcommandbuffer>
    ///     you intend to use for buffer modifications.
    ///     RealityKit waits for the command buffer to complete before utilizing the buffer for rendering.
    @MainActor public func replace(bufferIndex index: Int, using commandBuffer: any MTLCommandBuffer) -> any MTLBuffer

    /// Retrieves the Metal index buffer for GPU reading.
    ///
    /// - Parameter commandBuffer: The <doc://com.apple.documentation/documentation/metal/mtlcommandbuffer>
    ///   you intend to use for reading.
    ///   RealityKit waits for the command buffer to complete before discarding the buffer.
    @MainActor public func readIndices(using commandBuffer: any MTLCommandBuffer) -> any MTLBuffer

    /// Retrieves a Metal index buffer that you can use to replace the indices of this low-level mesh.
    ///
    /// The buffer's contents are in an uninitialized state.
    ///
    /// - Parameter commandBuffer: The <doc://com.apple.documentation/documentation/metal/mtlcommandbuffer>
    ///   you intend to use for reading.
    ///   RealityKit waits for the command buffer to complete before discarding the buffer.
    @MainActor public func replaceIndices(using commandBuffer: any MTLCommandBuffer) -> any MTLBuffer

    /// Reads a Metal vertex buffer synchronously on the CPU.
    ///
    /// The buffer is only valid for the lifetime of the callback.
    @MainActor public func withUnsafeBytes(bufferIndex: Int, _ callback: (UnsafeRawBufferPointer) -> Void)

    /// Updates a Metal vertex buffer synchronously on the CPU.
    ///
    /// The buffer is only valid for the lifetime of the callback.
    @MainActor public func withUnsafeMutableBytes(bufferIndex: Int, _ callback: (UnsafeMutableRawBufferPointer) -> Void)

    /// Replaces a Metal vertex buffer synchronously on the CPU.
    ///
    /// The buffer's contents are unspecified, and it is
    /// the caller's responsibility to populate the buffer with valid data.
    /// The buffer is only valid for the lifetime of the callback.
    @MainActor public func replaceUnsafeMutableBytes(bufferIndex: Int, _ callback: (UnsafeMutableRawBufferPointer) -> Void)

    /// Reads the index buffer synchronously on the CPU.
    ///
    /// The buffer is only valid for the lifetime of the callback.
    @MainActor public func withUnsafeIndices(_ callback: (UnsafeRawBufferPointer) -> Void)

    /// Updates the index buffer synchronously on the CPU.
    ///
    /// The buffer is only valid for the lifetime of the callback.
    @MainActor public func withUnsafeMutableIndices(_ callback: (UnsafeMutableRawBufferPointer) -> Void)

    /// Replaces the index buffer synchronously on the CPU.
    ///
    /// The buffer's contents are unspecified, and it is
    /// the caller's responsibility to populate the buffer with valid data.
    /// The buffer is only valid for the lifetime of the callback.
    @MainActor public func replaceUnsafeMutableIndices(_ callback: (UnsafeMutableRawBufferPointer) -> Void)
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension LowLevelMesh : Sendable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension LowLevelMesh.VertexSemantic : Equatable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension LowLevelMesh.VertexSemantic : Hashable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension LowLevelMesh.PartsCollection : MutableCollection, RandomAccessCollection {

    /// A type representing the sequence's elements.
    public typealias Element = LowLevelMesh.Part

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// For example, you can replace an element of an array by using its
    /// subscript.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one
    /// past the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: LowLevelMesh.PartsCollection.Index) -> LowLevelMesh.Part

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = Range<LowLevelMesh.PartsCollection.Index>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Iterator = IndexingIterator<LowLevelMesh.PartsCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<LowLevelMesh.PartsCollection>
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension LowLevelMesh.PartsCollection {

    /// Adds an element to the end of the collection.
    ///
    /// - Parameter newElement: The element to append to the collection.
    public mutating func append(_ newElement: LowLevelMesh.PartsCollection.Element)

    /// Adds the elements of a sequence or collection to the end of this collection.
    ///
    /// - Parameter newElements: The elements to append to the collection.
    public mutating func append<S>(contentsOf newElements: S) where S : Sequence, S.Element == LowLevelMesh.Part

    /// Removes all mesh parts from this collection.
    public mutating func removeAll()

    /// Replaces all mesh parts in this collection with
    /// those from the new sequence.
    ///
    /// - Parameter newElements: The elements to replace the contents of the collection.
    public mutating func replaceAll<S>(_ newElements: S) where S : Sequence, S.Element == LowLevelMesh.Part
}

/// A container for texture data allowing you to create and update textures using your own format.
///
/// Use `LowLevelTexture` when you want to bring your own texture data to RealityKit, or update your data frequently.
/// You update the data on the GPU with Metal compute shaders.
/// This is ideal for bringing your own textures to RealityKit as-is, or when you intend to update your data frequently.
///
/// - Note: For a simpler alternative, consider creating your ``TextureResource`` from a
///         <doc://com.apple.documentation/documentation/coregraphics/cgimage> with
///         ``TextureResource/init(image:withName:options:)-4qz9s``,
///         ``TextureResource/texture2DArray(slices:named:options:)-50g10``,
///         ``TextureResource/cube(slices:named:options:)-57yj1``, or
///         ``TextureResource/texture3D(slices:named:options:)-6pude``.
///
/// Express your texture by creating a ``LowLevelTexture/Descriptor-swift.struct`` that describes
/// how the data is laid out, along with the size of the texture.  This descriptor is similar to
/// <doc://com.apple.documentation/documentation/metal/mtltexturedescriptor>.
///
/// To use `LowLevelTexture`, first configure the descriptor with the desired characteristics of your texture.
///
/// ```swift
/// var textureDescriptor: LowLevelTexture.Descriptor {
///     var desc = LowLevelTexture.Descriptor()
///
///     desc.textureType = .type2D
///     desc.arrayLength = 1
///
///     desc.width = 2048
///     desc.height = 2048
///     desc.depth = 1
///
///     desc.mipmapLevelCount = 1
///     desc.pixelFormat = .bgra8Unorm
///     desc.textureUsage = [.shaderRead, .shaderWrite]
///     desc.swizzle = .init(red: .red, green: .green, blue: .blue, alpha: .alpha)
///
///     return desc
/// }
/// ```
///
/// Then, you can initialize the `LowLevelTexture` from its descriptor and provide it to a ``TextureResource``.
///
/// ```swift
/// let texture = try LowLevelTexture(descriptor: textureDescriptor)
/// let resource = try TextureResource(from: texture)
/// ```
///
/// You update the contents of a `LowLevelTexture` on the GPU, using a Metal Command Buffer and Compute Command Encoder.
/// For example, you can write a compute kernel in Metal Shading Language to generate the color of each pixel:
///
/// ```cpp
/// kernel void
/// lowLevelTextureKernel(
///     texture2d<half, access::write> outTexture [[texture(0)]],
///     uint2 gid [[thread_position_in_grid]])
/// {
///     // Compute texture coordinate ranging from 0 to 1 along each axis.
///     half2 texCoord {
///         half(gid[0]) / (outTexture.get_width() - 1),
///         half(gid[1]) / (outTexture.get_height() - 1)
///     };
///
///     // Compute the color as a linear gradient from top to bottom.
///     half3 color = mix(
///         half3 { 0.2, 0.2, 0.8 },
///         half3 { 0.7, 0.7, 0.9 },
///         texCoord.y);
///
///     // Specify an opacity of 1 if the pixel is within a circle
///     // spanning the image bounds.
///     half alpha = length(texCoord - 0.5) < 0.5 ? 1.0h : 0.0h;
///
///     // Write the color and opacity to the texture.
///     outTexture.write(half4(color, alpha), gid);
/// }
/// ```
///
/// You can use this compute kernel to populate the `LowLevelTexture`:
///
/// ```swift
/// func populate(texture: LowLevelTexture, device: MTLDevice) {
///     // Set up the Metal command queue and compute command encoder, 
///     // or abort if that fails.
///     guard let commandQueue = device.makeCommandQueue(),
///           let commandBuffer = commandQueue.makeCommandBuffer(),
///           let computeEncoder = commandBuffer.makeComputeCommandEncoder() else {
///         return
///     }
///
///     // Load a Metal compute kernel written in Metal Shading Language, 
///     // or abort if that fails.
///     guard let library = device.makeDefaultLibrary(),
///           let function = library.makeFunction(name: "lowLevelTextureKernel"),
///           let computePipelineState = try? device.makeComputePipelineState(function: function) else {
///         return
///     }
///
///     // Enqueue the Metal command buffer.
///     commandBuffer.enqueue()
///
///     // Set up the Metal compute command encoder with the app's compute kernel.
///     computeEncoder.setComputePipelineState(computePipelineState)
///
///     // Retrieve a MTLTexture from LowLevelTexture.
///     // This texture will be directly consumed by RealityKit's renderer.
///     let outTexture: MTLTexture = texture.replace(using: commandBuffer)
///     computeEncoder.setTexture(outTexture, index: 0)
///
///     // Disptach the GPU compute work.
///     // Note: threadGroupCount and threadGroupSize determined elsewhere.
///     computeEncoder.dispatchThreadgroups(
///         threadGroupCount,
///         threadsPerThreadgroup: threadGroupSize)
///
///     // End the encoding and commit the command buffer.
///     // When the command buffer completes, RealityKit automatically applies the changes.
///     computeEncoder.endEncoding()
///     commandBuffer.commit()
/// }
/// ```
///
/// To finish, add your ``TextureResource`` to a ``Material`` and display it on an ``Entity``.
/// ```swift
/// func textureEntity(device: MTLDevice) throws -> Entity {
///     // Create the LowLevelTexture and populate it on the GPU.
///     let texture = try LowLevelTexture(descriptor: textureDescriptor)
///     populate(texture: texture, device: device)
///
///     // Create a TextureResource from the LowLevelTexture.
///     let resource = try TextureResource(from: texture)
///
///     // Create a material that uses the texture.
///     var material = UnlitMaterial(texture: resource)
///     material.opacityThreshold = 0.5
///
///     // Return an entity of a plane which uses the generated texture.
///     return ModelEntity(mesh: .generatePlane(width: 1, depth: 1), materials: [material])
/// }
/// ```
///
/// ![A screenshot of a circle.  The color of the circle is a linear gradient; the top is light blue and the bottom is close to white.](lowleveltexture-circle-unlit)
///
/// The ``TextureResource`` retains a reference to the `LowLevelTexture`,
/// and presents changes made to the `LowLevelTexture` when the renderer updates.
@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
@MainActor public class LowLevelTexture {

    /// The descriptor that was used to initialize this `LowLevelTexture`.
    @MainActor final public let descriptor: LowLevelTexture.Descriptor

    /// An object that you use to configure new `LowLevelTexture` objects.
    public struct Descriptor {

        /// Creates a descriptor for a low level texture.
        ///
        /// To create a new ``LowLevelTexture``, first create a `LowLevelTexture.Descriptor` object and set its property
        /// values.  Then, call ``LowLevelTexture/init(descriptor:)``.
        public init(textureType: MTLTextureType = .type2D, pixelFormat: MTLPixelFormat = .invalid, width: Int = 0, height: Int = 0, depth: Int = 1, mipmapLevelCount: Int = 1, arrayLength: Int = 1, textureUsage: MTLTextureUsage = .unknown, swizzle: MTLTextureSwizzleChannels = .init(red: .red, green: .green, blue: .blue, alpha: .alpha))

        /// The dimension and arrangement of texture image data.
        public var textureType: MTLTextureType

        /// The size and bit layout of all pixels in the texture.
        public var pixelFormat: MTLPixelFormat

        /// The width of the texture image for the base level mipmap, in pixels.
        public var width: Int

        /// The height of the texture image for the base level mipmap, in pixels.
        public var height: Int

        /// The depth of the texture image for the base level mipmap, in pixels.
        public var depth: Int

        /// The number of mipmap levels for this texture.
        public var mipmapLevelCount: Int

        /// The number of array elements for this texture.
        public var arrayLength: Int

        /// An enumeration for the various options that determine how you can use a texture.
        public var textureUsage: MTLTextureUsage

        /// The pattern you want the GPU to apply to pixels when you read or sample pixels from the texture.
        public var swizzle: MTLTextureSwizzleChannels
    }

    /// Creates a low level texture from a descriptor.
    ///
    /// - Parameter descriptor: An object that defines the structure of the low level texture.
    /// - Throws: If the descriptor is invalid or if memory was not allocated successfully.
    @MainActor public init(descriptor: LowLevelTexture.Descriptor) throws

    /// Retrieves the current texture for GPU reading.
    @MainActor public func read() -> any MTLTexture

    /// Retrieves a Metal texture that your app's shaders can write to when they run on a GPU.
    ///
    /// The buffer's contents are in an uninitialized state.
    ///
    /// - Parameter commandBuffer: The <doc://com.apple.documentation/documentation/metal/mtlcommandbuffer>
    ///   you intend to use for texture modifications.
    ///   RealityKit waits for the command buffer to complete before utilizing the texture for rendering.
    @MainActor public func replace(using commandBuffer: any MTLCommandBuffer) -> any MTLTexture
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension LowLevelTexture : Sendable {
}

/// A type that describes the material aspects of a mesh, like color and
/// texture.
///
/// In RealityKit, a _material_ defines the surface properties of a 3D model. It
/// specifies how RealityKit renders the entity, including its color and whether
/// it’s shiny or reflective. A ``ModelEntity`` may have one material that
/// defines the way RealityKit renders the entire entity, or it may have several
/// that define the look of different parts of the model.
///
/// RealityKit provides several different material structures for different
/// types of rendering, including ``PhysicallyBasedMaterial``, which is a
/// versatile material capable of simulating real-world objects in a highly
/// realistic manner, and ``UnlitMaterial``, which RealityKit draws with no
/// lighting effects or shadows.
///
/// If you import a model from a USDZ file, RealityKit automatically creates one
/// or more ``PhysicallyBasedMaterial`` instances from the material properties
/// contained in the file.
@available(macOS 10.15, iOS 13.0, *)
public protocol Material {
}

@available(macOS 12.0, iOS 15.0, *)
extension Material {

    /// The parameter type that custom materials uses for properties the
    /// framework passes to shader functions.
    public typealias Parameters = MaterialParameters
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Material {

    /// Name exported with USDz or Reality File asset
    public var name: String? { get }
}

/// The abstract superclass for objects representing compute functions for RealityKit custom materials .
///
/// This class is the parent of, and contains common properties and methods for
/// ``CustomMaterial/GeometryModifier``
/// and ``CustomMaterial/SurfaceShader``. Don’t create an instance of this superclass yourself.
@available(macOS 12.0, iOS 15.0, *)
public protocol MaterialFunction {

    /// Name of function found in library
    ///
    /// This function should exist in the given library and be declared
    /// with the `[[visible]]` attribute.
    var name: String { get set }

    /// Metal Library containing the given function.
    ///
    /// Most often this is your app's default library.
    var library: any MTLLibrary { get set }
}

/// A set of types that material parameters can use.
///
/// This class contains many nested types used to specify various properties of
/// material.
///
/// Many material properties support more than one type of data. For example,
/// you can specify ``PhysicallyBasedMaterial/baseColor-swift.property`` using
/// either a single `Float`, or a UV mapped image texture.
/// MaterialParameterTypes and its nested symbols implement the ability to
/// accept different data types for the same property.
@available(macOS 12.0, iOS 15.0, *)
public struct MaterialParameterTypes {

    /// An object that defines how the system removes polygons before rendering
    /// a scene.
    ///
    /// To improve performance, RealityKit culls polygons, or faces, that it
    /// determines won’t be visible. Discarding faces that aren’t part of the
    /// final render eliminates the need to do any calculations for those
    /// faces. Use this object to specify what kind of polygons RealityKit
    /// culls.
    @available(macOS 12.0, iOS 15.0, *)
    public enum FaceCulling {

        /// The system doesn’t cull polygons.
        case none

        /// The system culls front-facing polygons.
        case front

        /// The system culls back-facing polygons.
        case back

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: MaterialParameterTypes.FaceCulling, b: MaterialParameterTypes.FaceCulling) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An object that defines a transformation the framework applies to a
    /// material’s UV-mapped textures.
    ///
    /// An entity’s UV texture coordinates define how RealityKit maps image
    /// textures onto an entity. This object defines a transformation to texture
    /// coordinates that changes the way this material maps textures onto an
    /// entity. You might, for example, continuously rotate, translate, or scale
    /// the texture coordinates and animate materials to create special effects,
    /// such as fire or flowing liquids.
    @available(macOS 12.0, iOS 15.0, *)
    public struct TextureCoordinateTransform {

        /// The amount by which the framework offsets the entity’s UV texture
        /// coordinates.
        public var offset: SIMD2<Float>

        /// The amount by which the framework scale the UV texture coordinates.
        public var scale: SIMD2<Float>

        /// The amount by which the framework rotates the UV texture coordinates
        /// you specify in radians.
        public var rotation: Float

        /// Creates a texture coordinate transform object.
        ///
        /// - Parameters:
        ///   - offset: The amount to offset the UV texture coordinates.
        ///
        ///   - scale: The amount to scale the UV texture coordinates.
        ///
        ///   - rotation: The amount to rotate the UV texture coordinates in
        ///     radians.
        public init(offset: SIMD2<Float> = .init(), scale: SIMD2<Float> = .init(1, 1), rotation: Float = 0.0)
    }

    /// An object that defines how the system rasterizes triangles and triangle strips
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public enum TriangleFillMode {

        /// Triangles and triangle strips are rasterized as filled triangles
        case fill

        /// Triangles and triangle strips are rasterized as lines
        case lines

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: MaterialParameterTypes.TriangleFillMode, b: MaterialParameterTypes.TriangleFillMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension MaterialParameterTypes {

    /// Modes that describe how materials should be blended with content behind them.
    public enum BlendMode : Equatable, Hashable, Sendable {

        /// Blend by multiplying the material's color value by its alpha value
        ///
        /// This is the default blending mode for materials.
        /// Use this mode to represent transparent objects such as glass.
        case alpha

        /// Blend by adding the material's color to the background color, ignoring alpha.
        ///
        /// This method is also known as additive blending or linear dodge.
        case add

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: MaterialParameterTypes.BlendMode, b: MaterialParameterTypes.BlendMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 12.0, iOS 15.0, *)
extension MaterialParameterTypes.FaceCulling : Equatable {
}

@available(macOS 12.0, iOS 15.0, *)
extension MaterialParameterTypes.FaceCulling : Hashable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MaterialParameterTypes.TriangleFillMode : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MaterialParameterTypes.TriangleFillMode : Hashable {
}

@available(macOS 12.0, iOS 15.0, *)
public struct MaterialParameters {

    public struct Texture {

        public struct Sampler {

            public init()

            public init(_ v: MTLSamplerDescriptor)

            public mutating func modify<R>(_ closure: (MTLSamplerDescriptor) throws -> R) rethrows -> R

            public func access<R>(_ closure: (MTLSamplerDescriptor) throws -> R) rethrows -> R
        }

        public var resource: TextureResource

        public var sampler: MaterialParameters.Texture.Sampler

        public var uvIndex: Int

        /// Channel swizzle to use when RealityKit reads or samples from the texture.
        ///
        /// The default value performs no swizzle, sampling red from the texture's red channel,
        /// green from the texture's green channel, blue from the texture's blue channel, and
        /// alpha from the texture's alpha channel.
        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public var swizzle: MTLTextureSwizzleChannels

        public init(_ resource: TextureResource, sampler: MaterialParameters.Texture.Sampler)

        public init(_ resource: TextureResource)
    }

    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public struct Handle {
    }

    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public enum Value {

        @available(visionOS 2.0, *)
        case texture(MaterialParameters.Texture)

        case textureResource(TextureResource)

        case float(Float)

        case simd2Float(SIMD2<Float>)

        case simd3Float(SIMD3<Float>)

        case simd4Float(SIMD4<Float>)

        case color(CGColor)

        case float2x2(float2x2)

        case float3x3(float3x3)

        case float4x4(float4x4)

        case bool(Bool)

        case int(Int32)
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MaterialParameters.Texture : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: MaterialParameters.Texture, rhs: MaterialParameters.Texture) -> Bool
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension MaterialParameters.Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: MaterialParameters.Value, b: MaterialParameters.Value) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MaterialParameters.Texture.Sampler : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: MaterialParameters.Texture.Sampler, b: MaterialParameters.Texture.Sampler) -> Bool
}

/// The scalar parameter applied to a material.
@available(macOS 10.15, iOS 13.0, *)
public enum MaterialScalarParameter : ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral, Hashable {

    /// A scalar, single-precision value.
    case float(Float)

    /// A one-channel texture.
    case texture(TextureResource)

    /// Creates a scalar parameter from a floating-point literal.
    public init(floatLiteral value: Float)

    /// Creates a scalar parameter from an integer literal.
    public init(integerLiteral value: Int)

    /// Indicates whether two scalar parameters are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first scalar parameter to compare.
    ///
    ///   - rhs: The second scalar parameter to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two scalar parameters
    /// are equal.
    public static func == (lhs: MaterialScalarParameter, rhs: MaterialScalarParameter) -> Bool

    /// Hashes the essential components of the scalar parameter by feeding them
    /// into the given hash function.
    ///
    /// - Parameters:
    ///   - hasher: The hash function to use when combining the components of the
    ///     scalar parameter.
    public func hash(into hasher: inout Hasher)

    /// A type that represents a floating-point literal.
    ///
    /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
    /// where available.
    @available(iOS 13.0, macOS 10.15, *)
    public typealias FloatLiteralType = Float

    /// A type that represents an integer literal.
    ///
    /// The standard library integer and floating-point types are all valid types
    /// for `IntegerLiteralType`.
    @available(iOS 13.0, macOS 10.15, *)
    public typealias IntegerLiteralType = Int

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Mesh buffer containing elements of any type.
@available(macOS 12.0, iOS 15.0, *)
public struct MeshBuffer<Element> : Sequence {

    /// A type representing the sequence's elements.
    public typealias Element = Element

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> Element?
    }

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> MeshBuffer<Element>.Iterator

    /// The number of elements in the buffer.
    public let count: Int

    /// Rate of the buffer.
    public var rate: MeshBuffers.Rate

    /// Access the buffer as an array. This may create a copy if the data are not already an array.
    public var elements: [Element] { get }

    /// New object with updated rate.
    public func usingRate(_ rate: MeshBuffers.Rate) -> MeshBuffer<Element>

    /// Iterate over pairs of elements.
    public func forEach(_ body: (Element, Element) throws -> Void) rethrows

    /// Iterate over three elements per step.
    public func forEach(_ body: (Element, Element, Element) throws -> Void) rethrows

    /// Iterate over four elements per step.
    public func forEach(_ body: (Element, Element, Element, Element) throws -> Void) rethrows
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == Int8 {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == Int8
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == UInt8 {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == UInt8
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == Int16 {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == Int16
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == UInt16 {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == UInt16
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == Int32 {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == Int32
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == UInt32 {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == UInt32
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == Float {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == Float
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == Double {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == Double
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == SIMD2<Float> {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == SIMD2<Float>
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == SIMD3<Float> {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == SIMD3<Float>
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffer where Element == SIMD4<Float> {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == SIMD4<Float>
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshBuffer where Element == MeshJointInfluence {

    /// Create buffer from an array of elements.
    public init(_ array: [Element])

    /// Create buffer from an array of element values and an array of indices into that value array.
    public init(elements: [Element], indices: [UInt32])

    /// Create a buffer from any sequence of elements.
    public init<S>(_ sequence: S) where S : Sequence, S.Element == MeshJointInfluence
}

/// Conforming objects contain a table of mesh buffers.
@available(macOS 12.0, iOS 15.0, *)
public protocol MeshBufferContainer {

    /// Descriptors for the buffers.
    var buffers: [MeshBuffers.Identifier : AnyMeshBuffer] { get }

    /// The buffer for a given semantic. There can only be one buffer for any given ID.
    subscript<S>(semantic: S) -> MeshBuffer<S.Element>? where S : MeshBufferSemantic { get set }
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBufferContainer {

    /// Positions of all the points.
    public var positions: MeshBuffers.Positions

    /// Buffer of normals, if any.
    public var normals: MeshBuffers.Normals?

    /// Buffer of tangents, if any.
    public var tangents: MeshBuffers.Tangents?

    /// Buffer of bitangents, if any.
    public var bitangents: MeshBuffers.Tangents?

    /// Buffer of texture coordinates, if any.
    public var textureCoordinates: MeshBuffers.TextureCoordinates?
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension MeshBufferContainer {

    /// - Parameters:
    ///   - name: The unique name of the blendShape offset buffer.
    /// - Returns a MeshBuffer that is associated with the name
    public func blendShapeOffsets(named: String) -> MeshBuffers.BlendShapeOffsets?

    /// - Parameters:
    ///   - name: The unique name of the blendShape offset buffer.
    ///     - buffer: The MeshBuffer that contains the blendShape offset data
    public mutating func setBlendShapeOffsets(named: String, buffer: MeshBuffers.BlendShapeOffsets?)

    /// An array of blendShape names that exist in MeshBufferContainer
    public var blendShapeNames: [String] { get }
}

/// A protocol that holds an identifier value for mesh buffers.
@available(macOS 12.0, iOS 15.0, *)
public protocol MeshBufferSemantic : Identifiable {

    associatedtype Element

    var id: MeshBuffers.Identifier { get }
}

/// An object that holds the data for an model entity's mesh.
@available(macOS 12.0, iOS 15.0, *)
public enum MeshBuffers {

    public struct Identifier : Hashable, Equatable, CustomStringConvertible, Sendable {

        public let name: String

        public let isCustom: Bool

        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        public let isBlendShape: Bool

        public static let positions: MeshBuffers.Identifier

        public static let normals: MeshBuffers.Identifier

        public static let tangents: MeshBuffers.Identifier

        public static let bitangents: MeshBuffers.Identifier

        public static let textureCoordinates: MeshBuffers.Identifier

        public static let triangleIndices: MeshBuffers.Identifier

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: MeshBuffers.Identifier, rhs: MeshBuffers.Identifier) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Defines how elements in the buffer map to features of the mesh.
    public enum Rate {

        /// Buffer maps at the vertex rate.
        ///
        /// The buffer count needs to match the number of points.
        case vertex

        /// Buffer maps at the face rate.
        ///
        /// The buffer count needs to match the number of polygons.
        case face

        /// Buffer maps at the index rate.
        ///
        /// The buffer count needs to match the number of indices.
        case faceVarying

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: MeshBuffers.Rate, b: MeshBuffers.Rate) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The data type for each element of the buffer.
    public enum ElementType {

        case uInt8

        case uInt16

        case uInt32

        case int8

        case int16

        case int32

        case float

        case double

        case simd2Float

        case simd3Float

        case simd4Float

        @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
        case jointInfluence

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: MeshBuffers.ElementType, b: MeshBuffers.ElementType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffers {

    public struct Semantic<Element> : MeshBufferSemantic {

        /// The stable identity of the entity associated with this instance.
        public let id: MeshBuffers.Identifier

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias ID = MeshBuffers.Identifier
    }

    public static let positions: MeshBuffers.Semantic<SIMD3<Float>>

    public static let normals: MeshBuffers.Semantic<SIMD3<Float>>

    public static let tangents: MeshBuffers.Semantic<SIMD3<Float>>

    public static let bitangents: MeshBuffers.Semantic<SIMD3<Float>>

    public static let textureCoordinates: MeshBuffers.Semantic<SIMD2<Float>>

    public static let triangleIndices: MeshBuffers.Semantic<UInt32>

    public static func custom<Value>(_ name: String, type: Value.Type) -> MeshBuffers.Semantic<Value>
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshBuffers {

    public static let jointInfluences: MeshBuffers.Semantic<MeshJointInfluence>
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffers {

    public typealias Positions = MeshBuffer<SIMD3<Float>>

    public typealias Normals = MeshBuffer<SIMD3<Float>>

    public typealias Tangents = MeshBuffer<SIMD3<Float>>

    public typealias TextureCoordinates = MeshBuffer<SIMD2<Float>>

    public typealias TriangleIndices = MeshBuffer<UInt32>
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension MeshBuffers {

    public static func blendShapeOffsets(named: String) -> MeshBuffers.Semantic<SIMD3<Float>>

    public typealias BlendShapeOffsets = MeshBuffer<SIMD3<Float>>
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshBuffers {

    public typealias JointInfluences = MeshBuffer<MeshJointInfluence>
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshBuffers.Identifier {

    public static let jointInfluences: MeshBuffers.Identifier
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffers.Rate : Equatable {
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffers.Rate : Hashable {
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffers.ElementType : Equatable {
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshBuffers.ElementType : Hashable {
}

/// Defines a 3D mesh's structure and data.
///
/// Create or modify 3D shapes in a RealityKit scene using `MeshDescriptor`,
/// which provides properties and methods to define the vertices,
/// normals, texture coordinates, and other attributes of the mesh.
///
/// Apply the mesh to an ``Entity`` by creating a ``MeshResource`` with ``MeshResource/generate(from:)-6l1q2``, and create a ``ModelComponent`` with ``ModelComponent/init(mesh:materials:)``.
///
/// Start by creating a basic triangle with a `MeshDescriptor` instance.
///
/// ```swift
/// var descriptor = MeshDescriptor(name: "triangle")
/// descriptor.positions = MeshBuffers.Positions([
///     [-1, -1, 0], [1, -1, 0], [0, 1, 0]
/// ])
/// descriptor.primitives = .triangles([0, 1, 2])
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct MeshDescriptor : MeshBufferContainer {

    public enum Materials {

        /// A single material index for the whole mesh.
        case allFaces(UInt32)

        /// A different material index for each face.
        case perFace([UInt32])
    }

    /// Indicates which primitive shape type a mesh applies to its vertex indices.
    public enum Primitives {

        /// Defines one or more triangles with an integer array of indices.
        ///
        /// Add three vertex index integers per triangle.
        /// For example, you can represent a single triangle with three indices.
        /// ```swift
        /// .triangles([0, 1, 2])
        /// ```
        case triangles([UInt32])

        /// Defines one or more triangles and quadrilaterals with two separate arrays of indices.
        ///
        /// Each element in the first array represents a polygon and the element's value indicates how many vertices in that polygon.
        /// The elements in the second array are the vertex indices for the polygons.
        ///
        /// For example, to represent a triangle and a quadrilateral the first array has the elements `3` and `4`,
        /// and the second array has a total of 7 elements, one for every vertex in both polygons.
        /// ```swift
        /// .polygons([3, 4], [
        ///     0, 1, 2,
        ///     3, 4, 5, 6
        /// ])
        /// ```
        case polygons([UInt8], [UInt32])

        /// Defines separate arrays for triangle and quad indices.
        ///
        /// The elements of the first array have three vertex indices for each triangle.
        /// The elements of the first array have four vertex indices for each quadrilateral.
        ///
        /// For example, you can define three triangles with 9 vertex indices in the first array,
        /// and two quadralaterals with 8 vertex indices in the second array.
        /// ```swift
        /// .trianglesAndQuads(
        ///     triangles: [0, 1, 2, 7, 8, 9, 42, 43, 44],
        ///     quads: [3, 4, 5, 6, 10, 11, 12, 13]
        /// )
        /// ```
        case trianglesAndQuads(triangles: [UInt32], quads: [UInt32])
    }

    /// Creates an empty mesh descriptor.
    public init(name: String = "")

    /// The name of the mesh.
    public var name: String

    /// Material assignments.
    public var materials: MeshDescriptor.Materials

    /// The primitives that make up the mesh.
    public var primitives: MeshDescriptor.Primitives?

    /// Descriptors for the buffers.
    public var buffers: [MeshBuffers.Identifier : AnyMeshBuffer] { get }

    /// The buffer for a given semantic. There can only be one buffer for any given ID.
    public subscript<S>(semantic: S) -> MeshBuffer<S.Element>? where S : MeshBufferSemantic
}

/// An object that holds a collection of mesh resource instances.
@available(macOS 12.0, iOS 15.0, *)
public struct MeshInstanceCollection {

    /// Number of instances.
    public var count: Int { get }

    /// True if there are no instances.
    public var isEmpty: Bool { get }

    public init()

    public init(_ instances: [MeshResource.Instance])

    /// Read an instance given its name.
    public subscript(id: String) -> MeshResource.Instance? { get }

    /// Add a new instance to the container. Returns true if added.
    @discardableResult
    public mutating func insert(_ instance: MeshResource.Instance) -> Bool

    /// Update an existing instance. The old instance is returned.
    @discardableResult
    public mutating func update(_ instance: MeshResource.Instance) -> MeshResource.Instance?

    /// Remove an instance by name.
    @discardableResult
    public mutating func remove(id: String) -> MeshResource.Instance?

    /// Remove all the instances.
    public mutating func removeAll()
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshInstanceCollection : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> MeshResource.Instance?

        /// The type of element traversed by the iterator.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias Element = MeshResource.Instance
    }

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> MeshInstanceCollection.Iterator

    /// A type representing the sequence's elements.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias Element = MeshResource.Instance
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension MeshInstanceCollection : Collection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> MeshResource.Instance { get }

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = DefaultIndices<MeshInstanceCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<MeshInstanceCollection>
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshInstanceCollection : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral: MeshResource.Instance...)

    /// The type of the elements of an array literal.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias ArrayLiteralElement = MeshResource.Instance
}

/// A binding to a joint, which consists of the joint's index and the weight of that joint's
/// influence on a vertex.
///
/// A vertex may be influenced by one or more joints. The skinned position of that vertex is defined
/// by a set of MeshJointInfluence values whose weights sum to 1. The skinned position is given by:
///
/// ```swift
/// position = vertexPosition(transformedByJoint: influences[0].jointIndex) * influences[0].weight
///          + vertexPosition(transformedByJoint: influences[1].jointIndex) * influences[1].weight
///          + ...
/// ```
///
/// The skinned position of a vertex is a linear combination of the vertex's position transformed by
/// each joint, with weights given by the MeshJointInfluence values.
///
/// To transform a vertex position by a joint, the initial vertex position is first transformed by
/// the joint's inverse bind pose matrix, then by the local-to-parent transform of the joint, and
/// finally by the local-to-parent transform of each of the joint's parents.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct MeshJointInfluence {

    public init()

    public init(jointIndex: Int, weight: Float)

    public var jointIndex: Int

    public var weight: Float
}

/// An object that holds a collection of mesh models.
@available(macOS 12.0, iOS 15.0, *)
public struct MeshModelCollection {

    /// Number of models.
    public var count: Int { get }

    /// True if there are no models.
    public var isEmpty: Bool { get }

    public init()

    public init(_ models: [MeshResource.Model])

    /// Read a model given its id.
    public subscript(id: String) -> MeshResource.Model? { get }

    /// Add a new model to the container. Returns true if added.
    @discardableResult
    public mutating func insert(_ model: MeshResource.Model) -> Bool

    /// Update an existing model. The old model is returned.
    @discardableResult
    public mutating func update(_ model: MeshResource.Model) -> MeshResource.Model?

    /// Remove a model by id.
    @discardableResult
    public mutating func remove(id: String) -> MeshResource.Model?

    /// Remove all the models.
    public mutating func removeAll()
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshModelCollection : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> MeshResource.Model?

        /// The type of element traversed by the iterator.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias Element = MeshResource.Model
    }

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> MeshModelCollection.Iterator

    /// A type representing the sequence's elements.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias Element = MeshResource.Model
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension MeshModelCollection : Collection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> MeshResource.Model { get }

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = DefaultIndices<MeshModelCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<MeshModelCollection>
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshModelCollection : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral: MeshResource.Model...)

    /// The type of the elements of an array literal.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias ArrayLiteralElement = MeshResource.Model
}

/// An object that holds a collection of mesh parts.
@available(macOS 12.0, iOS 15.0, *)
public struct MeshPartCollection {

    /// Number of parts.
    public var count: Int { get }

    /// True if there are no parts.
    public var isEmpty: Bool { get }

    public init()

    public init(_ parts: [MeshResource.Part])

    /// Read a part given its id.
    public subscript(id: String) -> MeshResource.Part? { get }

    /// Add a new part to the container. Returns true if added.
    @discardableResult
    public mutating func insert(_ part: MeshResource.Part) -> Bool

    /// Update an existing part. The old part is returned.
    @discardableResult
    public mutating func update(_ part: MeshResource.Part) -> MeshResource.Part?

    /// Remove a part by id.
    @discardableResult
    public mutating func remove(id: String) -> MeshResource.Part?

    /// Remove all the parts.
    public mutating func removeAll()
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshPartCollection : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> MeshResource.Part?

        /// The type of element traversed by the iterator.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias Element = MeshResource.Part
    }

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> MeshPartCollection.Iterator

    /// A type representing the sequence's elements.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias Element = MeshResource.Part
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension MeshPartCollection : Collection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> MeshResource.Part { get }

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = DefaultIndices<MeshPartCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<MeshPartCollection>
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshPartCollection : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral: MeshResource.Part...)

    /// The type of the elements of an array literal.
    @available(iOS 15.0, macOS 12.0, *)
    public typealias ArrayLiteralElement = MeshResource.Part
}

/// A high-level representation of a collection of vertices and edges that
/// define a shape.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class MeshResource : Resource {

    /// The number of material entries required to render the mesh resource.
    @MainActor @preconcurrency public var expectedMaterialCount: Int { get }

    /// A box that bounds the mesh.
    @MainActor @preconcurrency public var bounds: BoundingBox { get }

    /// Creates a box mesh from a length for the box's width, height, and depth,
    /// and a radius for the corners.
    ///
    /// - Parameters:
    ///   - size: The length of the box's width, height, and depth, in meters.
    ///
    ///   - cornerRadius: The radius of each corner's circular arc, in meters.
    ///   Values for `cornerRadius` can be, at most, equal to `size / 2.0`.
    ///   For example, if the box's dimensions are `5.0` x `5.0` x `5.0`,
    ///   the corner radius needs to be in the range `[0.0, 2.5]`.
    ///
    /// The method centers the box at the entity’s origin and aligns the box's
    /// faces with the coordinate system's axes.
    ///
    /// > Note: The method clamps `cornerRadius` so that it doesn't exceed half
    /// the length of the box's smallest dimension.
    @MainActor @preconcurrency public static func generateBox(size: Float, cornerRadius: Float = 0) -> MeshResource

    /// Creates a box mesh from a vector of three scalar values that represent
    /// width, height, and depth, respectively, and a radius for the corners.
    ///
    /// - Parameters:
    ///   - size: The length of the box's width, height, and depth, in meters,
    ///   along the x-, y-, and z-axis, respectively.
    ///
    ///   - cornerRadius: The radius of each corner's circular arc, in meters.
    ///   Values for `cornerRadius` can be, at most, equal to
    ///   `min(size.x, size.y, size.z) / 2.0`.
    ///   For example, if the box's dimensions are `3.0` x `4.0` x `5.0`,
    ///   the corner radius needs to be in the range `[0.0, 1.5]`.
    ///
    /// The method centers the box at the entity’s origin and aligns the box's
    /// faces with the coordinate system's axes.
    ///
    /// > Note: The method clamps `cornerRadius` so that it doesn't exceed half
    /// the length of the box's smallest dimension.
    @MainActor @preconcurrency public static func generateBox(size: SIMD3<Float>, cornerRadius: Float = 0) -> MeshResource

    /// Creates a box mesh from a width, height, depth,
    /// a radius for the corners, and a Boolean option that splits faces.
    ///
    /// - Parameters:
    ///   - width: The length of the box's width, in meters, along the x-axis.
    ///
    ///   - height: The length of the box's height, in meters, along the y-axis.
    ///
    ///   - depth: The length of the box's depth, in meters, along the z-axis.
    ///
    ///   - cornerRadius: The radius of each corner's circular arc, in meters.
    ///   Values for `cornerRadius` can be, at most, equal to the smallest
    ///   value of the `width`, `height`, and `depth` parameters.
    ///   For example, if the box's dimensions are `3.0` x `4.0` x `5.0`,
    ///   the corner radius needs to be in the range `[0.0, 1.5]`.
    ///
    ///   - splitFaces: A Boolean value that indicates whether you can assign up
    ///   to six separate materials, one for each face. If `false`, you can only
    ///   assign one material for all six faces.
    ///
    /// The method centers the box at the entity’s origin and aligns the box's
    /// faces with the coordinate system's axes.
    ///
    /// > Note: The method clamps `cornerRadius` so that it doesn't exceed half
    /// the length of the box's smallest dimension.
    @MainActor @preconcurrency public static func generateBox(width: Float, height: Float, depth: Float, cornerRadius: Float = 0, splitFaces: Bool = false) -> MeshResource

    /// Creates a new rectangle mesh with the specified dimensions in the
    /// entity’s xy-plane.
    ///
    /// The rectangle is centered at the entity’s origin and aligned with its x
    /// and y axes. The surface normal points along the z-axis. The depth along
    /// the z-axis is 0.
    ///
    /// - Note: The xy-plane is a plane that aligns with the x and y axes.
    ///
    /// - Parameters:
    ///   - width: The width, in meters, of the rectangle along the x-axis.
    ///
    ///   - height: The height, in meters, of the rectangle along the y-axis.
    ///
    ///   - cornerRadius: A corner radius in the form of a circular arc, with
    ///     curvature that transitions abruptly from `0` to `1/r` at the boundary
    ///     between the edge and the corner.
    ///
    /// - Returns: The rectangle mesh.
    @MainActor @preconcurrency public static func generatePlane(width: Float, height: Float, cornerRadius: Float = 0) -> MeshResource

    /// Creates a new rectangle mesh with the specified dimensions in the
    /// entity’s xz-plane.
    ///
    /// The rectangle is centered at the entity’s origin and aligned with its x
    /// and y axes. The surface normal points along the y-axis. The depth along
    /// the y-axis is 0.
    ///
    /// - Note: The xz-plane is a plane that aligns with the x and z axes.
    ///
    /// - Parameters:
    ///   - width: The width, in meters, of the rectangle along the x-axis.
    ///
    ///   - depth: The depth, in meters, of the rectangle along the z-axis.
    ///
    ///   - cornerRadius: A corner radius in the form of a circular arc, with
    ///     curvature that transitions abruptly from `0` to `1/r` at the boundary
    ///     between the edge and the corner.
    ///
    /// - Returns: The rectangle mesh.
    /// 
    @MainActor @preconcurrency public static func generatePlane(width: Float, depth: Float, cornerRadius: Float = 0) -> MeshResource

    /// Creates a new sphere mesh with the specified radius.
    ///
    /// The sphere is centered at the entity’s origin.
    ///
    /// - Parameters:
    ///   - radius: The radius, in meters, of the sphere.
    ///
    /// - Returns: A sphere mesh.
    @MainActor @preconcurrency public static func generateSphere(radius: Float) -> MeshResource
}

@available(macOS 12.0, iOS 15.0, *)
extension MeshResource {

    /// A part of a model consisting of a single material.
    public struct Part : MeshBufferContainer, Identifiable {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        /// Material index for the part.
        public var materialIndex: Int

        /// Create a new part.
        public init(id: String, materialIndex: Int)

        /// Index buffer for triangles.
        public var triangleIndices: MeshBuffers.TriangleIndices?

        /// Descriptors for the buffers.
        public var buffers: [MeshBuffers.Identifier : AnyMeshBuffer] { get }

        /// The buffer for a given semantic. There can only be one buffer for any given ID.
        public subscript<S>(semantic: S) -> MeshBuffer<S.Element>? where S : MeshBufferSemantic

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias ID = String
    }

    /// A model consists of a list of parts.
    public struct Model : Identifiable {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        /// Table of parts composing this mesh.
        public var parts: MeshPartCollection

        public init(id: String, parts: [MeshResource.Part])

        @MainActor @preconcurrency public init(id modelID: String, descriptors: [MeshDescriptor]) throws

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias ID = String
    }

    /// An object that transforms a model to a location.
    public struct Instance : Identifiable {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        /// Name of the model to instance.
        public var model: String

        /// Transform for the instance.
        public var transform: simd_float4x4

        public init(id: String, model: String, at transform: simd_float4x4? = nil)

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias ID = String
    }

    /// Value of the contents of the resource.
    public struct Contents {

        /// Table of models.
        public var models: MeshModelCollection

        /// Table of instances.
        public var instances: MeshInstanceCollection

        public init()
    }

    /// Get the contents of the mesh asset.
    @MainActor @preconcurrency public var contents: MeshResource.Contents { get }

    /// Replace the contents of this mesh resource.
    ///
    /// - Note: The contents of the modified mesh resource will not be synced between network clients.
    @MainActor @preconcurrency public func replace(with content: MeshResource.Contents) throws

    /// Replace the contents of this mesh resource asynchronously.
    ///
    /// - Note: The contents of the modified mesh resource will not be synced between network clients.
    ///
    nonisolated public func replace(with content: MeshResource.Contents) async throws

    /// Replace the contents of this mesh resource asynchronously.
    ///
    /// - Note: The contents of the modified mesh resource will not be synced between network clients.
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "replace(with:)")
    @available(macOS, introduced: 12.0, deprecated: 15.0, renamed: "replace(with:)")
    @available(macCatalyst, introduced: 15.0, deprecated: 18.0, renamed: "replace(with:)")
    @available(iOS, introduced: 15.0, deprecated: 18.0, renamed: "replace(with:)")
    @MainActor @preconcurrency public func replaceAsync(with content: MeshResource.Contents) -> LoadRequest<MeshResource>

    /// Create a mesh resource from contents.
    @MainActor @preconcurrency public static func generate(from content: MeshResource.Contents) throws -> MeshResource

    /// Initialize a mesh resource from contents asynchronously.
    nonisolated public convenience init(from content: MeshResource.Contents) async throws

    /// Create a mesh resource from contents asynchronously.
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "init(from:)")
    @available(macOS, introduced: 12.0, deprecated: 15.0, renamed: "init(from:)")
    @available(macCatalyst, introduced: 15.0, deprecated: 18.0, renamed: "init(from:)")
    @available(iOS, introduced: 15.0, deprecated: 18.0, renamed: "init(from:)")
    @MainActor @preconcurrency public static func generateAsync(from content: MeshResource.Contents) -> LoadRequest<MeshResource>

    /// Create a mesh resource from a list of mesh descriptors.
    @MainActor @preconcurrency public static func generate(from descriptors: [MeshDescriptor]) throws -> MeshResource

    /// Initialize a mesh resource from descriptors asynchronously.
    nonisolated public convenience init(from descriptors: [MeshDescriptor]) async throws

    /// Create a mesh resource from a list of mesh descriptors asynchronously.
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "init(from:)")
    @available(macOS, introduced: 12.0, deprecated: 15.0, renamed: "init(from:)")
    @available(macCatalyst, introduced: 15.0, deprecated: 18.0, renamed: "init(from:)")
    @available(iOS, introduced: 15.0, deprecated: 18.0, renamed: "init(from:)")
    @MainActor @preconcurrency public static func generateAsync(from descriptors: [MeshDescriptor]) -> LoadRequest<MeshResource>
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshResource {

    /// A skeleton consists of a hierarchy of joints. Each joint defines a coordinate space.
    /// Portions of a model may be thought of as having a position in a joint's local space.
    ///
    /// Each joint in a skeleton has a name, which usually determines the joint's parent. For
    /// example, the legs of a human body might include these joints:
    /// - `root`
    /// - `root/hips_joint`
    /// - `root/hips_joint/left_upLeg_joint`
    /// - `root/hips_joint/left_upLeg_joint/left_leg_joint`
    /// - `root/hips_joint/right_upLeg_joint`
    /// - `root/hips_joint/right_upLeg_joint/right_leg_joint`
    /// - etc.
    ///
    /// Models with skinned animation are authored in a fixed pose (the "bind pose"). The position
    /// of a vertex in a particular joint's local space is a function of the vertex's position in
    /// the bind pose and an "inverse bind pose" matrix which transforms from the bind pose (model
    /// space) to the joint's local space.
    ///
    /// When unanimated, the pose of a skinned model is defined by the rest pose of each joint. This
    /// transform is relative to the joint's parent. Usually, the rest pose of a model is the same
    /// as its bind pose.
    public struct Skeleton : Identifiable {

        /// A named joint in a ``Skeleton``.
        public struct Joint : Equatable {

            /// The name of this joint.
            ///
            /// Each joint needs to have a unique name within its skeleton.
            public var name: String

            /// The index of this joint's parent, or nil if this joint has no parent.
            ///
            /// If the joint has a parent, the index of the parent
            /// needs to be lower than that of the child.
            public var parentIndex: Int?

            /// A matrix which transforms from the authored pose (the "bind pose") of the bound model
            /// to the local space of this joint.
            ///
            /// > Note: The bind pose matrix transforms a vertex from a joint's local coordinate
            /// space to the position of that vertex in the model's bind pose. This property is the
            /// _inverse_ bind pose matrix, so it transforms a vertex from its position in the
            /// model's bind pose to the local coordinate space of this joint.
            public var inverseBindPoseMatrix: simd_float4x4

            /// The local transform of this joint in skeleton's rest pose, specified relative to
            /// this joint's parent (or relative to model space, if this joint has no parent).
            ///
            /// The rest pose of a skeleton is used when a joint is not otherwise animated.
            public var restPoseTransform: Transform

            /// Creates a single joint in a skeleton.
            public init(name: String, parentIndex: Int?, inverseBindPoseMatrix: simd_float4x4, restPoseTransform: Transform)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: MeshResource.Skeleton.Joint, b: MeshResource.Skeleton.Joint) -> Bool
        }

        /// The unique identifier of this skeleton. This acts as a stable identity for this object.
        public var id: String

        /// The joints which define this skeleton's hierarchy.
        ///
        /// - Important: The order of joints in this array is significant;
        ///   parents need to precede their children.
        public var joints: [MeshResource.Skeleton.Joint]

        /// Creates a skeleton from an array of joints.
        ///
        /// - Important: The order of joints in this array is significant;
        ///   parents need to precede their children.
        public init(id: String, joints: [MeshResource.Skeleton.Joint])

        /// Creates a skeleton from arrays which define its joints. Returns `nil` if there was an
        /// issue converting the parameters to a valid skeleton.
        ///
        /// - Parameters:
        ///   - id: The unique name of this skeleton.
        ///   - jointNames: The names of each joint.
        ///   - inverseBindPoseMatrices: The matrix which, for each joint, transforms from model
        ///   space (bind pose) to the local space of that joint.
        ///   - restPoseTransforms: The transform from each joint's local space to its parent's local
        ///   space, used when the joint is not animated. If not specified, the rest pose is assumed to
        ///   be the same as the bind pose, and is computed from the inverse bind pose matrices.
        ///   - parentIndices: The index of each joint's parent, or nil if that joint has no parent.
        ///   If this array is not provided, the parent of each joint is inferred from its name (e.g.
        ///   a joint named `root/hips_joint` is parented to a joint named `root`).
        ///
        /// - Note: A parent joint needs to precede all of its child joints.
        /// - Note: All the arrays passed to this initializer need to have the same length.
        public init?(id: String, jointNames: [String], inverseBindPoseMatrices: [simd_float4x4], restPoseTransforms: [Transform]? = nil, parentIndices: [Int?]? = nil)

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias ID = String
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshResource {

    /// A buffer of vertex-joint influences which bind the mesh part's vertices to a skeleton via a
    /// skinning deformation.
    ///
    /// Each vertex is associated with a fixed number of influences. If `influencesPerVertex` is 4,
    /// then there should be four elements in the buffer of joint influences for each vertex in the
    /// mesh part.
    ///
    /// - Note: If a particular vertex needs fewer influences than the `influencesPerVertex` value,
    /// the influences for that vertex can be padded with zero-weight influences.
    public struct JointInfluences {

        /// Buffer of joint influences.
        public var influences: MeshBuffers.JointInfluences { get }

        /// Associates every vertex in the mesh with a fixed number of influences per vertex.
        ///
        /// - Parameters:
        ///   - influences: Buffer of joint influences.
        ///   - influencesPerVertex: The number of consecutive influences used by each vertex.
        ///
        /// - Note: The buffer should contain `vertexCount * influencesPerVertex` elements.
        public init(influences: MeshBuffers.JointInfluences, influencesPerVertex: Int)
    }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension MeshResource {

    /// Asynchronously creates a mesh resource from a low-level mesh.
    ///
    /// - Parameter mesh: The vertex data that defines the mesh.
    @MainActor @preconcurrency public convenience init(from mesh: LowLevelMesh) async throws

    /// Synchronously creates a mesh resource from a low-level mesh.
    ///
    /// - Parameter mesh: The vertex data that defines the mesh.
    @MainActor @preconcurrency public convenience init(from mesh: LowLevelMesh) throws

    /// The low-level mesh that this mesh is built from, if any.
    ///
    /// If this mesh is not built from a ``LowLevelMesh``, it returns nil.
    @MainActor @preconcurrency public var lowLevelMesh: LowLevelMesh? { get }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension MeshResource {

    /// A type that determines the configuration for rendering text in 2D,
    /// before it is extruded.
    public struct GenerateTextOptions : Sendable {

        /// The size in points of the frame where the text is laid out.
        ///
        /// The points are scaled at a ratio of 72 points per meter.
        ///
        /// The container frame has the same origin as the local coordinate system.
        ///
        /// - Note: Use a value of `nil` to denote an arbitrarily large frame.
        public var containerFrame: CGRect?

        public init()
    }

    /// A type that determines the extrusion, chamfering,
    /// and material assignment of
    /// an extruded shape.
    public struct ShapeExtrusionOptions : Sendable {

        /// Designates the resolution at which a smooth curve is discretized.
        public enum CurveStrokeResolution : Sendable {

            /// For each span of the curve, generates a uniform number of segments.
            case uniformSegmentsPerSpan(segmentCount: Int)
        }

        /// Determines which part of the extrusion to chamfer.
        public enum ChamferMode : Sendable {

            /// Only chamfer the front of the extrusion.
            case front

            /// Only chamfer the back of the extrusion.
            case back

            /// Chamfer both the front and the back of the extrusion.
            case both

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: MeshResource.ShapeExtrusionOptions.ChamferMode, b: MeshResource.ShapeExtrusionOptions.ChamferMode) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// A type that determines the material assignments
        /// for each part of an extruded shape.
        public struct MaterialAssignment : Sendable {

            /// Creates a material assignment structure that assigns the same
            /// material to all faces.
            ///
            /// - Parameter all: The material index for all mesh faces.
            public init(assignAll all: UInt32)

            /// Creates a material assignment structure with options for each side of an extruded shape.
            ///
            /// - Parameters:
            ///   - front: The material index for the front face of the shape.
            ///   - back: The material index for the back face of the shape.
            ///   - extrusion: The material index for the extruded faces of the shape.
            ///   - frontChamfer: The material index for the chamfered edges between the front and sides of the shape.
            ///   - backChamfer: The material index for the chamfered edges between the back and sides of the shape.
            ///
            /// The default for any omitted parameter is `0`.
            public init(front: UInt32 = 0, back: UInt32 = 0, extrusion: UInt32 = 0, frontChamfer: UInt32 = 0, backChamfer: UInt32 = 0)
        }

        /// The options that determine the way in which to extrude a
        /// swept shape in 3D.
        public enum ExtrusionMethod : Sendable {

            /// Extrudes the shape with a linear extrusion in Z by the desired depth.
            ///
            /// For example an extrusion that has a linear depth of 0.6 meters:
            ///
            /// ```swift
            /// var extrusionOptions = ShapeExtrusionOptions()
            /// extrusionOptions.extrusionMethod = .linear(depth: 0.6)
            /// ```
            ///
            /// ![](generateExtrudedShape-extrusionMethod-linear-red)
            ///
            /// You can also use ``tracePositions(_:)`` an equivalent way.
            ///
            /// ```swift
            /// .tracePositions([
            ///     [0, 0, -depth/2],
            ///     [0, 0,  depth/2]
            /// )
            /// ```
            case linear(depth: Float)

            /// Extrudes the shape by sweeping it along a piecewise-linear curve.
            ///
            /// The curve is defined as the set of line segments
            /// For each edge in the provided curve, the swept shape (e.g. the 2D path provided in
            /// `MeshResource(extruding: Path)`, or text) will be instantiated at the edge's endpoints.
            /// Each instance of the swept shape will be joined together by a strip of geometry.
            ///
            /// The positions are traced in such a way as to avoid twist in the generated 3D shape.  When possible,
            /// the local y-axis of the swept (2D) shape will be aligned with the y-axis of the generated 3D shape.
            ///
            /// For example, extrude a rounded square along the z-axis, while zig-zagging in the y-axis:
            ///
            /// ```swift
            /// // Positions in a zig-zag pattern.
            /// let positions: [SIMD3<Float>] = [
            ///     [0,    0,   0],
            ///     [0, -0.1, 0.2],
            ///     [0,    0, 0.4],
            ///     [0, -0.1, 0.6]
            /// ]
            ///
            /// var extrusionOptions = ShapeExtrusionOptions()
            /// extrusionOptions.extrusionMethod = .tracePositions(positions)
            /// ```
            ///
            /// ![](generateExtrudedShape-extrusionMethod-tracePositions-red)
            case tracePositions([SIMD3<Float>])

            /// Extrudes the shape by sweeping it along a piecewise-linear curve.
            ///
            /// The swept shape (e.g. the 2D path provided in `MeshResource(extruding: Path)`, or text) is instantiated at
            /// each of the provided transforms.  Each instance is joined together by a strip of geometry.
            /// You can specify a different rotation of the swept shape for each point on the curve with `traceTransforms`.
            ///
            /// For example, extrude a rounded square along the z-axis while zig-zagging in the y-axis,
            /// using the default rotation throughout.
            /// This creates a mesh where the swept shapes have the same orientation.
            ///
            /// ```swift
            /// // Positions in a zig-zag pattern.
            /// let positions: [SIMD3<Float>] = [
            ///     [0,    0,   0],
            ///     [0, -0.1, 0.2],
            ///     [0,    0, 0.4],
            ///     [0, -0.1, 0.6]
            /// ]
            ///
            /// var extrusionOptions = ShapeExtrusionOptions()
            /// extrusionOptions.extrusionMethod = .traceTransforms(
            ///     positions.map { position in
            ///         Transform(translation: position).matrix
            ///     }
            /// )
            /// ```
            ///
            /// ![](generateExtrudedShape-extrusionMethod-traceTransforms-red)
            ///
            /// You can also add a rotation for each point in the collection. For example, use the
            /// index to rotate the angle by `.pi / 6` in the z-axis for each position.
            ///
            /// ```swift
            /// extrusionOptions.extrusionMethod = .traceTransforms(
            ///     positions.enumerated().map { index, position in
            ///         Transform(
            ///             rotation: simd_quatf(
            ///                 // Increase the angle depending on index.
            ///                 angle: Float(index) * .pi / 6, axis: [0, 0, 1]
            ///             ),
            ///             translation: position
            ///         ).matrix
            ///     }
            /// )
            /// ```
            ///
            /// ![](generateExtrudedShape-extrusionMethod-traceTransforms-red-rotated)
            case traceTransforms([simd_float4x4])
        }

        /// Creates the shape extrusion options with default values.
        ///
        /// By default, the extrusion method is
        /// ``ExtrusionMethod-swift.enum/linear(depth:)``,
        /// with a depth of 0.25m,
        /// and all sides are assigned the first material.
        public init()

        /// Specifies the extrusion type applied to the swept shape in 3D space.
        ///
        /// For example, use `.linear(depth: 0.25)` to extrude the shape in Z by 0.25 meters.
        public var extrusionMethod: MeshResource.ShapeExtrusionOptions.ExtrusionMethod

        /// The width or depth, in meters, of each chamfered edge.
        public var chamferRadius: Float

        /// Resolution of the shape.
        ///
        /// The default value is ``CurveStrokeResolution/uniformSegmentsPerSpan(segmentCount:)`` with a segment count of 6.
        public var boundaryResolution: MeshResource.ShapeExtrusionOptions.CurveStrokeResolution

        /// Resolution of the chamfer curve.
        ///
        /// The default value is ``CurveStrokeResolution/uniformSegmentsPerSpan(segmentCount:)`` with a segment count of 8.
        public var chamferResolution: MeshResource.ShapeExtrusionOptions.CurveStrokeResolution

        /// Determines if the front, back or both sides should be chamfered.
        ///
        /// The default value is ``ChamferMode-swift.enum/both``.
        public var chamferMode: MeshResource.ShapeExtrusionOptions.ChamferMode

        /// Determines the material assignments for each part of an extruded shape.
        public var materialAssignment: MeshResource.ShapeExtrusionOptions.MaterialAssignment
    }

    /// Synchronously generates a 3D mesh from a string,
    /// with options for text layout and custom extrusions.
    ///
    /// You can use the method to make a 3D mesh of a string,
    /// control the text's layout, chamfers, materials,
    /// and how to extrude the shape into 3D.
    /// 
    /// The generated text is scaled at a ratio of 72 points per meter.
    ///
    /// ![A screenshot of a living room scene with 3D text in the center that reads "Hello, World!", which is primarily a teal color with chamfered, gray edges around the text's faces that face the camera.](meshResource-generateText-extrusion)
    ///
    /// - Parameters:
    ///   - string: A string that contains text for the 3D mesh geometry.
    ///   - textOptions: A configuration for rendering the text in 2D, before extrusion.
    ///   - extrusionOptions: A configuration for extruding the text in 3D.
    @MainActor @preconcurrency public convenience init(extruding string: AttributedString, textOptions: MeshResource.GenerateTextOptions = GenerateTextOptions(), extrusionOptions: MeshResource.ShapeExtrusionOptions = ShapeExtrusionOptions()) throws

    /// Asynchronously generates a 3D mesh from a string,
    /// with options for text layout and custom extrusions.
    ///
    /// You can use the method to make a 3D mesh of a string,
    /// control the text's layout, chamfers, materials,
    /// and how to extrude the shape into 3D.
    ///
    /// The generated text is scaled at a ratio of 72 points per meter.
    ///
    /// ![A screenshot of a living room scene with 3D text in the center that reads "Hello, World!", which is primarily a teal color with chamfered, gray edges around the text's faces that face the camera.](meshResource-generateText-extrusion)
    ///
    /// - Parameters:
    ///   - string: A string that contains text for the 3D mesh geometry.
    ///   - textOptions: A configuration for rendering the text in 2D, before extrusion.
    ///   - extrusionOptions: A configuration for extruding the text in 3D.
    nonisolated public convenience init(extruding string: AttributedString, textOptions: MeshResource.GenerateTextOptions = GenerateTextOptions(), extrusionOptions: MeshResource.ShapeExtrusionOptions = ShapeExtrusionOptions()) async throws
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshResource {

    /// Creates a box mesh from a vector of three scalar values that represent
    /// width, height, and depth, respectively, and radii for the corners.
    ///
    /// - Parameters:
    ///   - size: The length of the box's width, height, and depth, in meters,
    ///   along the x-, y-, and z-axis, respectively.
    ///
    ///   - majorCornerRadius: The radius of each corner's circular arc,
    ///   in meters, orthogonal to the z-axis.
    ///
    ///   - minorCornerRadius: The radius of each corner's circular arc,
    ///   in meters, orthogonal to the x-axis.
    ///
    /// The method centers the box at the entity’s origin and aligns the box's
    /// faces with the coordinate system's axes.
    @MainActor @preconcurrency public static func generateBox(size: SIMD3<Float>, majorCornerRadius: Float = 0.2, minorCornerRadius: Float = 0.05) -> MeshResource

    /// Creates a new cone mesh with the specified dimensions.
    ///
    /// - Parameters:
    ///     - height:   The height of the cone in meters [m].
    ///     - radius:   The radius of the cone in meters [m].
    ///
    /// The cone is centered at the local origin.
    @MainActor @preconcurrency public static func generateCone(height: Float, radius: Float) -> MeshResource

    /// Creates a new cylinder mesh with the specified dimensions.
    ///
    /// - Parameters:
    ///     - height:   The height of the cylinder in meters [m].
    ///     - radius:   The radius of the cylinder in meters [m].
    ///
    /// The cylinder is centered at the local origin.
    @MainActor @preconcurrency public static func generateCylinder(height: Float, radius: Float) -> MeshResource
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshResource {

    /// Generates a MeshResource from a ShapeResource.
    ///
    /// - Parameters:
    ///   - resource: The ShapeResource which will be used for generating the mesh.
    @MainActor @preconcurrency public convenience init(shape resource: ShapeResource)

    /// Generates a MeshResource from a ShapeResource.
    ///
    /// - Parameters:
    ///   - resource: The ShapeResource which will be used for generating the mesh.
    @MainActor @preconcurrency public convenience init(shape resource: ShapeResource) async
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshResource.Part {

    /// Identifier of the skeleton that this mesh part is bound to (if it is skinned).
    public var skeletonID: String?

    /// A buffer of vertex-joint influences which defines how the mesh deforms in response to the
    /// skeleton that it is bound to. Each vertex may be influenced by one or more joints defined
    /// by the skeleton.
    public var jointInfluences: MeshResource.JointInfluences?
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshResource.Contents {

    /// Table of skeletons.
    public var skeletons: MeshSkeletonCollection
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension MeshResource.ShapeExtrusionOptions.ChamferMode : Equatable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension MeshResource.ShapeExtrusionOptions.ChamferMode : Hashable {
}

/// An object that holds a collection of skeletons used by a mesh resource.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct MeshSkeletonCollection {

    /// Number of skeletons.
    public var count: Int { get }

    /// True if there are no skeletons.
    public var isEmpty: Bool { get }

    public init()

    public init(_ skeletons: [MeshResource.Skeleton])

    /// Read a skeleton given its id.
    public subscript(id: String) -> MeshResource.Skeleton? { get }

    /// Add a new skeleton to the container. Returns true if added.
    @discardableResult
    public mutating func insert(_ instance: MeshResource.Skeleton) -> Bool

    /// Update an existing skeleton. The old instance is returned.
    @discardableResult
    public mutating func update(_ instance: MeshResource.Skeleton) -> MeshResource.Skeleton?

    /// Remove a skeleton by id.
    @discardableResult
    public mutating func remove(id: String) -> MeshResource.Skeleton?

    /// Remove all the skeletons.
    public mutating func removeAll()
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshSkeletonCollection : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> MeshResource.Skeleton?

        /// The type of element traversed by the iterator.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias Element = MeshResource.Skeleton
    }

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> MeshSkeletonCollection.Iterator

    /// A type representing the sequence's elements.
    @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
    public typealias Element = MeshResource.Skeleton
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension MeshSkeletonCollection : Collection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> MeshResource.Skeleton { get }

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = DefaultIndices<MeshSkeletonCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<MeshSkeletonCollection>
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension MeshSkeletonCollection : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral: MeshResource.Skeleton...)

    /// The type of the elements of an array literal.
    @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
    public typealias ArrayLiteralElement = MeshResource.Skeleton
}

/// A component that contains a mesh and materials for the visual appearance of an entity.
///
/// This component is a foundational component for all visual content in RealityKit.
/// Use `ModelComponent` to render 3D models by attaching it to any ``Entity``
/// in your RealityKit scene.
///
/// To create a `ModelComponent`, you need a mesh and the number of materials that mesh expects,
/// which is typically one.
///
/// For example, here's how to create a simple blue, metallic box using
/// ``MeshResource/generateBox(size:cornerRadius:)-8em0v``,
/// and ``SimpleMaterial``:
///
/// ```swift
/// let mesh = MeshResource.generateBox(size: 1, cornerRadius: 0.05)
/// let material = SimpleMaterial(color: .blue, isMetallic: true)
///
/// let modelComponent = ModelComponent(mesh: mesh, materials: [material])
///
/// let entity = Entity()
/// entity.components.set(modelComponent)
/// ```
///
/// ![A screenshot of a reflective, metallic blue cube centered on the screen with a plain background.](modelcomponent-cube-simple)
///
/// Make different primitive shapes, like spheres with
/// ``MeshResource/generateSphere(radius:)-5v3w2``,
/// or cylinders with ``MeshResource/generateCylinder(height:radius:)``,
/// or create custom shapes with ``MeshDescriptor``.
/// For more information about materials, see <doc:applying-realistic-material-and-lighting-effects-to-entities>
///
/// > Tip: To load a USDZ or reality file to your app, use an entity initializer such as
/// ``Entity/init(named:in:)`` or ``Entity/init(contentsOf:withName:)``.
///
/// Use other components like
/// ``CollisionComponent``, ``PhysicsBodyComponent``,
/// ``PhysicsMotionComponent``, and ``InputTargetComponent``
/// to make entities interactive and dynamic.
@available(macOS 10.15, iOS 13.0, *)
public struct ModelComponent : Component {

    /// The mesh that defines the model's shape.
    public var mesh: MeshResource

    /// The materials that define the model's visual appearance.
    ///
    /// Each ``RealityKit/MeshResource`` requires a set of materials.
    /// An entity that has no materials renders using a magenta striped material.
    /// To determine the number of materials a mesh requires,
    /// use ``MeshResource/expectedMaterialCount``.
    public var materials: [any Material]

    /// A margin applied to an entity’s bounding box that determines object
    /// visibility.
    ///
    /// When determining which entities are currently visible, RealityKit tests
    /// each entity’s bounding box to see if it overlaps with the camera’s field
    /// of view (also known as the camera’s _frustum_). For efficiency, entities
    /// with a bounding box that don’t overlap the camera’s frustum aren’t
    /// rendered. Use this property to prevent RealityKit from incorrectly
    /// culling entities that use a ``CustomMaterial`` with a geometry modifier
    /// that moves vertices outside of the entity’s bounding box.
    ///
    /// RealityKit adds the value of `boundsMargin` to the bounding box before
    /// determining which entities are visible.
    @available(macOS 12.0, iOS 15.0, *)
    public var boundsMargin: Float

    /// Creates a model component from a mesh and a collection of materials.
    ///
    /// - Parameters:
    ///   - mesh: The mesh that describes the shape of the model.
    ///
    ///   - materials: Materials used to give the mesh a certain visual appearance.
    public init(mesh: MeshResource, materials: [any Material])
}

/// A component that changes how RealityKit renders its entity to help with
/// debugging.
///
/// Attaching a `ModelDebugOptionsComponent` to a ``ModelEntity`` tells
/// RealityKit to change the way it renders that entity based on a specified
/// ``ModelDebugOptionsComponent/visualizationMode-swift.property``. This
/// component isolates individual parts of the rendering process, such as the
/// entity’s transparency or roughness, and displays surface color to help
/// identify visual anomalies.
///
/// To use this component, create a `ModelDebugOptionsComponent` and set its
/// ``ModelDebugOptionsComponent/visualizationMode-swift.property`` to the
/// desired value. Then, set the component as the entity’s
/// ``ModelEntity/modelDebugOptions`` property:
///
/// ```swift
/// if let robot = anchor.findEntity(named: "Robot") as? ModelEntity {
///     let component = ModelDebugOptionsComponent(visualizationMode: .normal)
///     robot.modelDebugOptions = component
/// }
/// ```
///
/// For more information on the visualization modes supported by
/// `ModelDebugOptionsComponent`, see
/// ``ModelDebugOptionsComponent/VisualizationMode-swift.enum``.
///
/// ### Attach a debug component to an entity
///
/// To attach a debug component to a particular entity, traverse the entity tree
/// while passing the component to each child:
///
/// ```swift
/// // Traverse the entity tree to attach a certain debug mode through components.
/// func attachDebug(entity: Entity, debug: ModelDebugOptionsComponent) {
///     entity.components.set(debug)
///     for child in entity.children {
///         attachDebug(entity: child, debug: debug)
///     }
/// }
/// // Respond to a button or UI element.
/// func debugLightingDiffuseButtonCallback() {
///     let debugComponent = ModelDebugOptionsComponent(
///         visualizationMode: .lightingDiffuse
///     )
///     attachDebug(entity: model, debug: debugComponent)
/// }
/// ```
///
/// ### Attach a debug component to a trait
///
/// To attach a debug component based on a trait, traverse the entity tree while
/// checking for ``HasModel`` adoption:
///
/// ```swift
/// func attachDebug(entity: Entity, debug: ModelDebugOptionsComponent) {
///     if let model = entity as? ModelEntity {
///         model.visualizationMode = debug
///     }
///     for child in entity.children {
///         attachDebug(entity: child, debug: debug)
///     }
/// }
/// // Respond to a button or UI element.
/// func debugLightingDiffuseButtonCallback() {
///     let debugComponent = ModelDebugOptionsComponent(
///         visualizationMode: .lightingDiffuse
///     )
///     attachDebug(entity: model, debug: debugComponent)
/// }
/// ```
@available(macOS 11.0, iOS 14.0, *)
public struct ModelDebugOptionsComponent : Component {

    /// The part of the rendering process to display as the entity’s surface
    /// texture.
    public var visualizationMode: ModelDebugOptionsComponent.VisualizationMode { get }

    /// Creates a component that isolates a portion of the rendering process and
    /// displays it as the entity’s surface texture.
    ///
    /// - Parameters:
    ///   - visualizationMode: The portion of the rendering process to use as the
    ///     entity’s surface texture.
    public init(visualizationMode: ModelDebugOptionsComponent.VisualizationMode = .none)

    /// A mode that specifies the portion of the rendering process to isolate
    /// and display for debugging.
    public enum VisualizationMode : String {

        /// A mode that doesn’t display a visualization.
        ///
        /// A ``ModelDebugOptionsComponent`` with a `VisualizationNode` of
        /// `none` has no effect on how RealityKit renders its entity.
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .none)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none)
        case none

        /// A mode that displays the normal vectors as a color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `normal` to an entity to tell RealityKit to draw that entity’s
        /// _surface normal vectors_ as its surface color. A normal vector is an
        /// imaginary line perpendicular to the surface of the object at a
        /// specific point. RealityKit draws a normal vector by using its `X`,
        /// `Y`, and `Z` values as the `R`, `G`, and `B` components of the
        /// color.
        ///
        /// RealityKit calculates normals for entities with a ``VideoMaterial``,
        /// ``UnlitMaterial``, or ``SimpleMaterial`` as well as for entities
        /// imported from a USDZ file. If an entity doesn’t fall within those
        /// parameters, this option has no effect on the rendering.
        ///
        /// Here’s how to enable surface normal visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .normal)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `normal` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a normal visualization, appearing in shades of blue, green, and purple, which is a graphical representation of the calculated normal vector at each point on the TV's surface.](ModelDebugOptionsComponent-VisualizationMode-enum-normal) |
        case normal

        /// A mode that displays the surface tangent vectors as a color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `tangent` to an entity to tell RealityKit to draw that entity’s
        /// calculated tangent vectors as its surface color. A tangent vector is
        /// an imaginary line that touches, but doesn’t intersect with the
        /// surface of the object at a specific point. RealityKit draws a
        /// tangent vector by using its `X`, `Y`, and `Z` values as the `R`,
        /// `G`, and `B` components of the color.
        ///
        /// RealityKit calculates tangents for entities with a
        /// ``VideoMaterial``, ``UnlitMaterial``, or ``SimpleMaterial`` as well
        /// as for entities imported from a USDZ file. If an entity doesn’t fall
        /// within those parameters, this option has no effect on the rendering.
        ///
        /// Here’s how to enable tangent visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .tangent)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `tangent` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a tangent visualization, appearing in shades of yellows, purple, pinks and blues, which is a graphical representation of the calculated surface tangent vector at each point on the TV's surface.](ModelDebugOptionsComponent-VisualizationMode-enum-tangent) |
        case tangent

        /// A mode that displays the surface bitangent vectors as a color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `bitangent` to an entity to tell RealityKit to draw that entity’s
        /// calculated surface bitangent vectors as its surface color. A
        /// bitangent vector is an imaginary line that’s orthagonal to both the
        /// `normal` and `tangent` vectors. RealityKit draws a bitangent vector
        /// by using its `X`, `Y`, and `Z` values as the `R`, `G`, and `B`
        /// components of the color.
        ///
        /// RealityKit calculates bitangents for entities with a
        /// ``VideoMaterial``, ``UnlitMaterial``, or ``SimpleMaterial`` as well
        /// as for entities imported from a USDZ file. If an entity doesn’t fall
        /// within those parameters, this option has no effect on the rendering.
        ///
        /// Here’s how to enable bitangent visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .bitangent)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `bitangent` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a bitangent visualization, appearing in shades of yellows, purple, pinks and blues, which is a graphical representation of the calculated surface tangent vector at each point on the TV's surface.](ModelDebugOptionsComponent-VisualizationMode-enum-bitangent) |
        case bitangent

        /// A mode that displays the entity’s base color with no lighting or
        /// material properties applied.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `baseColor` to an entity to tell RealityKit to draw that entity’s
        /// base color without any shadows, specular highlights, transparency,
        /// or reflections.
        ///
        /// Here’s how to enable base color visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .baseColor)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `baseColor` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a base color visualization, appearing without shadows, reflections, transparency or other effects.](ModelDebugOptionsComponent-VisualizationMode-enum-baseColor) |
        case baseColor

        /// A mode that displays the texture coordinates as a color.
        ///
        /// Adding a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `textureCoordinates` to an entity tells RealityKit to draw that
        /// entity’s UV texture coordinates as its surface color. RealityKit
        /// draws the texture coordinates by using its `U` and `V` values as the
        /// `R` and `G` components of the color, using a value of `0` for the
        /// color’s `B` component.
        ///
        /// RealityKit calculates texture coordinates for entities with a
        /// ``VideoMaterial``, ``UnlitMaterial``, ``SimpleMaterial`` as well as
        /// for entities imported from a USDZ file. If an entity doesn’t fall
        /// within those parameters, this option has no effect on the rendering.
        ///
        /// Here’s how to enable UV texture coordinate visualization for an
        /// entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .textureCoordinates)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `textureCoordinates` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a texture coordinate visualization, appearing in bright shades of yellow, green, and red, which is a graphical representation of the TV’s texture coordinates.](ModelDebugOptionsComponent-VisualizationMode-enum-textureCoordinates) |
        case textureCoordinates

        /// A mode that displays the entity’s calculated color, ignoring
        /// transparency.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `finalColor` to an entity to tell RealityKit to draw that entity’s
        /// calculated surface color with no transparency. This option causes
        /// RealityKit to render the object as if it were fully opaque. For
        /// entities that don’t use transparency, this option has no affect.
        ///
        /// Here’s how to enable final color visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .finalColor)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `finalColor` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a final color visualization, where every surface is fully opaque, and screen cannot be seen through the now opaque glass.](ModelDebugOptionsComponent-VisualizationMode-enum-finalColor) |
        case finalColor

        /// A mode that displays the entity’s calculated transparency as its
        /// surface color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `finalAlpha` to an entity to tell RealityKit to draw that entity’s
        /// alpha value as its surface color. RealityKit draws the alpha value
        /// as a grayscale value from black (`0.0`) to white (`1.0`), meaning
        /// the more transparent a part of the entity is, the darker RealityKit
        /// draws it.
        ///
        /// RealityKit calculates final alpha values for entities with a
        /// ``VideoMaterial``, ``UnlitMaterial``, ``SimpleMaterial`` as well as
        /// for entities imported from a USDZ file. If an entity doesn’t fall
        /// within those parameters, this option has no effect on the rendering.
        ///
        /// Here’s how to enable alpha visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .finalAlpha)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `finalAlpha` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a final alpha visualization, appearing completely white, except for the screen, which is gray, representing the TV's calculated transparency.](ModelDebugOptionsComponent-VisualizationMode-enum-finalAlpha) |
        case finalAlpha

        /// A mode that displays the shininess of a material as the surface
        /// color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `roughness` to an entity to tell RealityKit to draw that entity’s
        /// roughness value as its surface color. A high roughness value
        /// represents a surface with a matte finish, while a low roughness
        /// value represents a shiny or polished surface. When using this mode,
        /// RealityKit draws the roughness value as a grayscale value from black
        /// (`0.0`) to white (`1.0`), meaning the shinier a part of the entity
        /// is, the darker RealityKit draws it.
        ///
        /// RealityKit calculates roughness for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no affect.
        ///
        /// Here’s how to enable roughness visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .roughness)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `roughness` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a roughness visualization, appearing in shades of gray, which is a graphical representation of the TV's surface roughness.](ModelDebugOptionsComponent-VisualizationMode-enum-roughness) |
        case roughness

        /// A mode that displays the reflectiveness of an entity as its surface
        /// color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `metallic` to an entity to tell RealityKit to draw that entity so
        /// the surface color indicates whether that part of the object reflects
        /// the surrounding environment.
        ///
        /// RealityKit draws the quality of _metallicity_ as a grayscale value
        /// from black (`0.0`) to white (`1.0`), rendering the reflective parts
        /// of the entity in white and the nonreflective parts in black.
        ///
        /// RealityKit calculates `metallic` values for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no effect.
        ///
        /// Here’s how to enable `metallic` visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .metallic)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `metallic` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a metallic visualization, appearing mostly in black, with some white representing the metallic parts such as antenna dials, and a metallic frame around the screen.](ModelDebugOptionsComponent-VisualizationMode-enum-metallic) |
        case metallic

        /// A mode that displays the calculated ambient occlusion value as the
        /// surface color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `ambientOcclusion` to an entity to tell RealityKit to draw the
        /// calculated ambient occlusion values as the entity’s surface color.
        /// Ambient occlusion represents the entity’s exposure to ambient light.
        /// RealityKit draws ambient occlusion values as a grayscale value from
        /// black (`0.0`) to white (`1.0`), rendering flat surface areas in
        /// white, and crevices, dents, and recessed areas in darker shades.
        ///
        /// RealityKit calculates ambient occlusion for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no effect.
        ///
        /// Here’s how to enable ambient occlusion visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .ambientOcclusion)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `ambientOcclusion` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using an ambient occlusion visualization, appearing in white and gray, which is a graphical representation of the TV's ambient occlusion values.](ModelDebugOptionsComponent-VisualizationMode-enum-ambientOcclusion) |
        case ambientOcclusion

        /// A mode that displays en entity’s shininess as its surface color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `specular` to an entity to tell RealityKit to draw the entity’s
        /// calculated specularity as its surface color. RealityKit uses
        /// `specular` to calculate bright highlights caused by shiny surfaces
        /// reflecting light. RealityKit draws the specularity value as a
        /// grayscale value from black (`0.0`) to white (`1.0`).
        ///
        /// - Note: In most cases, RealityKit calculates specular highlights
        /// based on an entity’s `roughness` and `metallic` values, and not its
        /// `specular` value, which is usually `0.0`. As a result, this mode
        /// causes most entities to render in solid black. Only entities that
        /// need highlights in addition to the ones RealityKit calculates from
        /// `roughness` and `metallic` need `specular` values greater than zero.
        /// Examples of entities that might use `specular` to create
        /// supplemental highlights are gemstones and cut glass.
        ///
        /// RealityKit calculates specularity for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no effect.
        ///
        /// Here’s how to enable ambient occlusion visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .specular)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `specular` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a specular visualization, appearing in gray, which is a graphical representation of the TV's specular values.](ModelDebugOptionsComponent-VisualizationMode-enum-specular) |
        case specular

        /// A mode that displays the emissive channel of a material as the
        /// surface color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `emissive` to an entity to tell RealityKit to draw that entity’s
        /// calculated emissive values as its surface color. The emissive
        /// channel indicates which parts of the entity emit light. When using
        /// this mode, RealityKit draws any part of the entity that emits light
        /// in the color of the light it emits and draws any part of the entity
        /// that doesn’t emit light as black.
        ///
        /// RealityKit calculates emissive for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no effect.
        ///
        /// Here’s how to enable roughness visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .emissive)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `emissive` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a emissive visualization, appearing in black, except for the screen, which displays the colored test pattern. This is a graphical representation of the TV's emissive values.](ModelDebugOptionsComponent-VisualizationMode-enum-emissive) |
        case emissive

        /// A mode that displays the clearcoat channel of a material as the
        /// surface color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `clearcoat` to an entity to tell RealityKit to draw the entity’s
        /// clearcoat values as its surface color. A clearcoat is a way to
        /// render objects that appear to have a transparent coating or veneer,
        /// such as the surface of a car with a coat of wax or items
        /// shrinkwrapped in clear plastic. RealityKit draws clearcoat values as
        /// a grayscale value from black (`0.0`) to white (`1.0`), with black
        /// representing parts of the entity that don’t use clearcoat.
        ///
        /// RealityKit calculates clearcoat for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no effect.
        ///
        /// Here’s how to enable roughness visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .clearcoat)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `clearcoat` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a clearcoat visualization, appearing in black. This is a graphical representation of the TV's clearcoat values.](ModelDebugOptionsComponent-VisualizationMode-enum-clearcoat) |
        case clearcoat

        /// A mode that displays the clearcoat roughness channel of a material
        /// as the surface color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `clearcoatRoughness` to an entity to tell RealityKit to draw the
        /// entity’s calculated clearcoat roughness as its surface color.
        /// Clearcoat is a way to render objects that have a shiny transparent
        /// coating or veneer, such as the surface of a car with a coat of wax
        /// or items shrinkwrapped in clear plastic. The clearcoat roughness
        /// value represents the shininess of the clearcoat and is only used on
        /// parts of the entity that have a `clearcoat` value greater than zero.
        /// RealityKit draws the clearcoat roughness value as a grayscale value
        /// from black (`0.0`) to white (`1.0`), with lighter areas representing
        /// parts with a shinier clearcoat.
        ///
        /// RealityKit calculates clearcoat roughness for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no effect.
        ///
        /// Here’s how to enable roughness visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .clearcoatRoughness)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `clearcoatRoughness` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a clearcoat roughness visualization, appearing in black. This is a graphical representation of the TV's clearcoat roughness values.](ModelDebugOptionsComponent-VisualizationMode-enum-clearcoatRoughness) |
        case clearcoatRoughness

        /// A mode that displays the intensity of indirect light hitting the
        /// entity as its surface color.
        ///
        /// Add a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `lightingDiffuse` to an entity to tell RealityKit to draw the
        /// intensity of indirect, ambient lighting falling on the entity as its
        /// surface color. RealityKit represents the intensity of indirect light
        /// as a grayscale value from black (`0.0`) to white (`1.0`).
        ///
        /// RealityKit calculates diffuse lighting for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no effect.
        ///
        /// Here’s how to enable roughness visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .lightingDiffuse)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `lightingDiffuse` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a lighting diffuse visualization, appearing in shades of gray, which is a representation of the amount of indirect light falling on the TV at each point.](ModelDebugOptionsComponent-VisualizationMode-enum-lightingDiffuse) |
        case lightingDiffuse

        /// A mode that displays the intensity of direct light hitting the
        /// entity as its surface color.
        ///
        /// Adding a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `lightingSpecular` to an entity tells RealityKit to draw the
        /// intensity of direct light falling on the entity as its surface
        /// color. The calculated value represents direct light hitting the
        /// object from both real-world and virtual lights. RealityKit draws the
        /// light intensity as a grayscale value from black (`0.0`) to white
        /// (`1.0`).
        ///
        /// RealityKit calculates specular lighting for entities with a
        /// ``SimpleMaterial`` and for entities imported from a USDZ file. For
        /// other entities, this option has no effect.
        ///
        /// Here’s how to enable roughness visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .lightingSpecular)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `lightingSpecular` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a specular lighting visualization, appearing in highly reflective shades of gray, which is a representation of the amount of direct light falling on the TV at each point.](ModelDebugOptionsComponent-VisualizationMode-enum-lightingSpecular) |
        case lightingSpecular

        /// A mode that displays the clearcoat normal of a material
        /// as the surface color.
        ///
        /// Adding a ``ModelDebugOptionsComponent`` with a visualization mode of
        /// `clearcoatNormal` to an entity tells RealityKit to draw the world
        /// space clearcoat normal as its surface color. RealityKit draws the xyz value
        /// as a rgb color value after it has been transformed from tangent to world space.
        ///
        /// Here’s how to enable clearcoat normal visualization for an entity:
        ///
        /// ```swift
        /// if let television = try? await ModelEntity(named: "tv_retro") {
        ///     let component = ModelDebugOptionsComponent(visualizationMode: .clearcoatNormal)
        ///     television.components.set(component)
        /// }
        /// ```
        ///
        /// | ``ModelDebugOptionsComponent/VisualizationMode-swift.enum/none`` | `clearcoatNormal` |
        /// |:-:|:-:|
        /// | ![A screenshot of a virtual TV in a visionOS app. The TV is an old-fashioned television displaying a multicolored test pattern. It is drawn with shadows and highlights to appear as realistic as possible.](ModelDebugOptionsComponent-VisualizationMode-enum-none) | ![A screenshot of a virtual TV in a visionOS app. The TV is using a clearcoat normal visualization, appearing in black. This is a graphical representation of the TV's clearcoat normal values.](ModelDebugOptionsComponent-VisualizationMode-enum-clearcoatNormal) |
        @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
        case clearcoatNormal

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 14.0, macOS 11.0, *)
        public typealias RawValue = String

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }
}

@available(macOS 11.0, iOS 14.0, *)
extension ModelDebugOptionsComponent.VisualizationMode : Equatable {
}

@available(macOS 11.0, iOS 14.0, *)
extension ModelDebugOptionsComponent.VisualizationMode : Hashable {
}

@available(macOS 11.0, iOS 14.0, *)
extension ModelDebugOptionsComponent.VisualizationMode : RawRepresentable {
}

/// A representation of a physical object that RealityKit renders and optionally
/// simulates.
///
/// Use one or more model entities to place physical objects in a scene. In
/// addition to the components they inherit from the ``Entity`` class, model
/// entities have geometry, described by their ``ModelComponent``. Model
/// entities acquire the model component by conforming to the ``HasModel``
/// protocol. You specify meshes and materials to control how a model entity
/// appears.
///
/// ![Diagram showing the components present in the model
/// entity.](ModelEntity-1)
///
/// Models respond to physics simulations because they conform to the
/// ``HasPhysics`` protocol. You give them mass and other physical properties
/// with a ``PhysicsBodyComponent`` instance, and then apply forces or impulses.
/// The simulator uses a ``PhysicsMotionComponent`` to manage the linear and
/// angular velocity of the object. Alternatively, you can selectively
/// circumvent the simulation to control position and velocity yourself. Do this
/// for a given model by setting its physics body ``PhysicsBodyComponent/mode``
/// to ``PhysicsBodyMode/kinematic``.
///
/// Models can also collide with one another, and with other entities that
/// conform to the ``HasCollision`` protocol. The ``CollisionComponent``
/// provides parameters that let you manage which models collide with each
/// other. It also lets you control the collision shape, which for performance
/// reasons, is typically simpler than the visual geometry.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class ModelEntity : Entity, HasModel, HasPhysics {

    /// Creates a model entity.
    @MainActor @preconcurrency required public init()

    /// Creates a model entity with a particular mesh and set of materials.
    ///
    /// - Parameters:
    ///   - mesh: A mesh that defines the geometry of the model.
    ///
    ///   - materials: Material resources that define the appearance of the model.
    @MainActor @preconcurrency public init(mesh: MeshResource, materials: [any Material] = [])

    /// Creates a model entity with a particular mesh, set of materials,
    /// collision shape, and mass.
    ///
    /// - Parameters:
    ///   - mesh: A mesh that defines the geometry of the model.
    ///
    ///   - materials: Material resources that define the appearance of the model.
    ///
    ///   - collisionShape: A collection of shape resources that define a composite collision shape.
    ///
    ///   - mass: The mass of the model in kilograms.
    @MainActor @preconcurrency public init(mesh: MeshResource, materials: [any Material] = [], collisionShape: ShapeResource, mass: Float)

    /// Creates a model entity with a particular mesh, set of materials, a
    /// composite collision shape, and mass.
    ///
    /// - Parameters:
    ///   - mesh: A mesh that defines the geometry of the model.
    ///
    ///   - materials: Material resources that define the appearance of the model.
    ///
    ///   - collisionShapes: A collection of shape resources that define a composite collision shape.
    ///
    ///   - mass: The mass of the model in kilograms.
    @MainActor @preconcurrency public init(mesh: MeshResource, materials: [any Material] = [], collisionShapes: [ShapeResource], mass: Float)
}

/// A group that you assign to multiple entities to tell the renderer what
/// order and how to render the entities in the group.
///
/// Each model sort group relates model entities to each other
/// so that you can define what order the renderer draws them.
/// Pass the same model sort group instance to each ``ModelSortGroupComponent``
/// whose entity you want to group, along with an order number for that
/// entity within the group.
///
/// ```swift
/// let group1 = ModelSortGroup()
/// entityA.components.set(
///     ModelSortGroupComponent(group: group1, order: 0)
/// )
/// entityB.components.set(
///     ModelSortGroupComponent(group: group1, order: 1)
/// )
/// ```
///
/// In the example above, the renderer draws `entityA` before `entityB`.
///
/// Each `ModelSortGroup` instance represent a unique group.
///
/// ```swift
/// let group2 = ModelSortGroup()
/// entityC.components.set(
///     ModelSortGroupComponent(group: group2, order: 2)
/// )
/// entityD.components.set(
///     ModelSortGroupComponent(group: group2, order: 3)
/// )
/// ```
///
/// In this example, `entityC` and `entityD` are in the same group as each other,
/// but in a different group than `entityA` and `entityB`.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct ModelSortGroup : Equatable, Sendable {

    /// Creates a model sort group with an optional depth pass.
    ///
    /// - Parameter depthPass: A depth pass instance that tells the group how to
    /// draw the model entity's color relative to its depth.
    public init(depthPass: ModelSortGroup.DepthPass? = nil)

    /// Returns a Boolean that indicates whether the model sort groups are equal.
    /// - Parameters:
    ///   - lhs: A model sort group.
    ///   - rhs: Another model sort group.
    public static func == (lhs: ModelSortGroup, rhs: ModelSortGroup) -> Bool

    /// Returns a Boolean that indicates whether the model sort groups are unequal.
    /// - Parameters:
    ///   - lhs: A model sort group.
    ///   - rhs: Another model sort group.
    public static func != (lhs: ModelSortGroup, rhs: ModelSortGroup) -> Bool

    /// A depth pass that controls when the renderer draws the depth of model
    /// entities in the group relative to their color.
    ///
    /// You can tell the renderer to draw the depth and color together by
    /// setting the value to `nil`.
    public var depthPass: ModelSortGroup.DepthPass? { get }

    /// Options that indicate when the renderer draws a model's depth relative
    /// to its color.
    public enum DepthPass : Sendable {

        /// An option that instructs the renderer to draw the depth of all the
        /// models in the group before it draws any model's color.
        case prePass

        /// An option that instructs the renderer to draw the depth of a model
        /// only after it draws the colors for all the models in the group first.
        case postPass

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ModelSortGroup.DepthPass, b: ModelSortGroup.DepthPass) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A planar placement instance that controls how the renderer draws a model
    /// relative to a planar mesh or a SwiftUI view that's coplanar and overlapping.
    ///
    /// Set to `nil` when the renderer doesn't need planar sort the group.
    /// setting the property to `nil`.
    @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
    public var planarUIPlacement: ModelSortGroup.PlanarUIPlacement? { get }

    /// A set of predefined groups that indicate how the renderer draws a model
    /// relative to a planar mesh or a SwiftUI view that's coplanar and overlapping.
    ///
    /// ### Overview
    /// Use one of the predefined groups ``ModelSortGroup/planarUIInline``, ``ModelSortGroup/planarUIAlwaysInFront``, and ``ModelSortGroup/planarUIAlwaysBehind`` to order virtual content relative to coincidental (coplanar and overlapping) app UI to avoid rendering artifacts.
    ///
    /// ### Placing virtual content relative to app UI
    /// The scenario below shows a museum scene that has a green planar mesh entity, stacked between two
    /// SwiftUI <doc://com.apple.documentation/documentation/swiftui/view> instances
    /// in a <doc://com.apple.documentation/documentation/swiftui/zstack>.
    ///
    /// | **Actual View** | **Layout Illustration** |
    /// |:-:|:-:|
    /// |![A screenshot of a museum scene with ZStack layout of red UI layer first, the greenPlane entity second, and UI with text and symbols third. All 3 are coplanar and overlapping with one another.](modelsortgroupcomponent-planarui-green-inline-dark)|![A screenshot illustrating the relative layout of the 3 layers in this scenario with the red UI layer at the back, greenPlane entity in the middle, and the UI with text and SF Symbol in front.](modelsortgroupcomponent-planarui-layer-breakdown)|
    ///
    /// ```swift
    ///ZStack {
    ///    // A red UI layer.
    ///    Color(.red).opacity(0.5)
    ///        .frame(width: 700, height: 520, alignment: .center)
    ///        .clipShape(RoundedRectangle(cornerRadius: 40))
    ///
    ///    // A green plane with 0.9 opacity.
    ///    RealityView { content in
    ///        let greenPlane = Entity()
    ///        let planeModel = ModelComponent(
    ///            mesh: .generatePlane(width: 0.3, height: 0.2, cornerRadius: 0.01),
    ///            materials: [UnlitMaterial(color: .green)]
    ///        )
    ///        greenPlane.components.set(planeModel)
    ///        greenPlane.components.set(OpacityComponent(opacity: 0.9))
    ///
    ///        // Set the model sort group to planarUIInline.
    ///        let group = ModelSortGroup.planarUIInline
    ///        greenPlane.components.set(ModelSortGroupComponent(group: group, order: 0))
    ///        content.add(greenPlane)
    ///    }
    ///    .frame(depth: 0.0)
    ///
    ///    // A UI with text and SF symbol.
    ///    VStack {
    ///        Text("Hello World").font(.system(size: 50))
    ///        Image(systemName: "visionpro")
    ///            .resizable()
    ///            .foregroundColor(.yellow)
    ///            .aspectRatio(contentMode: .fit)
    ///            .frame(width: 80.0, height: 80.0)
    ///    }
    ///    .frame(width: 460, height: 240, alignment: .center)
    ///    .offset(z: .ulpOfOne)
    ///}
    /// ```
    ///
    /// Use the ``ModelSortGroup/planarUIInline`` group to draw the `greenPlane` entity according to its placement within the `ZStack`. The `greenPlane` draws over the red layer, and the text/symbol draws over the `greenPlane`.
    /// ```swift
    /// let group = ModelSortGroup.planarUIAlwaysInline
    /// greenPlane.components.set(ModelSortGroupComponent(group: group, order: 0))
    /// ```
    /// @Row {
    ///     @Column{}
    ///     @Column(size: 5) {
    ///         @Image(
    ///             source: modelsortgroupcomponent-planarui-green-inline-dark,
    ///             alt: "A screenshot of a museum scene with the red UI layer drawing first, followed by the greenPlane entity drawing second, and the layer with text and symbol drawing third. All 3 are coplanar and overlapping with one another."
    ///         )
    ///     }
    ///     @Column{}
    /// }
    ///
    /// Use the ``ModelSortGroup/planarUIAlwaysInFront`` group to order the `greenPlane` after both UI layers. The `greenPlane` draws over both the text/symbol layer and the red layer.
    ///
    /// ```swift
    /// let group = ModelSortGroup.planarUIAlwaysInFront
    /// greenPlane.components.set(ModelSortGroupComponent(group: group, order: 0))
    /// ```
    /// @Row {
    ///     @Column{}
    ///     @Column(size: 5) {
    ///         @Image(
    ///             source: modelsortgroupcomponent-planarui-green-alwaysinfront-dark,
    ///             alt: "A screenshot of a museum scene with the greenPlane entity drawing after both UI layers. All 3 are coplanar and overlapping with one another."
    ///         )
    ///     }
    ///     @Column{}
    /// }
    ///
    /// Use the ``ModelSortGroup/planarUIAlwaysBehind`` group to order the `greenPlane` before both UI layers. The red layer and the text/symbol layer both draw over the `greenPlane`.
    ///
    /// ```swift
    /// let group = ModelSortGroup.planarUIAlwaysBehind
    /// greenPlane.components.set(ModelSortGroupComponent(group: group, order: 0))
    /// ```
    /// @Row {
    ///     @Column{}
    ///     @Column(size: 5) {
    ///         @Image(
    ///             source: modelsortgroupcomponent-planarui-green-alwaysbehind-dark,
    ///             alt: "A screenshot of a living room scene with the greenPlane entity drawing before both UI layers. All 3 are coplanar and overlapping with one another."
    ///         )
    ///     }
    ///     @Column{}
    /// }
    ///
    @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
    public enum PlanarUIPlacement : Sendable {

        /// Instructs the renderer to draw a model's mesh along with a SwiftUI
        /// layer that's coincident with the mesh.
        case inlineUI

        /// Instructs the renderer to draw a model's mesh in front of a SwiftUI
        /// layer that's coincident with the mesh.
        case alwaysInFront

        /// Instructs the renderer to draw a model's mesh behind a SwiftUI
        /// layer that's coincident with the mesh.
        case alwaysBehind

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ModelSortGroup.PlanarUIPlacement, b: ModelSortGroup.PlanarUIPlacement) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension ModelSortGroup {

    /// A model sort group that instructs the renderer to draw a model's mesh
    /// along with a SwiftUI layer that's coincident with the mesh. See ``ModelSortGroup/PlanarUIPlacement-swift.enum`` for usage.
    public static let planarUIInline: ModelSortGroup

    /// A model sort group that instructs the renderer to draw a model's mesh
    /// in front of a SwiftUI layer that's coincident with the mesh. See ``ModelSortGroup/PlanarUIPlacement-swift.enum`` for usage.
    public static let planarUIAlwaysInFront: ModelSortGroup

    /// A model sort group that instructs the renderer to draw a model's mesh
    /// behind a SwiftUI layer that's coincident with the mesh. See ``ModelSortGroup/PlanarUIPlacement-swift.enum`` for usage.
    public static let planarUIAlwaysBehind: ModelSortGroup
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ModelSortGroup.DepthPass : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ModelSortGroup.DepthPass : Hashable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension ModelSortGroup.PlanarUIPlacement : Equatable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension ModelSortGroup.PlanarUIPlacement : Hashable {
}

/// A component that configures the rendering order for an entity's model.
///
/// ## Overview
///
/// Tell the renderer to draw a model on top of another by adding
/// a `ModelSortGroupComponent` instance to both entities.
///
/// A model sort group component gives you control over the rendering
/// order for entities within the same ``ModelSortGroup``.
/// You can configure the group to render models in a specific order,
/// even if that order contradicts their relative positions to each other in the
/// scene.
///
/// The scenario below shows a living room scene that has two rectangular cuboids
/// which overlap and form the shape of a plus symbol.
/// The blue cuboid is opaque and taller than it is wide.
/// The red cuboid is transparent and wider than it is tall.
///
/// @Row {
///     @Column{}
///     @Column(size: 5) {
///         @Image(
///             source: modelsortgroupcomponent-not-set,
///             alt: "A screenshot of a living room scene with two rectangular cuboids that overlap. The vertical cuboid is an opaque blue, and the horizontal cuboid is a translucent red. The red cuboid appears in front of the blue one, which gives the area where they overlap a purple hue."
///         )
///     }
///     @Column{}
/// }
///
/// The sections below demonstrate how to change the default behavior by
/// configuring the properties of the model sort group component.
///
/// ### Set the draw order
///
/// To tell the renderer to draw the red cuboid
/// before the blue one, add a `ModelSortGroupComponent` instance to both
/// cuboids.
/// Then set both component's ``order`` property so that the red cuboid's
/// component has a smaller value than the blue cuboid's component.
///
/// ```swift
/// let redCuboid = Entity()
/// let blueCuboid = Entity()
///
/// // ...
///
/// // Create a group for both cuboids.
/// let group = ModelSortGroup(depthPass: nil)
///
/// let redSortComponent = ModelSortGroupComponent(
///     group: group,
///     order: 1
/// )
///
/// redCuboid.components.set(redSortComponent)
///
/// let blueSortComponent = ModelSortGroupComponent(
///     group: group,
///     order: 2
/// )
/// blueCuboid.components.set(blueSortComponent)
/// ```
///
/// The renderer draws the red cuboid first and then doesn't draw the part of the
/// blue cuboid where the two cuboids overlap because the nearest face of the
/// red cuboid in the overlapping area is closer to the camera.
///
/// @Row {
///     @Column{}
///     @Column(size: 5) {
///         @Image(
///             source: modelsortgroupcomponent-none-redfirst,
///             alt: "A screenshot of a living room scene with two rectangular cuboids that overlap. The vertical cuboid is an opaque blue, and the horizontal cuboid is a translucent red. The red cuboid appears in front of the blue one, and in the area where they overlap, the blue cuboid isn't visible, which reveals the scene's background through the red one."
///         )
///     }
///     @Column{}
/// }
///
/// If the renderer instead draws the blue cuboid first,
/// and the translucent red cuboid second,
/// the blue cuboid is once again visible in the overlapping area.
///
/// @Row {
///     @Column{}
///     @Column(size: 5) {
///         @Image(
///             source: modelsortgroupcomponent-none-bluefirst,
///             alt: "A screenshot of a living room scene with two rectangular cuboids that overlap. The vertical cuboid is an opaque blue, and the horizontal cuboid is a translucent red. The red cuboid appears in front of the blue one, which gives the area where they overlap a purple hue."
///         )
///     }
///     @Column{}
/// }
///
/// Rendering the blue cuboid produces the same result as if the two cuboids
/// weren't in a sort group.
///
///
/// ### Set the depth pass
///
/// In the examples in the previous section, the renderer draws each model's
/// depth and color together, at the same time.
///
/// To draw each entity's color and depth separately, set the ``ModelSortGroup/depthPass-swift.property`` property of a ``ModelSortGroup`` instance, which changes the rendering sequence
/// for each model in the group that either draws their colors first or their
/// depths first.
///
/// - Tip: You can also set the property with the ``ModelSortGroup/init(depthPass:)`` initializer.
///
/// To draw each model's color on the first pass and then the depth, set the
/// property to ``ModelSortGroup/DepthPass-swift.enum/postPass``.
///
/// ```swift
/// // Draw the color first, depth second.
/// let group = ModelSortGroup(depthPass: .postPass)
/// ```
///
/// | **Red First** | **Blue First** |
/// |:-:|:-:|
/// | ![A screenshot of a living room scene with two rectangular cuboids that overlap. The vertical cuboid is an opaque blue, and the horizontal cuboid is a translucent red. The red cuboid appears behind the blue one.](modelsortgroupcomponent-postpass-redfirst) | ![A screenshot of a living room scene with two rectangular cuboids that overlap. The vertical cuboid is an opaque blue, and the horizontal cuboid is a translucent red. The red cuboid appears in front of the blue one, which gives the area where they overlap a purple hue.](modelsortgroupcomponent-postpass-bluefirst) | |
///
/// The ``ModelSortGroup/DepthPass-swift.enum/postPass`` option tells the
/// renderer to draw entities in reverse order, which gives the effect that the
/// last model it draws appears in front.
///
/// The depth pass ``ModelSortGroup/DepthPass-swift.enum/prePass`` draws each
/// entity's depth on the first pass, then their color.
///
/// ```swift
/// // Draw the depth first, color second.
/// let group = ModelSortGroup(depthPass: .prePass)
/// ```
///
/// | **Red First** | **Blue First** |
/// |:-:|:-:|
/// | ![A screenshot of a living room scene with two rectangular cuboids that overlap. The vertical cuboid is an opaque blue, and the horizontal cuboid is a translucent red. The red cuboid appears in front of the blue one, and in the area where they overlap, the blue cuboid isn't visible, which reveals the scene's background through the red one.](modelsortgroupcomponent-prepass-redfirst) | ![A screenshot of a living room scene with two rectangular cuboids that overlap. The vertical cuboid is an opaque blue, and the horizontal cuboid is a translucent red. The red cuboid appears in front of the blue one, and in the area where they overlap, the blue cuboid isn't visible, which reveals the scene's background through the red one.](modelsortgroupcomponent-prepass-bluefirst) |
///
/// The ``ModelSortGroup/DepthPass-swift.enum/prePass`` option tells the renderer
/// to write the depth buffer for the group's entities first.
/// The renderer doesn't draw the blue cuboid in the overlapping area, regardless
/// of order, because the red cuboid has a shallower depth in all parts of the
/// overlapping area.
///
/// - Tip: Check out <doc://com.apple.documentation/documentation/visionos/swift-splash>
/// which has an implementation that leverages `ModelSortGroupComponent`.
///
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct ModelSortGroupComponent : Component {

    /// Creates a model sort group component.
    ///
    /// - Parameters:
    ///   - group: A group the component's entity belongs to.
    ///   - order: An integer value in the range `(Int32.min, Int32.max)` that
    ///   represents when the renderer draws the model relative to other the
    ///   models in its group.
    ///
    /// - Warning: Don't pass `Int32.max` or `Int32.min` to the `order` parameter
    /// because the framework reserves these as sentinel values, and using them
    /// may trigger erratic behavior.
    public init(group: ModelSortGroup, order: Int32)

    /// The group that the component's entity belongs to.
    ///
    /// The renderer only draws entities with the same ``ModelSortGroup`` relative to each other.
    ///
    /// - Note: Membership only applies to the entity that directly owns this component,
    /// but not to its descendants.
    public var group: ModelSortGroup

    /// An integer value that represents when the renderer draws the model
    /// relative to other the models in its group.
    ///
    /// The renderer draws models in ascending order, starting with the
    /// components with the smallest value.
    /// You can tell the renderer that it only needs to order entities by their
    /// depths by setting the component's ``order`` property to the sam value
    /// for those entities.
    ///
    /// - Warning: Don't set `order` to `Int32.max` or `Int32.min` because the
    /// framework reserves these as sentinel values, and assigning their values
    /// may trigger erratic behavior.
    public var order: Int32
}

/// An opaque token used to check the networking compatibility between two peers
/// in a multipeer connection.
///
/// ``RealityKit`` apps running on incompatible versions of RealityKit can’t
/// connect and sync over the network. Use ``NetworkCompatibilityToken`` to
/// check if two peers can synchronize ``RealityKit`` scenes over the network.
/// With this class, host applications can prevent incompatible clients from
/// joining.
///
/// Client apps send a copy of their token to the host when attempting to
/// connect to a host app. The host deserializes that token and calls
/// ``NetworkCompatibilityToken/compatibilityWith(_:)`` on
/// ``NetworkCompatibilityToken``.``NetworkCompatibilityToken/local``. If
/// ``NetworkCompatibilityToken/compatibilityWith(_:)`` returns
/// ``NetworkCompatibilityToken/Compatibility/compatible``,
/// the client and host can sync and it’s safe to proceed with the connection.
/// If ``NetworkCompatibilityToken/compatibilityWith(_:)`` returns any other
/// value, the client that’s attempting to connect is incompatible and should be
/// ignored.
///
/// A client running a
/// <doc://com.apple.documentation/documentation/multipeerconnectivity/mcnearbyserviceadvertiser>,
/// for example, writes its own token into its
/// <doc://com.apple.documentation/documentation/multipeerconnectivity/mcnearbyserviceadvertiser/1406967-discoveryinfo>
/// dictionary. When the host (running a
/// <doc://com.apple.documentation/documentation/multipeerconnectivity/mcnearbyservicebrowser>)
/// discovers that client, it deserializes the client’s token from the
/// `discoverInfo` dictionary and uses it to check compatibility before inviting
/// the client to the
/// <doc://com.apple.documentation/documentation/multipeerconnectivity/mcsession>.
///
/// - Note: Even if two peers are compatible, scene synchronization can fail for
/// other reasons, such as packet corruption or a poor network connection.
@available(macOS 10.15.4, iOS 13.4, *)
final public class NetworkCompatibilityToken : Codable {

    /// Indicates whether two devices running RealityKit are compatible and able
    /// to connect and sync scenes.
    public enum Compatibility {

        /// An indication that the compared devices are running compatible
        /// versions of RealityKit.
        case compatible

        /// An indication that two peers running incompatible versions of
        /// RealityKit can’t sync.
        ///
        /// The ``NetworkCompatibilityToken/compatibilityWith(_:)`` method
        /// returns this value when two devices have different OS versions and
        /// there has been a significant change in networking protocol between
        /// those releases.
        case sessionProtocolVersionMismatch

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NetworkCompatibilityToken.Compatibility, b: NetworkCompatibilityToken.Compatibility) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A token containing the local peer’s networking compatibility info.
    public static let local: NetworkCompatibilityToken

    /// Creates a new instance from a decoder.
    ///
    /// Throws an error if reading from `decoder` fails, or if the data is
    /// corrupted or otherwise invalid.
    ///
    /// - Parameters:
    ///   - decoder: The decoder to read data from.
    required public init(from decoder: any Decoder) throws

    /// Writes the token’s data into an encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container. This function throws an
    /// <doc://com.apple.documentation/documentation/swift/error> if any values
    /// are invalid for the given encoder’s format.
    ///
    /// - Parameters:
    ///   - encoder:  The encoder to write data to.
    final public func encode(to encoder: any Encoder) throws

    /// Compares network compatibility tokens between the local device and
    /// another device.
    ///
    /// - Parameters:
    ///   - otherToken: The token for the remote client against which the local
    ///     device checks compatibility
    ///
    /// - Returns: Returns
    ///     ``NetworkCompatibilityToken/Compatibility/compatible`` if the local
    ///     client and the remote client represented by `otherToken` can be synced.
    ///     Any other result indicates that the two devices are incompatible and you
    ///     shouldn’t proceed with the connection.
    final public func compatibilityWith(_ otherToken: NetworkCompatibilityToken) -> NetworkCompatibilityToken.Compatibility
}

@available(macOS 10.15.4, iOS 13.4, *)
extension NetworkCompatibilityToken.Compatibility : Equatable {
}

@available(macOS 10.15.4, iOS 13.4, *)
extension NetworkCompatibilityToken.Compatibility : Hashable {
}

/// An invisible material that hides objects rendered behind it.
///
/// Add an `OcclusionMaterial` to a model by setting it as one of the
/// ``ModelComponent/materials`` in a ``ModelComponent``.
///
/// ```swift
/// let model = ModelComponent(
///     mesh: .generateBox(size: 1),
///     materials: [OcclusionMaterial()]
/// )
/// smallBoxEntity.components.set(model)
/// ```
///
/// For example, on the left is a case of two cubes, the larger red cube is slightly further from the camera and has a simple material.
/// The slightly smaller and closer cube has no material in the left image and an occlusion material on the right image.
///
/// | No material | Occlusion material |
/// |:-:|:-:|
/// | ![A screenshot of two cubes in a living room scene. One cube is red and is slightly further from the camera, the other cube has a magenta striped material, is slightly closer to the camera, and is smaller than the red cube.](occlusionmaterial-not-applied) | ![A screenshot of a partial red shape in a living room scene. The shape is of a cube with a cut-out in the shape of another cube slightly towards the upper right corner of the cube.](occlusionmaterial-applied)
@available(macOS 10.15, iOS 13.0, *)
public struct OcclusionMaterial : Material, Sendable {
}

extension OcclusionMaterial {

    @available(visionOS 1.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    public init()
}

/// Property that controls how RealityKit reads depth  for this material
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension OcclusionMaterial {

    /// A boolean value that determines whether this material performs the depth test by reading RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will depth test each of their fragments when being rendered.
    /// If an object that writes depth is in front of this material, this material will be hidden.
    ///
    /// If false, meshes with this material will ignore the depth test, and always render all of their
    /// fragments during their draw call, regardless of the positioning of other objects in the scene.
    /// Note that other objects may still render on top of this material, depending on draw order.
    ///
    /// The default value is true.
    public var readsDepth: Bool
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension OcclusionMaterial {

    /// An alias for the cull mode object that’s appropriate for this material class.
    public typealias FaceCulling = MaterialParameterTypes.FaceCulling

    /// A process in which the system specifies polygons to remove before
    /// rendering a mesh using this material.
    ///
    /// To improve performance, RealityKit culls polygons, or faces, that it
    /// determines won’t be visible. Discarding faces that aren’t part of the
    /// final render eliminates the need to do any calculations for those
    /// faces.
    ///
    /// RealityKit recognizes when a face aims toward the camera (a front face)
    /// or away from the camera (a back face). This value controls the type of
    /// faces RealityKit culls.
    ///
    /// This value defaults to ``MaterialParameterTypes/FaceCulling/back``,
    /// which means RealityKit removes faces that point away from the camera.
    /// Most of the time, this is the correct behavior, because back faces are
    /// usually obscured by other front-facing polygons.
    ///
    /// You can change the culling behavior to cull front faces instead or to
    /// turn off face culling altogether, but be aware that turning off face
    /// culling results in less efficient rendering and may negatively impact
    /// your app’s frame rate.
    public var faceCulling: OcclusionMaterial.FaceCulling
}

/// A component that controls the opacity of an entity and its descendants.
///
/// An opacity component multiplies its
/// ``OpacityComponent/opacity`` property with
/// all visual components the entity and its descendants own.
/// Visual components include ``ModelComponent`` and ``ParticleEmitterComponent``.
/// If a descendant also has its own opacity component, the system combines the two opacities by multiplying their values.
/// The system repeats this pattern for the entity's entire family tree.
///
/// For example, the following code sets a component's opacity value
/// to `0.5` for its entity:
///
/// ```swift
/// // Load a USDZ model from a file, or create a model component.
/// let robot = try await Entity(named: "vintage_robot")
///
/// // Create an opacity component.
/// let opacityComponent = OpacityComponent(opacity: 0.5)
///
/// // Apply the opacity component to the robot entity.
/// robot.components.set(opacityComponent)
/// ```
///
/// The following images show robot models with opacity values of `1.0` and `0.5`.
///
/// | `opacity: 1` | `opacity: 0.5` |
/// |:-:|:-:|
/// | ![An image of an opaque vintage-style toy robot in a living room scene. The robot is facing about 45 degrees to the left and down from the viewer's perspective.](opacitycomponent-full) | ![An image of a translucent vintage-style toy robot in a living room scene. The robot is facing about 45 degrees to the left and down from the viewer's perspective.](opacitycomponent-half) |
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct OpacityComponent : Component, Equatable {

    /// The floating-point value the renderer applies to
    /// an entity and its descendants.
    ///
    /// The opacity is a float within the inclusive range `[0.0, 1.0]`,
    /// where `0.0` is completely transparent and `1.0` is completely opaque.
    public var opacity: Float

    /// Creates a new opacity component.
    ///
    /// - Parameters:
    ///   - opacity: A floating-point value in the range `[0.0, 1.0]`, where `0.0` is completely transparent and `1.0` is completely opaque.
    public init(opacity: Float = 1.0)

    /// Returns a Boolean value that indicates whether two opacity components are equal.
    ///
    /// - Parameters:
    ///   - lhs: An opacity component.
    ///   - rhs: Another opacity component.
    ///
    /// If the member values of each component match,
    /// the components are equal.
    public static func == (lhs: OpacityComponent, rhs: OpacityComponent) -> Bool
}

/// An animation that revolves an entity around its origin.
///
/// This class moves an entity in a circular path by gradually adjusting its
/// local transform. The animation sets the entity's initial position with
/// ``OrbitAnimation/startTransform`` and rotates it around the point `(0,` `0,`
/// `0)`. The ``OrbitAnimation/axis`` specifies which cartesian axis around
/// which to rotate. The full orbit completes after ``OrbitAnimation/duration``
/// lapses.
///
/// If the target entity contains child entities, the target entity orbits the
/// children.
///
/// ### Revolve an entity around its origin
///
/// The following code creates an animation that orbits an entity
/// around the y-axis 3 times over `6` seconds.
///
/// ```swift
/// let yAxis: SIMD3<Float> = [0, 1, 0]
/// let startingPosition: SIMD3<Float> = [0.25, 0, 0]
///
/// let orbit = OrbitAnimation(
///     name: "orbit",
///     duration: 6,
///     axis: yAxis,
///     startTransform: Transform(translation: startingPosition),
///     spinClockwise: false,
///     orientToPath: true,
///     rotationCount: 3,
///     bindTarget: .transform
/// )
/// ```
///
/// The newly created animation can be trimmed after creation, to last only 4 seconds.
///
/// ```swift
/// // Create an animation clip that skips the first two seconds.
/// let trimmed = orbit.trimmed(start: 2)
/// ```
///
/// Use ``AnimationResource/generate(with:)`` to convert `OrbitAnimation`
/// to an ``AnimationResource`` that can be applied to your entity with ``Entity/playAnimation(_:transitionDuration:blendLayerOffset:separateAnimatedValue:startsPaused:clock:)``.
///
/// @Video(
///     source: orbitanimation-red-box,
///     alt: "A screen recording of a red cube in a living room scene. The cube is slightly offset from the center, and rotates around the y-axis twice at a rate of 1 rotation every 2 seconds.",
///     poster: orbitanimation-red-box-poster
/// )
@available(macOS 12.0, iOS 15.0, *)
public struct OrbitAnimation : AnimationDefinition {

    /// A textual name for the animation.
    public var name: String

    /// The order in which the framework composites the animation.
    ///
    /// The framework applies multiple animations on the same target in
    /// ascending order of this property’s value. Animations in a lower layer
    /// run before animations in a higher layer. Animations that share the same
    /// value apply in the order that they execute.
    public var blendLayer: Int32

    /// A textual name that identifies the particular property that animates.
    public var bindTarget: BindTarget

    /// An option that determines which data displays outside of the normal
    /// duration.
    ///
    /// This property determines what to display when the framework samples the
    /// animation outside of the range defined by its underlying duration. The
    /// animation applies this property when:
    ///
    /// - Playback progresses toward, but hasn't yet reached, a nonzero
    /// ``AnimationDefinition/offset``. - A range determined by
    /// ``AnimationDefinition/trimStart``, ``AnimationDefinition/trimEnd``, or
    /// ``AnimationDefinition/trimDuration`` exceeds the animation's underlying
    /// duration.
    public var fillMode: AnimationFillMode

    /// A Boolean value that indicates whether the animation builds on the
    /// current state of the target entity or resets the state before running.
    public var additive: Bool

    /// The optional time, in seconds, at which the animation plays.
    ///
    /// This property is `nil` by default, which plays the animation with `time`
    /// = `0`. If you set a value, the animation edits the duration according to
    /// the specified beginning time.
    ///
    /// If you set a negative value for this property, the duration increases
    /// and the additional animation data fills in based on the
    /// ``AnimationView/fillMode`` you choose.
    public var trimStart: TimeInterval?

    /// The optional time, in seconds, at which the animation stops.
    ///
    /// This property is `nil` by default, which plays the animation until
    /// `time` = ``AnimationGroup/duration``. If you set a value, the animation
    /// edits the duration according to the specified ending time.
    public var trimEnd: TimeInterval?

    /// An optional duration that overrides the calculated duration.
    ///
    /// The framework calculates ``OrbitAnimation/duration``, but you can set
    /// this property to override it. This property is `nil` by default, which
    /// indicates that the animation stops after one play that spans
    /// ``OrbitAnimation/duration``.
    ///
    /// If you set a value for this property and both
    /// ``OrbitAnimation/trimStart`` and ``OrbitAnimation/trimEnd`` are `nil`,
    /// the animation observes this property as an edited duration.
    ///
    /// A value greater than ``OrbitAnimation/duration`` causes the animation to
    /// repeat, applying the characteristics defined by
    /// ``OrbitAnimation/repeatMode``. Assign this property
    /// <doc://com.apple.documentation/documentation/swift/double/1849607-greatestfinitemagnitude>
    /// to repeat indefinitely.
    public var trimDuration: TimeInterval?

    /// The time, in seconds, at which the animation begins within the duration.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no offset. Setting a value for this property moves the animation data
    /// along the timeline and doesn't change timing. If you set a
    /// ``OrbitAnimation/fillMode`` other than ``AnimationFillMode/none``, the
    /// animation fills the vacant area created by the offset according to the
    /// characteristics of the specified fill mode.
    public var offset: TimeInterval

    /// An amount of time that lapses before the animation plays.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no delay. If you set a value for this property, the animation plays from
    /// its start time after the specified delay lapses.
    ///
    /// During the delayed time, the animation doesn't update. However, to fill
    /// the delayed time with some portion of animation, set a negative
    /// ``OrbitAnimation/trimStart`` instead and choose a
    /// ``OrbitAnimation/fillMode`` that displays the desired portion of
    /// animation.
    public var delay: TimeInterval

    /// A factor that changes the animation’s rate of playback.
    ///
    /// The default value is `1.0`, which doesn’t alter the animation’s
    /// duration. A value of `2.0` indicates that the duration is half the
    /// normal rate. A value of `0.5` indicates that the duration is twice the
    /// normal rate. Negative values play the animation in reverse.
    ///
    /// This property doesn’t affect the animation’s
    /// ``FromToByAnimation/delay``.
    public var speed: Float

    /// An option that determines how the animation repeats.
    ///
    /// If you call ``OrbitAnimation/trimmed(start:end:duration:)`` with a
    /// `start` or `end` that lies outside of the timeline defined by
    /// ``OrbitAnimation/duration``, the animation fills the additional playback
    /// by applying this property.
    public var repeatMode: AnimationRepeatMode

    /// The elapsed time for one complete rotation.
    ///
    /// The framework sets a value for this property depending on the underlying
    /// animation data and the specified ``OrbitAnimation/speed``.
    ///
    /// You can override the default duration by defining
    /// ``OrbitAnimation/trimStart``, ``OrbitAnimation/trimEnd``, or
    /// ``OrbitAnimation/trimDuration``.
    public var duration: TimeInterval

    /// A 3D vector that points in the direction of the axis around which to
    /// rotate.
    ///
    /// You can rotate an object around any axis. For example, if you set a `1`
    /// in the vector's x-coordinate, rotation occurs around the x-axis, as in
    /// the following code.
    ///
    /// ```swift
    /// orbitAnimation.axis = SIMD3<Float>(x: 1.0, y: 0.0, z: 0.0)
    /// ```
    public var axis: SIMD3<Float>

    /// The pose of the orbiting object at the start of the animation.
    public var startTransform: Transform

    /// A Boolean value that indicates whether the object orbits the center
    /// point in the clockwise direction.
    ///
    /// The default value is `true`, which indicates that the rotation occurs in
    /// the clockwise direction. Set the value to `false` to cause the object to
    /// orbit the center point counterclockwise.
    public var spinClockwise: Bool

    /// A Boolean value that indicates whether the orbiting object updates its
    /// orientation during the animation to orient itself along the rotation
    /// path.
    ///
    /// The default value of this property is `false`.
    public var orientToPath: Bool

    /// The number of times to rotate the target entity before stopping.
    public var rotationCount: Float

    /// Creates an animation that revolves an entity around its origin.
    ///
    /// - Parameters:
    ///   - name: A textual name for the animation.
    ///
    ///   - duration: The elapsed time for one complete rotation.
    ///
    ///   - axis: A 3D vector that points in the direction of the axis around
    ///     which to rotate.
    ///
    ///   - startTransform: The orbiting entity's beginning position.
    ///
    ///   - spinClockwise: A Boolean value that indicates whether the object
    ///     orbits the center point in the clockwise direction.
    ///
    ///   - orientToPath: A Boolean value that indicates whether the orbiting
    ///     object updates its orientation during the animation to orient itself
    ///     along the rotation path.
    ///
    ///   - rotationCount: The number of times to rotate the target entity before
    ///     stopping.
    ///
    ///   - bindTarget: A textual name that identifies the particular property
    ///     that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation
    ///     into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     builds on the current state of the target entity or resets the state
    ///     before running.
    ///
    ///   - trimStart: The optional time, in seconds, at which the animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that lapses before the animation plays.
    ///
    ///   - speed: A factor that changes the animation’s rate of playback.
    public init(name: String = "", duration: TimeInterval = 1.0, axis: SIMD3<Float> = .init(x: 0.0, y: 1.0, z: 0.0), startTransform: Transform = .identity, spinClockwise: Bool = true, orientToPath: Bool = false, rotationCount: Float = 1.0, bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], isAdditive: Bool = false, trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1)
}

/// An action which animates the transform of an entity to revolve around a specified pivot entity.
///
/// This action moves an entity in a circular path by gradually adjusting its local transform.
/// The animation starts from the entity's initial transform, and rotates around the pivot
/// entity. The ``OrbitEntityAction/orbitalAxis`` specifies which cartesian axis
/// to rotate around in world space.. The axis is resolved when the action starts to produce an axis
/// of rotation around the pivot entity.
/// The full orbit completes after the action has ended.
///
/// The example below creates an animation that orbits an entity 
/// around the x-axis two times for five seconds.
///
/// ```swift
/// // Create an action entity resolution to the pivot entity 
/// // that exists in the scene.
/// let pivotEntity: ActionEntityResolution = .entityNamed("pivotEntity")
///
/// // Create an action that performs an orbit around the 
/// // specified pivot entity.
/// let orbitEntityAction = OrbitEntityAction(pivotEntity: pivotEntity,
///                                           revolutions: 2,
///                                           orbitalAxis: [0, 1, 0],
///                                           isOrientedToPath: true,
///                                           isAdditive: false)
///
/// // A five second animation that plays an animation causing the entity to
/// // orbit around the pivot.
/// let orbitAnimation = try AnimationResource
///     .makeActionAnimation(for: orbitEntityAction,
///                          duration: 5.0,
///                          bindTarget: .transform)
///
/// // Play the five second orbit animation.
/// entity.playAnimation(orbitAnimation)
/// ```
///
/// - Note: Use the ``OrbitEntityAction/orbitalAxis`` to determine whether the entity
///         orbits clockwise or counterclockwise.
///
/// - Important: This action directly animates the ``BindTarget/transform`` on the bound entity.
///              Ensure a correct bind target is supplied when creating the animation.
///
/// - Important: For a successful orbit, ensure the translational offset between the target and pivot entity are not parallel to the orbit axis.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct OrbitEntityAction : EntityAction, Codable {

    /// The entity that the target entity orbits around.
    public var pivotEntity: ActionEntityResolution

    /// The number of rotations to complete before stopping.
    public var revolutions: Float

    /// A vector that describes the axis of rotation (in world space).
    ///
    /// The default value of this property is `[0, 1, 0]`, meaning the rotation
    /// occurs around the y-axis.
    public var orbitalAxis: SIMD3<Float>

    /// A Boolean value that indicates whether the orbiting
    /// object updates its orientation during the animation to orient itself
    /// along the rotation path.
    ///
    /// The default value of this property is `false`.
    public var isOrientedToPath: Bool

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public var animatedValueType: (any AnimatableData.Type)? { get }

    /// A Boolean value that indicates whether the animation system additively blends the action's output with the base value.
    public var isAdditive: Bool

    /// Creates a new orbit entity action.
    ///
    /// - Parameters:
    ///   - pivotEntity: The pivot entity that the targeted entity will orbit.
    ///   - revolutions: The number of rotations to complete before stopping.
    ///   - orbitalAxis: A vector that describes the axis of rotation (in world space).
    ///   - isOrientedToPath: Indicates whether the orbiting target entity updates
    ///                   its orientation during the animation to orient itself
    ///                   along the rotation path.
    ///   - isAdditive:A Boolean value that indicates whether the animation system additively blends
    ///                the action's output with the base value.
    public init(pivotEntity: ActionEntityResolution, revolutions: Float, orbitalAxis: SIMD3<Float> = [0, 1, 0], isOrientedToPath: Bool = false, isAdditive: Bool = false)

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A component that defines an orthographic virtual camera and its settings.
///
/// Each scene requires a camera that defines the viewpoint from which RealityKit renders the scene.
/// The orthographic camera renders the entities in the scene without the perspective of depth,
/// meaning faraway objects don't look smaller.
///
/// To create an orthographic camera, add this component to an entity.
/// | **Perspective camera** | **Orthographic camera** |
/// |:-:|:-:|
/// | ![An illustration of three cubes, one behind the other, rendered with a perspective camera. The cube farthest away appears smaller than the closest one.](orthocamera-perspective-cubes) | ![A screenshot of three cubes, one behind the other, rendered with a orthographic camera. The cubes appear the same size, regardless of their distance.](orthocamera-orthographic-cubes) |
///
/// You can add an `OrthographicCameraComponent` to an entity's component set, and orient that
/// entity so that it looks at a specific target using ``Entity/look(at:from:upVector:relativeTo:)``.
///
///
/// ```swift
/// // Create an entity to hold the camera component.
/// let cameraEntity = Entity()
///
/// // Create an orthographic camera component and add it to the camera entity.
/// cameraEntity.components.set(OrthographicCameraComponent())
///
/// // Set the entity's position and orientation to look at the subject.
/// let cameraPosition: SIMD3<Float> = [0, 1, 3]
///
/// // The subject in this case is the origin.
/// let target: SIMD3<Float> = .zero
/// cameraEntity.look(at: target, from: cameraPosition, relativeTo: nil)
///
/// // Add the camera entity to your scene.
/// content.add(cameraEntity)
/// ```
///
///  In AR scenarios, the system provides the camera automatically;
///  however, in non-AR scenarios, the app needs to set the camera.
///  If the app doesn't provide a camera, the system uses the default perspective camera.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct OrthographicCameraComponent : Component, Equatable {

    /// The minimum distance in meters from the camera that the camera can see.
    ///
    /// The value defaults to `1.0` centimeter. Use a value greater than `0.0`
    /// and less than the value of ``far``.
    /// The renderer clips any surface closer than the `near` point.
    public var near: Float

    /// The maximum distance in meters from the camera that the camera can see.
    ///
    /// The value defaults to `1000.0`.
    /// Use a value greater than the value of ``near``.
    /// The renderer clips any surface beyond the `far` point.
    public var far: Float

    /// A floating-point value the camera uses to scale entities.
    public var scale: Float

    /// The direction in which the camera applies scaling.
    public var scaleDirection: CameraFieldOfViewOrientation

    /// Creates an orthographic camera component with default values.
    public init()

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: OrthographicCameraComponent, b: OrthographicCameraComponent) -> Bool
}

/// A reference to general-purpose entity parameters for animations.
///
/// Subscript this structure to access a particular property by name. The return
/// value is ``BindableValue`` `<T>`, where `T` is one of the adopting
/// ``BindableData`` types.
///
/// As a reference, this structure doesn’t exhibit copy-on-write behavior.
@available(macOS 12.0, iOS 15.0, *)
public struct ParameterSet {

    /// Provides a bindable value for the given name.
    @MainActor @preconcurrency public subscript<T>(name: String, type: T.Type = T.self) -> BindableValue<T>? where T : BindableData
}

/// A component that emits particles.
///
/// To learn how to use `ParticleEmitterComponent` in your app, see <doc:simulating-particles-in-your-visionos-app>.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct ParticleEmitterComponent : Component, Codable {

    /// Options for the shape of an emitter, used by the emitterShape property.
    public enum EmitterShape : Codable, Equatable, Hashable {

        /// Particles emit from a single point on the origin.
        case point

        /// Particles emit from a 2D plane that aligns with the x and z axes.
        case plane

        /// Particles emit from an axis-aligned box that is centered on the origin.
        case box

        /// Particles emit from a sphere centered on the origin.
        case sphere

        /// Particles emit from a cone with its apex pointing up along the y-axis, centered on the origin.
        case cone

        /// Particles emit from a cylinder oriented vertically along the y-axis, centered on the origin.
        case cylinder

        /// Particles emit from a torus oriented along the z-axis, centered on the origin.
        case torus

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ParticleEmitterComponent.EmitterShape, b: ParticleEmitterComponent.EmitterShape) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Options for the location on the shape of where particles are born, used by the birthLocation property.
    public enum BirthLocation : Codable, Equatable, Hashable {

        /// Particles emit from the surface of the shape.
        case surface

        /// Particles emit from the internal volume of the shape.
        case volume

        /// Particles emit from the vertices of the shape. `count` is the number of vertices in each direction, the distribution depends on the EmitterShape chosen.
        case vertices(count: SIMD3<UInt>)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ParticleEmitterComponent.BirthLocation, b: ParticleEmitterComponent.BirthLocation) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Options for the initial direction of each emitted particle, used by the birthDirection property.
    public enum BirthDirection : Codable, Equatable, Hashable {

        /// Ignores the orientation from the emitter entity's transform.
        case world

        /// Emit direction is relative to the orientation of the emitter entity's transform.
        case local

        /// The emitting direction for each particle is along the surface normal vector at the point where the particle is emitted.
        case normal

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ParticleEmitterComponent.BirthDirection, b: ParticleEmitterComponent.BirthDirection) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Options for when the spawned effect starts, used by the spawnOccasion property.
    public enum SpawnOccasion : Codable, Equatable, Hashable {

        /// The spawned effect starts at the birth time of a main particle.
        case onBirth

        /// The spawned effect starts on every tick of the engine.
        case onUpdate

        /// The spawned effect starts at the death of a main particle.
        case onDeath

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ParticleEmitterComponent.SpawnOccasion, b: ParticleEmitterComponent.SpawnOccasion) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Options for particle simulation space
    public enum SimulationSpace : Codable {

        case local

        case global

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ParticleEmitterComponent.SimulationSpace, b: ParticleEmitterComponent.SimulationSpace) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Options for the particle simulation state, used by the `simulationState` property.
    public enum SimulationState : Codable {

        /// Simulation will play.
        case play

        /// Simulation will pause.
        case pause

        /// Simulation will stop and clear existing particles.
        case stop

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ParticleEmitterComponent.SimulationState, b: ParticleEmitterComponent.SimulationState) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public init()

    /// The shape of the region of space where the system spawns new particles. Defaults to plane.
    public var emitterShape: ParticleEmitterComponent.EmitterShape

    /// The possible locations for newly spawned particles, relative to the emitter shape. Defaults to surface.
    public var birthLocation: ParticleEmitterComponent.BirthLocation

    /// The possible initial directions for newly spawned particles, relative to the emitter shape.Defaults to normal.
    public var birthDirection: ParticleEmitterComponent.BirthDirection

    /// The emitter shape size in meters.
    public var emitterShapeSize: SIMD3<Float>

    /// The initial speed, in meters per second, for newly spawned particles. Defaults to 0.5.
    public var speed: Float

    /// Defines a plus/minus range (in meters per second) from which a value is randomly selected to offset particle speed.
    public var speedVariation: Float

    /// The direction particles are emitted when birthDirection is set to World or Local. Defaults to (0.0, 1.0, 0.0).
    public var emissionDirection: SIMD3<Float>

    /// Radial sweep angle for sphere, cylinder, cone, and torus emitter shapes. Defaults to 2 * pi.
    public var radialAmount: Float

    /// Radius of the torus' emitter shape tube. Defaults to 0.25.
    public var torusInnerRadius: Float

    /// Determines when main particles emit spawn particles. Defaults to `onDeath`.
    public var spawnOccasion: ParticleEmitterComponent.SpawnOccasion

    /// How much of the parent particle's velocity to inherit. Defaults to 1.
    public var spawnVelocityFactor: Float

    /// Amount a spawned particle spreads away from its parent particle, works in conjunction with the spawn particle's `spreadingAngle`. Defaults to 0.
    public var spawnSpreadFactor: Float

    /// Defines a plus/minus range from which a value is randomly selected to offset Spawn Spread Factor.
    public var spawnSpreadFactorVariation: Float

    /// Whether or not the spawnedEmitter's color should be overriden by the mainEmitter's color at the time of the spawning.
    public var spawnInheritsParentColor: Bool

    /// Controls particle simulation state: playing, paused or stopped. Defaults to `play`.
    public var simulationState: ParticleEmitterComponent.SimulationState

    /// Determines if the entity's transformation also affects the particles.
    public var particlesInheritTransform: Bool

    /// Field Simulation Space, either local or global
    public var fieldSimulationSpace: ParticleEmitterComponent.SimulationSpace

    /// Restarts the emission of particles. Requires the component to be re-assigned to the entity to take effect.
    public mutating func restart()

    /// Disables/enables particle emission, independent of `simulationState`. Existing particles will not be affected.
    public var isEmitting: Bool

    /// Emits burstCount particles on the next update call.
    public mutating func burst()

    /// Number of particles to emit in a single burst. Defaults to 100.
    public var burstCount: Int

    /// Defines a plus/minus range from which a value is randomly selected to offset `burstCount`.
    public var burstCountVariation: Int

    /// Particle attributes affecting the main particles of the base simulation.
    public var mainEmitter: ParticleEmitterComponent.ParticleEmitter

    /// Attributes affecting secondary particles spawned from the main simulation.
    public var spawnedEmitter: ParticleEmitterComponent.ParticleEmitter?

    public struct ParticleEmitter {

        /// Options for specifying the axis about which the particle will be oriented, used by the `billboardMode` property.
        public enum BillboardMode : Codable, Equatable, Hashable {

            /// Each particle is oriented to face the camera.
            case billboard

            /// Each particle is oriented to face the camera but remains fixed about the y-axis
            case billboardYAligned

            /// The axis about which the particle will be oriented is the given `axis`. The `variation` is a unit multiplier that determines how far from the given axis the particle is allowed to actually be oriented.
            case free(axis: SIMD3<Float>, variation: Float)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: ParticleEmitterComponent.ParticleEmitter.BillboardMode, b: ParticleEmitterComponent.ParticleEmitter.BillboardMode) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// Options for the curve of opacity change over the lifetime of the particle, used by the opacityOverLife property.
        public enum OpacityCurve : Codable, Equatable, Hashable {

            case linearFadeOut

            case linearFadeIn

            case gradualFadeInOut

            case quickFadeInOut

            case easeFadeIn

            case easeFadeOut

            case constant

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: ParticleEmitterComponent.ParticleEmitter.OpacityCurve, b: ParticleEmitterComponent.ParticleEmitter.OpacityCurve) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// Options for the rendering order of particles, used by the sortingMode property.
        public enum SortOrder : Codable, Equatable, Hashable {

            /// Particles further from camera are rendered first.
            case increasingDepth

            /// Particles closer to camera are rendered first
            case decreasingDepth

            /// Particles with lower IDs are rendered first
            case increasingID

            /// Particles with higher IDs are rendered first
            case decreasingID

            /// Particles emitted more recently are rendered before particles emitted earlier.
            case increasingAge

            /// Particles emitted earlier are rendered before particles emitted more recently.
            case decreasingAge

            /// Particles are not sorted; they may be rendered in any order.
            case unsorted

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: ParticleEmitterComponent.ParticleEmitter.SortOrder, b: ParticleEmitterComponent.ParticleEmitter.SortOrder) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// Options for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.
        public enum BlendMode : Codable, Equatable, Hashable {

            /// The source and destination colors are blended by multiplying the source alpha value.
            case alpha

            /// The particle fully occludes anything drawn before it.
            case opaque

            /// The source and destination colors are added together.
            case additive

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: ParticleEmitterComponent.ParticleEmitter.BlendMode, b: ParticleEmitterComponent.ParticleEmitter.BlendMode) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// Structure used to define properties of the sprite sheet, used by imageSequence.
        public struct ImageSequence : Codable, Equatable, Hashable {

            /// Number of rows in the sprite sheet.
            public var rowCount: Int

            /// Number of columns in the sprite sheet.
            public var columnCount: Int

            /// First frame of the sprite sheet animation.
            public var initialFrame: Int

            /// Defines a plus/minus range (in frames) from which a value is randomly selected to offset `initialFrame`.
            public var initialFrameVariation: Int

            /// Number of sprite sheet frames to play per second.
            public var frameRate: Float

            /// Defines a plus/minus range (in frames per second) from which a value is randomly selected to offset `frameRate`.
            public var frameRateVariation: Float

            /// How the effect timeline is played.
            public var animationMode: ParticleEmitterComponent.ParticleEmitter.ImageSequence.AnimationRepeatMode

            /// Options for how the effect timeline is played, used by the animationMode property.
            public enum AnimationRepeatMode : Codable, Equatable, Hashable {

                /// The image sequence plays once and then stops.
                case playOnce

                /// The image sequence loops repeatedly.
                case looping

                /// The image sequence plays through and then plays in reverse order and then repeats.
                case autoReverse

                /// Returns a Boolean value indicating whether two values are equal.
                ///
                /// Equality is the inverse of inequality. For any values `a` and `b`,
                /// `a == b` implies that `a != b` is `false`.
                ///
                /// - Parameters:
                ///   - lhs: A value to compare.
                ///   - rhs: Another value to compare.
                public static func == (a: ParticleEmitterComponent.ParticleEmitter.ImageSequence.AnimationRepeatMode, b: ParticleEmitterComponent.ParticleEmitter.ImageSequence.AnimationRepeatMode) -> Bool

                /// Hashes the essential components of this value by feeding them into the
                /// given hasher.
                ///
                /// Implement this method to conform to the `Hashable` protocol. The
                /// components used for hashing must be the same as the components compared
                /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
                /// with each of these components.
                ///
                /// - Important: In your implementation of `hash(into:)`,
                ///   don't call `finalize()` on the `hasher` instance provided,
                ///   or replace it with a different instance.
                ///   Doing so may become a compile-time error in the future.
                ///
                /// - Parameter hasher: The hasher to use when combining the components
                ///   of this instance.
                public func hash(into hasher: inout Hasher)

                /// Encodes this value into the given encoder.
                ///
                /// If the value fails to encode anything, `encoder` will encode an empty
                /// keyed container in its place.
                ///
                /// This function throws an error if any values are invalid for the given
                /// encoder's format.
                ///
                /// - Parameter encoder: The encoder to write data to.
                public func encode(to encoder: any Encoder) throws

                /// The hash value.
                ///
                /// Hash values are not guaranteed to be equal across different executions of
                /// your program. Do not save hash values to use during a future execution.
                ///
                /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
                ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
                ///   The compiler provides an implementation for `hashValue` for you.
                public var hashValue: Int { get }

                /// Creates a new instance by decoding from the given decoder.
                ///
                /// This initializer throws an error if reading from the decoder fails, or
                /// if the data read is corrupted or otherwise invalid.
                ///
                /// - Parameter decoder: The decoder to read data from.
                public init(from decoder: any Decoder) throws
            }

            public init()

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: ParticleEmitterComponent.ParticleEmitter.ImageSequence, b: ParticleEmitterComponent.ParticleEmitter.ImageSequence) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// The number of particles emitted over the emission duration. Defaults to 100.
        public var birthRate: Float

        /// Defines a plus/minus range from which a value is randomly selected to offset `birthRate`.
        public var birthRateVariation: Float

        /// A factor that slows particles relative to their velocity. Defaults to 0.
        public var dampingFactor: Float

        /// The constant acceleration vector, in meters per second squared, applied to all particles in the system.
        public var acceleration: SIMD3<Float>

        /// The range, in radians, of randomized initial particle directions as radians describing the size of the spreading cone. Defaults to 0.
        public var spreadingAngle: Float

        /// The rendered size, in units of the scene’s world coordinate space, of the particle image. Value is the half-extent of the particle's quad. Defaults to 0.02.
        public var size: Float

        /// Defines a plus/minus range from which a value is randomly selected to offset `size`.
        public var sizeVariation: Float

        /// The mode defining whether and how particles orient towards the camera. Defaults to `billboardYAligned`.
        public var billboardMode: ParticleEmitterComponent.ParticleEmitter.BillboardMode

        /// The mass, in grams, of each particle in the system. Defaults to 1.
        public var mass: Float

        /// Defines a plus/minus range (in grams) from which a value is randomly selected to offset `mass`.
        public var massVariation: Float

        /// The duration, in seconds, for which each particle is rendered before being removed from the scene. Defaults to 1.
        public var lifeSpan: Double

        /// Defines a plus/minus range (in seconds) from which a value is randomly selected to offset `lifeSpan`. Defaults to 0.2.
        public var lifeSpanVariation: Double

        /// The rotation angle, in radians, of newly spawned particles. Defaults to 0.
        public var angle: Float

        /// Defines a plus/minus range (in radians) from which a value is randomly selected to offset `angle`.
        public var angleVariation: Float

        /// The initial spin rate, in radians per second, of newly spawned particles. Defaults to 0.
        public var angularSpeed: Float

        /// Defines a plus/minus range (in radians per second) from which a value is randomly selected to offset `angularSpeed`.
        public var angularSpeedVariation: Float

        /// The curve of opacity change over the lifetime of the particle. Defaults to `quickFadeInOut`.
        public var opacityCurve: ParticleEmitterComponent.ParticleEmitter.OpacityCurve

        /// At the end of the particle lifespan, the particle's size will be it's initial size times this multiplier. Defaults to 0.1.
        public var sizeMultiplierAtEndOfLifespan: Float

        /// How quickly or slowly particle size changes over its lifetime — a value of 1 is linear, values below 1 transition quicker, values above 1 transition slower.
        public var sizeMultiplierAtEndOfLifespanPower: Float

        /// How quickly the color evolves from its start to its end color — a value of 1 is a linear transition, values below 1 transition quicker, values over 1 transition slower.
        public var colorEvolutionPower: Float

        /// Strength of the noise (turbulence) fields affecting particle motion. Defaults to 0.
        public var noiseStrength: Float

        /// Scale of the noise (turbulence) patterns. Defaults to 1.
        public var noiseScale: Float

        /// Determines how fast the noise field changes over time. Defaults to 0.
        public var noiseAnimationSpeed: Float

        /// The particles are attracted to the `attractionCenter` by this amount. Defaults to 0.
        public var attractionStrength: Float

        /// The spot that the particles are attracted to. In local space. Defaults to (1, 1, 0).
        public var attractionCenter: SIMD3<Float>

        /// Strength of the vortex forces affecting particle motion. Defaults to 0.
        public var vortexStrength: Float

        /// Direction vector of the vortex axis. Defaults to (0, 1, 0).
        public var vortexDirection: SIMD3<Float>

        /// Determines if particles are affected by scene lighting.
        public var isLightingEnabled: Bool

        /// How much a particle's shape is stretched along its velocity direction (Billboard particles only).
        public var stretchFactor: Float

        /// How overlapping particles are sorted before rendering. Defaults to `increasingDepth`.
        public var sortOrder: ParticleEmitterComponent.ParticleEmitter.SortOrder

        /// How overlapping particles are composited together. Defaults to `alpha`.
        public var blendMode: ParticleEmitterComponent.ParticleEmitter.BlendMode

        /// The image that each particle will use (requires pre-multiplied RGB values). Defaults to a white circular texture.
        public var image: TextureResource?

        /// Determines if the particle image is a sprite sheet (used for animation).
        public var imageSequence: ParticleEmitterComponent.ParticleEmitter.ImageSequence?

        public init()
    }

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ParticleEmitterComponent.SimulationSpace : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ParticleEmitterComponent.SimulationSpace : Hashable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ParticleEmitterComponent.SimulationState : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ParticleEmitterComponent.SimulationState : Hashable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ParticleEmitterComponent.ParticleEmitter : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A virtual camera that establishes the rendering perspective.
///
/// During an AR session, RealityKit automatically uses the device’s camera to
/// define the perspective from which to render the scene. When rendering a
/// scene outside of an AR session (with the view’s
/// ``ARView/cameraMode-swift.property`` property set to
/// ``ARView/CameraMode-swift.enum/nonAR``), RealityKit uses a
/// ``PerspectiveCamera`` instead. You can add a perspective camera anywhere in
/// your scene to control the point of view. If you don't explicitly provide
/// one, RealityKit creates a default camera for you.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class PerspectiveCamera : Entity, HasPerspectiveCamera {

    /// Creates a perspective camera entity.
    @MainActor @preconcurrency required public init()
}

/// A component that defines a virtual camera and its controls.
///
/// Each scene requires a camera that defines the viewpoint from
/// which RealityKit renders the scene.
/// In RealityKit, the default camera is a *perspective camera*,
/// which simulates the way real cameras and human vision work.
/// Entities that are farther away from the camera render smaller.
///
/// For an alternative camera solution, see ``OrthographicCameraComponent``.
///
/// To create a perspective camera, add this component to an entity.
///
/// ```swift
/// let cameraEntity = Entity()
///
/// // Place the camera 2 meters along the z-axis,
/// // looking at the scene origin.
/// let cameraPosition: SIMD3<Float> = [0, 0, 2]
/// cameraEntity.look(at: .zero, from: cameraPosition, relativeTo: nil)
///
/// cameraEntity.components.set(PerspectiveCameraComponent())
/// ```
///
/// A `PerspectiveCameraComponent` defines the camera settings for a
/// perspective camera, such as the ``fieldOfViewInDegrees``.
/// The entity’s ``HasTransform/transform`` defines the camera entity’s viewpoint and direction.
/// The direction it points is along the entity's negative z-axis.
///
///  In AR scenarios, the system provides the camera automatically;
///  however, in non-AR scenarios, the app needs to set the camera.
///  If the app doesn't provide a camera, the system uses the default perspective camera.
@available(macOS 10.15, iOS 13.0, *)
public struct PerspectiveCameraComponent : Component, Equatable {

    /// The minimum distance in meters from the camera that the camera can see.
    ///
    /// The value defaults to `1.0` centimeter. Use a value greater than `0.0`
    /// and less than the value of ``PerspectiveCameraComponent/far``.
    /// The renderer clips any surface closer than the `near` point.
    public var near: Float

    /// The maximum distance in meters from the camera that the camera can see.
    ///
    /// The value defaults to `infinity`. Use a value greater than the
    /// value of ``PerspectiveCameraComponent/near``.
    /// The renderer clips any surface beyond the `far` point.
    public var far: Float

    /// The camera's total field of view in degrees.
    ///
    /// This property contains the entire field of view for the
    /// camera in degrees.
    ///
    /// When you set ``fieldOfViewOrientation`` to
    /// ``CameraFieldOfViewOrientation/vertical``,
    /// this value sets the vertical field of view for the camera in degrees,
    /// and the system automatically calculates the horizontal field of view
    /// to fit the aspect ratio of the device's screen.
    ///
    /// This property defaults to `60` degrees.
    public var fieldOfViewInDegrees: Float

    /// The orientation with which the system uses to apply the field-of-view degrees.
    ///
    /// The value of this property determines the orientation that
    /// the system uses to apply the ``fieldOfViewInDegrees`` value.
    ///
    /// This property defaults to ``CameraFieldOfViewOrientation/vertical``.
    @available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
    public var fieldOfViewOrientation: CameraFieldOfViewOrientation

    /// Creates a perspective camera component from near and far clipping planes and a field of view.
    ///
    /// - Parameters:
    ///   - near: The minimum distance in meters from the camera that the camera
    ///     can see.
    ///
    ///   - far: The maximum distance in meters from the camera that the camera
    ///     can see.
    ///
    ///   - fieldOfViewInDegrees: The camera's field of view, in degrees.
    public init(near: Float = 0.01, far: Float = .infinity, fieldOfViewInDegrees: Float = 60.0)

    /// Creates a perspective camera component from near and far clipping planes,
    /// a field of view, and an orientation.
    ///
    /// - Parameters:
    ///   - near: The minimum distance in meters from the camera that the camera can see.
    ///   - far: The maximum distance in meters from the camera that the camera can see.
    ///   - fieldOfViewInDegrees: The camera's field of view in degrees.
    ///   - fieldOfViewOrientation: The orientation of the field of view.
    @available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
    public init(near: Float = 0.01, far: Float = .infinity, fieldOfViewInDegrees: Float = 60.0, fieldOfViewOrientation: CameraFieldOfViewOrientation = .vertical)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PerspectiveCameraComponent, b: PerspectiveCameraComponent) -> Bool
}

/// A material that simulates the appearance of real-world objects.
///
/// In RealityKit, a _material_ is an object that defines the surface properties
/// of a rendered 3D object. A Physically Based Rendering (PBR) material is a
/// material that closely approximates the way light reflects off of real-world
/// objects. Use ``PhysicallyBasedMaterial`` to create highly realistic-looking
/// objects for your AR scenes.
///
/// Many of the properties for ``PhysicallyBasedMaterial`` provide the option to
/// use more than one type of data to specify that property. You can set an
/// object’s ``PhysicallyBasedMaterial/baseColor-swift.property`` using a
/// specific color for the entire material, or you can use an image that UV-maps
/// on to the entity.
///
/// ``PhysicallyBasedMaterial`` includes all material properties supported by
/// USDZ. On iOS 15 and later, RealityKit automatically uses
/// ``PhysicallyBasedMaterial`` when importing an entity from a USDZ file.
///
/// For more information on using ``PhysicallyBasedMaterial``, see
/// <doc:applying-realistic-material-and-lighting-effects-to-entities>.
@available(macOS 12.0, iOS 15.0, *)
public struct PhysicallyBasedMaterial : Material {

    /// Creates a physically based material.
    public init()

    /// The color of an entity unmodified by lighting.
    ///
    /// The base color of an entity is either a solid color or a UV-mapped image
    /// texture. This property represents the color of the entity before
    /// RealityKit applies any lighting or rendering calculations.
    ///
    /// To determine the appearance of the entity, RealityKit modifies the
    /// entity’s base color using its material properties and the light sources
    /// in the scene.
    ///
    /// You can define an entity’s base color using a `CGColor`, a UV-mapped
    /// image texture, or both. If you only provide a color, RealityKit uses
    /// that as the base color for the entire entity. If you specify only an
    /// image texture, it applies that texture as the base color of the entity.
    /// If you provide both a color and a texture, RealityKit tints the image
    /// texture using the color.
    ///
    /// Here’s an example of using a single color to specify base color:
    ///
    /// ```swift
    /// var material = PhysicallyBasedMaterial()
    /// material.baseColor = PhysicallyBasedMaterial.BaseColor(tint:.red)
    /// ```
    ///
    /// The following example demonstrates how to use an image to specify base
    /// color:
    ///
    /// ```swift
    /// var material = PhysicallyBasedMaterial()
    ///
    ///     // Load entity_basecolor.png from the app's bundle.
    ///     if let baseResource = try? TextureResource.load(named: "entity_basecolor") {
    ///         // Create a material parameter and assign it.
    ///         let baseColor = MaterialParameters.Texture(baseResource)
    ///         material.baseColor = PhysicallyBasedMaterial.BaseColor(texture:baseColor)
    ///     }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var baseColor: PhysicallyBasedMaterial.BaseColor

    /// The reflectiveness of an entity.
    ///
    /// The `metallic` property represents the reflectiveness of an entity. Use
    /// this property to specify whether the entity displays metallic qualities
    /// and reflects the surrounding environment, or displays dielectric
    /// qualities and doesn’t reflect the environment.
    ///
    /// ![An illustration showing two spheres rendered in RealityKit. The sphere
    /// on the left is shiny but dielectric so doesn’t reflect the surrounding
    /// environment other than specular highlights from the visible light. The
    /// sphere on the right is metallic and reflects all of the surrounding
    /// environment like a mirror
    /// ball.](PhysicallyBasedMaterial-metallic-swift-property-1)
    ///
    /// Specify this property using a
    /// <doc://com.apple.documentation/documentation/swift/float> to represent a
    /// uniform reflectiveness for the entire entity. You an also use a
    /// UV-mapped grayscale image to represent the reflectiveness of different
    /// parts of the entity. When using an image, black pixels represent areas
    /// that are dielectric, while white pixels represents areas that are
    /// completely metallic and reflective.
    ///
    /// If you initialize this property with a color image, rather than a
    /// grayscale image, RealityKit only uses the intensity of the image’s red
    /// channel.
    ///
    /// The following example specifies the metallic qualities of an entity
    /// using a single float value:
    ///
    /// ```swift
    /// material.metallic = 1.0
    /// ```
    ///
    /// The following example specifies the metallic qualities of an entity
    /// using a UV-mapped image:
    ///
    /// ```swift
    /// // Load a texture resource from a file.
    /// let metalResource = try TextureResource.load(named: "entity_metallic")
    ///
    /// // Set the texture to the metallic property.
    /// let metallic = MaterialParameters.Texture(metalResource)
    /// material.metallic = PhysicallyBasedMaterial.Metallic(texture: metallic)
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var metallic: PhysicallyBasedMaterial.Metallic

    /// The amount the surface of the 3D object scatters reflected light.
    ///
    /// The `roughness` property represents how much the surface of the entity
    /// scatters light it reflects. A material with a high roughness has a matte
    /// appearance, while one with a low roughness has a shiny appearance.
    ///
    /// ![An illustration showing three spheres with different amounts of
    /// roughness. The sphere on the left has a low roughness and looks like
    /// shiny, polished plastic. The sphere in the middle has a matte appearance
    /// with very soft specular highlights. The sphere on the right has no
    /// highlights
    /// whatsoever.](PhysicallyBasedMaterial-roughness-swift-property-1)
    ///
    /// Specify this property using a
    /// <doc://com.apple.documentation/documentation/swift/float> to represent a
    /// uniform `roughness` for the entire entity, or a UV-mapped grayscale
    /// image that uses shades of gray to represent the roughness of different
    /// parts of the entity. When using an image, black pixels represent areas
    /// that have a low roughness and appear shiny, while white represents areas
    /// that have a high roughness and display a matte finish.
    ///
    /// If you initialize this property with a color image rather than a
    /// grayscale image, RealityKit only uses the intensity of the image’s red
    /// channel.
    ///
    /// The following example uses a single value to specify roughness:
    ///
    /// ```swift
    /// material.roughness = PhysicallyBasedMaterial.Roughness(floatLiteral: 0.0)
    /// ```
    ///
    /// The following example uses an image to specify roughness:
    ///
    /// ```swift
    /// if let roughnessResource = try? TextureResource.load(named:
    /// "entity_roughness") {
    ///     let roughness = MaterialParameters.Texture(roughnessResource)
    ///     material.roughness = PhysicallyBasedMaterial.Roughness(texture:roughness)
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var roughness: PhysicallyBasedMaterial.Roughness

    /// The color of the light the entity emits.
    ///
    /// With Physically Based Rendering (PBR), you can give entities in
    /// RealityKit the appearance of emitting light. Use this property to
    /// simulate real-world objects that glow, such as objects with LEDs or
    /// computer screens. To enable light emission from a material, set
    /// ``PhysicallyBasedMaterial/emissiveIntensity`` to a value greater than
    /// zero, then specify a color for the emitted light other than black using
    /// this property. You can specify a single emissive color for the entire
    /// material, or use a UV-mapped image texture to use different colors for
    /// different parts of the entity.
    ///
    /// The following example uses a single color for the entire material:
    ///
    /// ```swift
    /// material.emissiveIntensity = 2.0
    /// self.emissiveColor = PhysicallyBasedMaterial.EmissiveColor(color: .red)
    /// ```
    ///
    /// This example uses an image map to control the light emission color:
    ///
    /// ```swift
    /// if let emissiveResource = try? TextureResource.load(named:"entity_emissive") {
    ///     let emissiveMap = MaterialParameters.Texture(emissiveResource)
    ///     material.emissiveColor = .init(texture: emissiveMap)
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var emissiveColor: PhysicallyBasedMaterial.EmissiveColor

    /// The intensity of light emitted by the entity.
    ///
    /// To make a material _emissive_ and appear to emit light, set this
    /// property to a value greater than zero and set
    /// ``PhysicallyBasedMaterial/emissiveColor-swift.property`` to a value
    /// other than black. RealityKit multiplies
    /// ``PhysicallyBasedMaterial/emissiveColor-swift.property`` by this value,
    /// so the higher the value, the more intense the entity’s emission of
    /// light.
    ///
    /// You can set this property to values greater than `1.0`.
    @available(macOS 12.0, iOS 15.0, *)
    public var emissiveIntensity: Float

    /// The specular highlight applied to the entity.
    ///
    /// In Physically Based Rendering (PBR), specular highlights primarily come
    /// from the object’s ``PhysicallyBasedMaterial/roughness-swift.property``
    /// value. RealityKit automatically renders materials that have a low
    /// roughness value with specular highlights based on the environment
    /// lighting and the shape of the entity. As a result, for most materials,
    /// you won’t need to specify a `specular` value when using
    /// ``PhysicallyBasedMaterial``.
    ///
    /// For some types of dielectric (nonmetallic) materials, like facet-cut
    /// glass or gems, PBR algorithms don’t create bright enough specular
    /// highlights using just roughness. To accurately simulate those types of
    /// materials, use the ``PhysicallyBasedMaterial/specular-swift.property``
    /// property to specify additional specular for the entity.
    ///
    /// The following example demonstrates how to specify specular using a
    /// single value for the entire material:
    ///
    /// ```swift
    /// material.specular = .init(floatLiteral: 0.8)
    /// ```
    ///
    /// This example shows how to specify specular using a UV-mapped image
    /// texture:
    ///
    /// ```swift
    /// if let specularResource = try? TextureResource.load(named:"entity_specular") {
    ///     let specularMap = MaterialParameters.Texture(specularResource)
    ///     material.specular = .init(texture: specularMap)
    /// }
    ///  ```
    @available(macOS 12.0, iOS 15.0, *)
    public var specular: PhysicallyBasedMaterial.Specular

    /// The transparent highlights that simulate a clear, shiny coating on an
    /// entity.
    ///
    /// An entity in RealityKit can display a clearcoat, which is a separate
    /// layer of transparent specular highlights used to simulate a clear
    /// transparent coating, like the paint on a car, or the surface of
    /// lacquered objects. By default, materials don’t have clearcoat enabled.
    ///
    /// Use this property to enable clearcoat rendering. Specifying any value
    /// greater than `0.0` turns clearcoat rendering on. A value of `1.0`
    /// indicates a full clearcoat. RealityKit treats values above `1.0` as if
    /// they’re `1.0`.
    ///
    /// You can specify ``PhysicallyBasedMaterial/clearcoat-swift.property``
    /// using a single `Float` that applies to the entire material, or a
    /// UV-mapped grayscale image to provide different values for different
    /// parts of an entity.
    ///
    /// The following example specifies `clearcoat` using a single value:
    ///
    /// ```swift
    /// material.clearcoat = .init(floatLiteral: 0.8)
    /// ```
    ///
    /// And this example shows how to specify `clearcoat` using a UV-mapped
    /// image texture:
    ///
    /// ```swift
    /// if let clearcoatResource = try? TextureResource.load(named:"entity_clearcoat") {
    ///     let clearcoatMap = MaterialParameters.Texture(clearcoatResource)
    ///     material.clearcoat = .init(texture: clearcoatMap)
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var clearcoat: PhysicallyBasedMaterial.Clearcoat

    /// The degree to which an entity’s clear, shiny coating scatters light to
    /// create soft highlights.
    ///
    /// When you enable clearcoat rendering for a material, RealityKit renders
    /// the clearcoat as a separate layer just above the surface of the entity.
    /// You can specify a clearcoat roughness value for the clearcoat to
    /// indicate how much the clearcoat scatters light that bounces off of it,
    /// which softens and spreads out the highlights.
    ///
    /// You can specify a single value that applies to the entire material, or
    /// you can supply a UV-mapped image texture containing different roughness
    /// values for different parts of the entity.
    ///
    /// The following example sets the `clearcoatRoughness` using a single
    /// value:
    ///
    /// ```swift
    /// material.clearcoatRoughness = .init(floatLiteral: 0.5)
    /// ```
    ///
    /// This example shows how to set the `clearcoatRoughness` using a UV-mapped
    /// image:
    ///
    /// ```swift
    /// if let clearcoatRoughnessResource = try?
    /// TextureResource.load(named: "entity_cc_roughness") {
    ///     let ccRoughnessMap = MaterialParameters.Texture(clearcoatRoughnessResource)
    ///     material.clearcoat = .init(texture: ccRoughnessMap)
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var clearcoatRoughness: PhysicallyBasedMaterial.ClearcoatRoughness

    /// A threshold below which RealityKit ignores opacity.
    ///
    /// When `opacityThreshold` is set, RealityKit discards pixels with opacity values less
    /// than the `opacityThreshold`, and renders opacity values greater than or equal to
    /// `opacityThreshold` fully opaque.
    ///
    /// - Note: When the `opacityThreshold` property is set, the blend mode of the
    /// ``PhysicallyBasedMaterial/blending-swift.property`` property is ignored and the renderer
    /// applies the masking behavior.
    @available(macOS 12.0, iOS 15.0, *)
    public var opacityThreshold: Float?

    /// A process in which the system specifies polygons to remove before
    /// rendering a mesh using this material.
    ///
    /// To improve performance, RealityKit culls polygons, or faces, that it
    /// determines won’t be visible. Discarding faces that aren’t part of the
    /// final render eliminates the need to do any calculations for those
    /// faces.
    ///
    /// RealityKit recognizes when a face aims toward the camera (a front face)
    /// or away from the camera (a back face). This value controls the type of
    /// faces RealityKit culls.
    ///
    /// This value defaults to ``MaterialParameterTypes/FaceCulling/back``,
    /// which means RealityKit removes faces that point away from the camera.
    /// Most of the time, this is the correct behavior, because back faces are
    /// usually obscured by other front-facing polygons.
    ///
    /// You can change the culling behavior to cull front faces instead or to
    /// turn off face culling altogether, but be aware that turning off face
    /// culling results in less efficient rendering and may negatively impact
    /// your app’s frame rate.
    @available(macOS 12.0, iOS 15.0, *)
    public var faceCulling: PhysicallyBasedMaterial.FaceCulling

    /// The transparency of an entity.
    ///
    /// Use this property to specify whether an entity is opaque or transparent.
    /// To create an entity that’s opaque, assign
    /// ``PhysicallyBasedMaterial/Blending-swift.enum/opaque`` to this property.
    ///
    /// ```swift
    /// material.blending = .opaque
    /// ```
    ///
    /// To create a translucent or transparent object using a single opacity
    /// value for the entire material, initialize
    /// ``PhysicallyBasedMaterial/Blending-swift.enum/transparent(opacity:)``
    /// using a `Float` value.
    ///
    /// ```swift
    /// material.blending = .transparent(opacity: .init(floatLiteral:0.5))
    /// ```
    ///
    /// To use a UV-mapped grayscale image texture to specify different opacity
    /// values for different parts of an entity, initialize
    /// ``PhysicallyBasedMaterial/Blending-swift.enum/transparent(opacity:)``
    /// using a texture. If you provide a color image, RealityKit only uses the
    /// intensity of the red channel.
    ///
    /// ```swift
    /// if let opacityResource = try? TextureResource.load(named:
    /// "entity_opacity") {
    ///     let opacityMap = MaterialParameterTypes.Texture(opacityResource)
    ///     material.blending = .transparent(opacity: .init(texture: opacityMap))
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var blending: PhysicallyBasedMaterial.Blending

    /// The normal map for the entity.
    ///
    /// _Normal mapping_ is a real-time rendering technique that captures fine
    /// surface details for a model using a texture instead of increasing the
    /// number of polygons in the model. It works by storing _surface normals_,
    /// which are vectors perpendicular to the surface of the model, from a much
    /// higher resolution version of the same 3D object. A normal map stores
    /// each vector in the image by storing the vectors’ `X`, `Y`, and `Z`
    /// values as the `R`, `G`, and `B` components of the corresponding pixel in
    /// the UV-mapped image.
    ///
    /// If you provide a normal map, RealityKit uses the normals stored in the
    /// image to do lighting calculations. This results in much more realistic
    /// highlights, shadows, and reflections without incurring the computational
    /// cost of using a much higher resolution 3D model. RealityKit uses
    /// tangent-space normal maps.
    ///
    /// The following code loads a normal map texture and uses it to set this
    /// property:
    ///
    /// ```swift
    /// if let normalResource = try? TextureResource.load(named:
    /// "entity_normals") {
    ///     let normalMap = MaterialParameters.Texture(normalResource)
    ///     material.normal = PhysicallyBasedMaterial.Normal(texture:normalMap)
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var normal: PhysicallyBasedMaterial.Normal

    /// The ambient occlusion values for a material.
    ///
    /// Ambient occlusion represents the entity’s exposure to ambient light.
    ///
    /// Specify ambient occlusion using a UV-mapped image called an _ambient
    /// occlusion map_. A value of black (`0.0`) represents parts of the model
    /// that receive less ambient light because that part of the model is a
    /// crevice, dent, or recessed area, or because another part of the same
    /// entity is preventing ambient light from reaching it. Ambient occlusion
    /// values of white (`1.0`) represent flat portions of the model that
    /// receive full ambient light. You generate ambient occlusion maps using a
    /// 3D software package.
    ///
    /// The following code loads an ambient occlusion map:
    ///
    /// ```swift if let aoResource = try? TextureResource.load(named:
    /// "entity_ao") {
    ///     let aoMap = MaterialParameters.Texture(aoResource)
    ///     material.emissiveColor = .init(texture: aoMap)
    /// } ```
    @available(macOS 12.0, iOS 15.0, *)
    public var ambientOcclusion: PhysicallyBasedMaterial.AmbientOcclusion

    /// The degree to which an entity reflects light to create stretched or
    /// oblong highlights.
    ///
    /// By default, PBR materials are isotropic; in other words, an entity that
    /// uses ``PhysicallyBasedMaterial`` reflects light uniformly in all
    /// directions, mimicking the behavior of most real-world objects. Some
    /// objects, including those with many small parallel striations such as
    /// vinyl records, CDs, or straight hair, reflect light more in some
    /// directions than others, resulting in stretched or oblong specular
    /// highlights, as shown in the following figure.
    ///
    /// ![An illustration showing 11 metallic spheres in a horizontal row. The
    /// left-most sphere is isotropic. The spheres represent increasing
    /// anisotropy from left to right, with the sphere furthest to the right
    /// displaying a long, stretched highlight.
    /// ](PhysicallyBasedMaterial-anisotropyLevel-swift-property-1)
    ///
    /// This property controls the amount of anisotropy. It works together with
    /// ``PhysicallyBasedMaterial/anisotropyAngle-swift.property``, which
    /// defines the angle of elongation for the specular highlights.
    ///
    /// The following example specifies `anisotropyLevel` using single values
    /// for the entire material:
    ///
    /// ```swift
    /// material.anisotropyLevel = .AnisotropyLevel(floatLiteral: 0.5)
    /// ```
    ///
    /// This example specifies `anisotropyLevel` using a UV-mapped image
    /// texture.
    ///
    /// ```swift
    /// if let anisoLevelResource = try? TextureResource.load(named:
    /// "entity_aniso_level") {
    ///     let anisoLevelMap = MaterialParameters.Texture(sheenResource)
    ///     material.anisotropyLevel = .init(texture: anisoLevelMap)
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var anisotropyLevel: PhysicallyBasedMaterial.AnisotropyLevel

    /// The angle at which the anisotropic direction of the material is oriented,
    /// influencing the reflection and appearance of surface highlights.
    ///
    /// This property controls the scattering angle for anisotropic objects. If
    /// ``PhysicallyBasedMaterial/anisotropyLevel-swift.property`` is `0.0`,
    /// this property has no effect. This property takes a value between `0.0
    /// `and `1.0` or a UV-mapped grayscale image specifying angles for
    /// different parts of the entity.` A` value of black (`0.0)` means a
    /// rotation of 0° and a value of white (`1.0)` indicates a rotation of
    /// 360°. To determine the
    /// ``PhysicallyBasedMaterial/anisotropyAngle-swift.property`` value from an
    /// angle, divide the desired angle in degrees by `360.0` or the desired
    /// angle in radians by pi times 2.
    ///
    /// ```swift
    /// let angleDegrees = Float(125.0)
    /// let anisotropyAngleFromDegrees = angleDegrees / 360.0
    ///
    /// let angleRadians = Float(2.181662) let anisotropyAngleFromRadians =
    /// angleRadians / (Float.pi * Float(2.0))
    /// ```
    ///
    /// The following example shows how to specify `anisotropyAngle` using
    /// single values for the entire material:
    ///
    /// ```swift
    /// material.anisotropyAngle = .AnisotropyAngle(floatLiteral: 0.25)
    /// ```
    ///
    /// This example shows how to specify anisotropy using a UV-mapped image
    /// texture for ``PhysicallyBasedMaterial/anisotropyLevel-swift.property``
    /// and a separate image for
    /// ``PhysicallyBasedMaterial/anisotropyAngle-swift.property``:
    ///
    /// ```swift
    /// if let anisoLevelResource = try? TextureResource.load(named:
    /// "entity_aniso_level") {
    ///     let anisoLevelMap = MaterialParameters.Texture(sheenResource)
    ///     material.anisotropyLevel = .init(texture: anisoLevelMap)
    /// }
    /// if let anisoAngleResource = try? TextureResource.load(named:
    /// "entity_aniso_angle") {
    ///     let anisoAngleMap = MaterialParameters.Texture(anisoAngleResource)
    ///     material.anisotropyAngle = .init(texture: anisoAngleMap)
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var anisotropyAngle: PhysicallyBasedMaterial.AnisotropyAngle

    /// The intensity of an entity’s sheen.
    ///
    /// For a ``PhysicallyBasedMaterial``, object, you can use `sheen` to add
    /// soft specular highlights that simulate subtle reflections like the ones
    /// that occur with some materials, primarily fabrics. You can specify
    /// `sheen` using a single color, or you can provide a UV-mapped image.
    ///
    /// ![An illustration showing two spheres. The one on the right has very
    /// subtle, soft specular highlights and is labeled “With sheen”. The one on
    /// the right has no specular highlights and is labeled “Without
    /// sheen”.](PhysicallyBasedMaterial-sheen-1)
    ///
    /// The following example specifies `sheen` using a single value for the
    /// entire material:
    ///
    /// ```swift
    /// let sheenColor = PhysicallyBasedMaterial.Color(deviceRed: 0.8,
    /// green: 0.8, blue: 0.8, alpha: 1.0)
    /// material.sheen = .init(tint:sheenColor)
    /// ```
    ///
    /// This example shows how to specify sheen using a UV-mapped image texture:
    ///
    /// ```swift
    /// if let sheenResource = try? TextureResource.load(named:
    /// "entity_sheen") {
    ///     let sheenMap = MaterialParameters.Texture(sheenResource)
    ///     material.sheen = .init(texture: sheenMap)
    /// }
    /// ```
    @available(macOS 12.0, iOS 15.0, *)
    public var sheen: PhysicallyBasedMaterial.SheenColor?

    /// A two-dimensional transformation to apply to the entity’s primary
    /// texture coordinates.
    ///
    /// An entity’s UV texture coordinates control how RealityKit materials map
    /// image textures onto an entity. This property allows you to transform the
    /// texture coordinates to change the way this material maps its textures.
    /// You might, for example, change the scale of a property to apply a tiled,
    /// repeating pattern, or continuously rotate or translate the texture
    /// coordinates to animate materials to create special effects, such as fire
    /// or flowing liquids.
    ///
    /// The following example shows how to set a material’s UV transformation:
    ///
    /// ```swift
    /// let rotationRadians = Float(45.0) * .pi / 180 // 45 degrees converted to radians.
    /// material.textureCoordinateTransform = .init(offset: SIMD2<Float>(x:0.5, y: 0.5),
    ///                                             scale: SIMD2<Float>(x:0.5, y: 0.5),
    ///                                             rotation: rotationRadians)
    /// ```
    ///
    /// Some entities imported from USDZ files have more than one set of UV
    /// coordinates. This property affects the primary UV set (sometimes called
    /// “UV1”). To transform the secondary UV coordinates (”UV2”), use
    /// ``PhysicallyBasedMaterial/secondaryTextureCoordinateTransform``.
    @available(macOS 12.0, iOS 15.0, *)
    public var textureCoordinateTransform: PhysicallyBasedMaterial.TextureCoordinateTransform

    /// A two-dimensional transformation to apply to the entity’s secondary
    /// texture coordinates.
    ///
    /// An entity’s UV texture coordinates define how RealityKit maps image
    /// textures onto an entity. This property allows you to transform the
    /// secondary texture coordinates to change the way this material maps
    /// textures onto an entity. If an entity has multiple materials assigned to
    /// it, the transformation doesn’t affect how the other materials map their
    /// textures.
    ///
    /// You might, for example, change the scale of the UV coordinates to apply
    /// a tiled, repeating pattern to the surface of your entity, or
    /// continuously rotate or translate the texture coordinates to animate
    /// materials to create special effects, such as fire or flowing liquids.
    ///
    /// The following example demonstrates how to set a material’s UV
    /// transformation:
    ///
    /// ```swift
    /// let rotationRadians = Float(45.0) * .pi / 180 // 45 degrees converted to radians.
    /// secondaryTextureCoordinateTransform =.init(offset: SIMD2<Float>(x:0.5, y: 0.5),
    ///                                             scale: SIMD2<Float>(x:0.5, y: 0.5),
    ///                                             rotation: rotationRadians)
    /// ```
    ///
    /// Some entities imported from USDZ files have more than one set of UV
    /// coordinates. This property transforms the secondary set. To transform
    /// the primary UV coordinates in a material, see
    /// ``PhysicallyBasedMaterial/textureCoordinateTransform-swift.property``.
    @available(macOS 12.0, iOS 15.0, *)
    public var secondaryTextureCoordinateTransform: PhysicallyBasedMaterial.TextureCoordinateTransform

    /// The object that controls how RealityKit draws triangles.
    ///
    /// A value of ``MaterialParameterTypes/TriangleFillMode/fill`` causes RealityKit
    /// to draw triangles normally, while a value of  ``MaterialParameterTypes/TriangleFillMode/lines``
    /// turns on wireframe rendering.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public var triangleFillMode: PhysicallyBasedMaterial.TriangleFillMode
}

@available(macOS 12.0, iOS 15.0, *)
extension PhysicallyBasedMaterial {

    /// The texture type to use for materials of this class.
    @available(macOS 12.0, iOS 15.0, *)
    public typealias Texture = MaterialParameters.Texture

    /// An alias for the face culling object that’s appropriate for this
    /// material class.
    public typealias FaceCulling = MaterialParameterTypes.FaceCulling

    /// An alias for the texture coordinate transform that’s appropriate for
    /// this material class.
    public typealias TextureCoordinateTransform = MaterialParameterTypes.TextureCoordinateTransform

    /// An alias for the triangle fill mode object that's appropriate for this
    /// material class.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public typealias TriangleFillMode = MaterialParameterTypes.TriangleFillMode

    /// An object that defines an entity’s base color.
    ///
    /// Use this struct to specify an entity’s base color, which defines the
    /// entity’s appearance before RealityKit calculates the effect of lighting
    /// or material properties such as
    /// ``PhysicallyBasedMaterial/roughness-swift.property`` or
    /// ``PhysicallyBasedMaterial/metallic-swift.property``. For more
    /// information, see ``PhysicallyBasedMaterial/baseColor-swift.property``.
    @available(macOS 12.0, iOS 15.0, *)
    public struct BaseColor {

        /// The base color as a UV Image map.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of this object’s texture property.
        public static let textureSemantic: TextureResource.Semantic
    }

    /// An object that defines the reflectiveness of an entity.
    ///
    /// Use this struct to specify an entity’s `metallic` property, which
    /// specifies the reflectiveness of an entity. For more information, see
    /// ``PhysicallyBasedMaterial/metallic-swift.property``.
    @available(macOS 12.0, iOS 15.0, *)
    public struct Metallic : ExpressibleByFloatLiteral {

        /// The reflectiveness for the entire entity.
        public var scale: Float

        /// The reflectiveness as a UV-mapped image texture.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates an object from a color or texture.
        ///
        /// In PBR rendering, the `metallic` property represents the
        /// reflectiveness of an entity. This initializer creates a new object
        /// from a single value to describe the reflectiveness of the entire
        /// material. This initializer creates a new object from a single value
        /// or a grayscale image texture, or from both.
        ///
        /// If you specify `texture`, RealityKit calculates the `metallic` for
        /// the entity by UV-mapping `texture` onto the entity and multiplying
        /// the value of each mapped pixel by `scale`. If you don’t specify
        /// `texture`, then RealityKit uses `scale` as the entire entity’s
        /// reflectiveness. If you provide a color image for `texture` rather
        /// than a grayscale image, RealityKit only uses the intensity of the
        /// image’s red channel.
        ///
        /// ![An illustration showing two spheres rendered in RealityKit. The
        /// sphere on the left is shiny but dielecric so doesn’t reflect the
        /// surrounding environment other than specular highlights from the
        /// visible light. The sphere on the right is metallic and reflects all
        /// of the surrounding environment like a mirror
        /// ball.](PhysicallyBasedMaterial-Metallic-swift-struct-init(scale:texture:)-1)
        ///
        /// - Parameters:
        ///   - scale: The reflectiveness value.
        ///
        ///   - texture: An optional image texture.
        public init(scale: Float = 1.0, texture: PhysicallyBasedMaterial.Texture? = nil)

        /// Creates an object from single value.
        ///
        /// In PBR rendering, the `metallic` property represents the
        /// reflectiveness of an entity. This initializer creates a new object
        /// from a single value to describe the reflectiveness of the entire
        /// material. A value of 0.0 creates a _dielectric_ (or non-reflective)
        /// material. Values greater than 0.0 result in an increasingly
        /// _metallic_ (or reflective) materials.
        ///
        /// ![An illustration showing two spheres rendered in RealityKit. The
        /// sphere on the left is shiny but dielecric so doesn’t reflect the
        /// surrounding environment other than specular highlights from the
        /// visible light. The sphere on the right is metallic and reflects all
        /// of the surrounding environment like a mirror
        /// ball.](PhysicallyBasedMaterial-Metallic-swift-struct-init(floatLiteral:)-1)
        ///
        /// - Parameters:
        ///   - value: The reflectiveness value for the material.
        public init(floatLiteral value: Float)

        /// A type that represents a floating-point literal.
        ///
        /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
        /// where available.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias FloatLiteralType = Float
    }

    /// An object that defines the roughness of an entity’s surface.
    ///
    /// Use this struct to specify the roughness of the entity. The `roughness`
    /// property represents how much the surface of the entity scatters light
    /// that it reflects. A material with a high roughness has a matte
    /// appearance, whereas one with a low roughness has a shiny appearance.
    ///
    /// For more information, see
    /// ``PhysicallyBasedMaterial/roughness-swift.property``.
    @available(macOS 12.0, iOS 15.0, *)
    public struct Roughness : ExpressibleByFloatLiteral {

        /// The roughness value for the entire entity.
        public var scale: Float

        /// The roughness values as a UV-mapped image texture.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates a roughness object from a color or texture.
        ///
        /// The `roughness` property represents how much the surface of the
        /// entity scatters light it reflects. A material with a high roughness
        /// has a matte appearance, while one with a low roughness has a shiny
        /// appearance.
        ///
        /// ![An illustration showing three spheres with different amounts of
        /// roughness. The sphere on the left has a low roughness and looks like
        /// shiny, polished plastic. The sphere in the middle has a matte
        /// appearance with very soft specular highlights. The sphere on the
        /// right has no highlights
        /// whatsoever.](PhysicallyBasedMaterial-Roughness-swift-struct-init(scale:texture:)-1)
        ///
        /// Use this initializer to create a new object from a single roughness
        /// value, from an image texture, or from both.
        ///
        /// If you specify `texture`, RealityKit calculates the `roughness` for
        /// the entity by UV-mapping `texture` onto the entity and multiplying
        /// the value of each mapped pixel by `scale`. If you don’t specify
        /// `texture`, then RealityKit uses `scale` as the entire entity’s
        /// roughness. If you provide a color image for `texture` rather than a
        /// grayscale image, RealityKit only uses the intensity of the image’s
        /// red channel.
        ///
        /// - Parameters:
        ///   - scale: The roughness value.
        ///
        ///   - texture: An optional image texture.
        public init(scale: Float = 1.0, texture: PhysicallyBasedMaterial.Texture? = nil)

        /// Creates an object from a single value.
        ///
        /// The `roughness` property represents how much the surface of the
        /// entity scatters light it reflects. A material with a high roughness
        /// has a matte appearance, while one with a low roughness has a shiny
        /// appearance.
        ///
        /// ![An illustration showing three spheres with different amounts of
        /// roughness. The sphere on the left has a low roughness and looks like
        /// shiny, polished plastic. The sphere in the middle has a matte
        /// appearance with very soft specular highlights. The sphere on the
        /// right has no highlights
        /// whatsoever.](PhysicallyBasedMaterial-Roughness-swift-struct-init(floatLiteral:)-1)
        ///
        /// Use this initializer to create an object to specify the amount of
        /// roughness using a single value that applies to the entire material.
        ///
        /// - Parameters:
        ///   - value: The roughness value.
        public init(floatLiteral value: Float)

        /// A type that represents a floating-point literal.
        ///
        /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
        /// where available.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias FloatLiteralType = Float
    }

    /// An object that defines the color of the light an entity emits.
    ///
    /// With physically based rendering (PBR), you can give entities in
    /// RealityKit the appearance of emitting light. Define the color of the
    /// light the entity emits by using this object.
    @available(macOS 12.0, iOS 15.0, *)
    public struct EmissiveColor {

        /// An optional image texture that defines the color of light emission.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic
    }

    /// An object that defines the specular highlights of an entity.
    ///
    /// RealityKit automatically draws _specular highlights_ for physically
    /// based materials,
    /// using the values of various properties, primarily
    /// ``PhysicallyBasedMaterial/roughness-swift.property`` and
    /// ``PhysicallyBasedMaterial/metallic-swift.property``. Specular highlights
    /// are bright spots of reflected light that appear on shiny objects.
    ///
    /// ![An illustration showing a sphere and a cube with rounded corners. Both
    /// have a shiny surface and a small white spot labeled “specular
    /// highlights” where they reflect the scene’s light
    /// source.](PhysicallyBasedMaterial-Specular-swift-struct-1)
    ///
    /// Although many real-world objects can be accurately and realistically
    /// simulated with just the core physically based rendering (PBR)
    /// properties, you can create additional realistic effects by augmenting
    /// the specular highlights.
    ///
    /// Use this object to specify the amount of
    /// ``PhysicallyBasedMaterial/specular-swift.property`` for a
    /// ``PhysicallyBasedMaterial``.
    @available(macOS 12.0, iOS 15.0, *)
    public struct Specular : ExpressibleByFloatLiteral {

        /// The amount of specular for the entire entity.
        public var scale: Float

        /// The amount of specular as a UV-mapped image texture.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates an object from a single value or a texture.
        ///
        /// RealityKit automatically draws _specular highlights_ for physically
        /// based materials using the values of various properties, primarily
        /// ``PhysicallyBasedMaterial/roughness-swift.property`` and
        /// ``PhysicallyBasedMaterial/metallic-swift.property``. Specular
        /// highlights are bright spots of reflected light that appear on shiny
        /// objects.
        ///
        /// ![An illustration showing a sphere and a cube with rounded corners.
        /// Both have a shiny surface and a small white spot labeled “specular
        /// highlights” where they reflect the scene’s light
        /// source.](PhysicallyBasedMaterial-Specular-swift-struct-init(scale:texture:)-1)
        ///
        /// While many real-world objects can be accurately and realistically
        /// simulated with just the core PBR properties, you can create
        /// additional realistic effects by augmenting the specular highlights.
        ///
        /// This initializer creates a
        /// ``PhysicallyBasedMaterial/Specular-swift.struct`` object from a
        /// single value, an image texture, or both.
        ///
        /// If you specify `texture`, RealityKit calculates the `specular` for
        /// the entity by UV-mapping `texture` onto the entity and multiplying
        /// the value of each mapped pixel by `scale`. If you don’t specify
        /// `texture`, RealityKit uses `scale` as the entire entity’s specular.
        /// If you provide a color image for `texture` rather than a grayscale
        /// image, RealityKit only uses the intensity of the image’s red
        /// channel.
        ///
        /// - Parameters:
        ///   - scale: A value from 0.0 to 1.0 to use as the specular value for
        ///     the material.
        ///
        ///   - texture: An optional UV-mapped image texture.
        public init(scale: Float = 1.0, texture: PhysicallyBasedMaterial.Texture? = nil)

        /// Creates an object from single value.
        ///
        /// RealityKit automatically draws _specular highlights_ for physically
        /// based materials using the values of various properties, primarily
        /// ``PhysicallyBasedMaterial/roughness-swift.property`` and
        /// ``PhysicallyBasedMaterial/metallic-swift.property``. Specular
        /// highlights are bright spots of reflected light that appear on shiny
        /// objects.
        ///
        /// ![An illustration showing a sphere and a cube with rounded corners.
        /// Both have a shiny surface and a small white spot labeled “specular
        /// highlights” where they reflect the scene’s light
        /// source.](PhysicallyBasedMaterial-Specular-swift-struct-init(floatLiteral:)-1)
        ///
        /// While many real-world objects can be accurately and realistically
        /// simulated with just the core PBR properties, you can create
        /// additional realistic effects by augmenting the specular highlights.
        ///
        /// This initializer creates a
        /// ``PhysicallyBasedMaterial/Specular-swift.struct`` object from a
        /// single value that applies to the entire material.
        ///
        /// - Parameters:
        ///   - value: A value from 0.0 to 1.0 to use as the specular value for
        ///     the material.
        public init(floatLiteral value: Float)

        /// A type that represents a floating-point literal.
        ///
        /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
        /// where available.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias FloatLiteralType = Float
    }

    /// The object that defines the transparency of an entity.
    @available(macOS 12.0, iOS 15.0, *)
    public enum Blending {

        /// An opaque surface.
        case opaque

        /// A surface that’s transparent.
        ///
        /// This enumeration case indicates that the material supports
        /// transparency.
        ///
        /// - Parameters:
        ///   - opacity: The opacity of the material.
        case transparent(opacity: PhysicallyBasedMaterial.Opacity)
    }

    /// An object that defines the opacity of an entity.
    @available(macOS 12.0, iOS 15.0, *)
    public struct Opacity : ExpressibleByFloatLiteral {

        public var scale: Float

        /// The amount of opacity specified using a UV-mapped image.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static var textureSemantic: TextureResource.Semantic { get }

        /// Creates an opacity object using a single value or a texture.
        ///
        /// This initializer allows you to create an instance using either a
        /// single value for the entire material or a UV-mapped image. If
        /// `texture` is non-`nil`, RealityKit uses that image to determine the
        /// material’s opacity and ignores `scale`. If `texture` is `nil`, then
        /// it uses `scale` for the entire material.
        ///
        /// - Parameters:
        ///   - scale: The opacity value for the entire material.
        ///
        ///   - texture: The opacity values as a UV-mapped image.
        public init(scale: Float = 1.0, texture: PhysicallyBasedMaterial.Texture? = nil)

        /// Creates an opacity object using a single value.
        ///
        /// - Parameters:
        ///   - value: The opacity value.
        public init(floatLiteral value: Float)

        /// A type that represents a floating-point literal.
        ///
        /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
        /// where available.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias FloatLiteralType = Float
    }

    /// An object that defines the intensity of an entity’s clear, shiny
    /// coating.
    ///
    /// A clearcoat is a separate layer of transparent specular highlights used
    /// to simulate a clear coating, like on a car or the surface of lacquered
    /// objects.
    @available(macOS 12.0, iOS 15.0, *)
    public struct Clearcoat : ExpressibleByFloatLiteral {

        /// The clearcoat intensity specified as a single value.
        public var scale: Float

        /// The clearcoat intensity specified using a UV-mapped image.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates a clearcoat object using a single value or a texture.
        ///
        /// A clearcoat is a separate layer of transparent specular highlights
        /// used to simulate a clear transparent coating, like the paint on a
        /// car, or the surface of lacquered objects. Use this initializer to
        /// create an object to specify the amount of clearcoat for a material
        /// using a single value for the entire material, a UV-mapped image to
        /// specify different values for different parts of the entity, or both.
        ///
        /// If you specify `texture`, RealityKit calculates the clearcoat
        /// intensity for the entity by UV-mapping `texture` onto the entity and
        /// multiplying the value of each mapped pixel by `scale`. If you don’t
        /// specify `texture`, then RealityKit uses `scale` as the entire
        /// entity’s clearcoat intensity value. If you provide a color image for
        /// `texture` rather than a grayscale image, RealityKit only uses the
        /// intensity of the image’s red channel.
        ///
        /// - Parameters:
        ///   - scale: The clearcoat value for the entire material.
        ///
        ///   - texture: The clearcoat values as the texture of a UV-mapped image.
        public init(scale: Float = 1.0, texture: PhysicallyBasedMaterial.Texture? = nil)

        /// Creates a clearcoat object using a single value.
        ///
        /// A clearcoat is a separate layer of transparent specular highlights
        /// used to simulate a clear transparent coating, like the paint on a
        /// car, or the surface of lacquered objects. Use this initializer to
        /// create an object to specify the amount of clearcoat for a material
        /// using a single value that applies to the entire material.
        ///
        /// - Parameters:
        ///   - value: The clearcoat value to use for the entity.
        public init(floatLiteral value: Float)

        /// A type that represents a floating-point literal.
        ///
        /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
        /// where available.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias FloatLiteralType = Float
    }

    /// An object that defines the degree to which an entity’s clear, shiny
    /// coating scatters light to create soft highlights.
    ///
    /// This object specifies clearcoat roughness for entities that have
    /// clearcoat enabled. A clearcoat is a separate layer of transparent
    /// specular highlights used to simulate a clear coating, like on a car or
    /// the surface of lacquered objects. When you enable clearcoat rendering
    /// for a material, RealityKit renders the clearcoat as a separate layer
    /// just above the surface of the entity. You can specify a clearcoat
    /// roughness value to indicate how much the clearcoat scatters light that
    /// bounces off of it, which softens and spreads out the highlights.
    @available(macOS 12.0, iOS 15.0, *)
    public struct ClearcoatRoughness : ExpressibleByFloatLiteral {

        /// The clearcoat roughness specified as a single value.
        public var scale: Float

        /// The clearcoat roughness specified using a UV-mapped image.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates a clearcoat roughness object using a single value or a
        /// texture.
        ///
        /// A clearcoat is a separate layer of transparent specular highlights
        /// used to simulate a clear transparent coating, like the paint on a
        /// car, or the surface of lacquered objects. When you enable clearcoat
        /// rendering for a material, RealityKit renders the clearcoat as a
        /// separate layer just above the surface of the entity. You can specify
        /// a clearcoat roughness value for the clearcoat to indicate how much
        /// the clearcoat scatters light that bounces off of it, which softens
        /// and spreads out the highlights.
        ///
        /// This initializer creates an object that specifies the clearcoat
        /// roughness for a material using a single value for the entire
        /// material, a UV-mapped image, or both.
        ///
        /// If you specify `texture`, RealityKit calculates the clearcoat
        /// roughness for the entity by UV-mapping `texture` onto the entity and
        /// multiplying the value of each mapped pixel by `scale`. If you don’t
        /// specify a `texture`, then RealityKit uses `scale` as the entire
        /// entity’s clearcoat roughness. If you provide a color image for
        /// `texture` rather than a grayscale image, RealityKit only uses the
        /// intensity of the image’s red channel.
        ///
        /// - Parameters:
        ///   - scale: The clearcoat roughness value for the entire material.
        ///
        ///   - texture: The clearcoat roughness values as a UV-mapped image.
        public init(scale: Float = 1.0, texture: PhysicallyBasedMaterial.Texture? = nil)

        /// Creates a clearcoat roughness object using a single value.
        ///
        /// A clearcoat is a separate layer of transparent specular highlights
        /// used to simulate a clear transparent coating, like the paint on a
        /// car, or the surface of lacquered objects. When you enable clearcoat
        /// rendering for a material, RealityKit renders the clearcoat as a
        /// separate layer just above the surface of the entity. You can specify
        /// a clearcoat roughness value for the clearcoat to indicate how much
        /// the clearcoat scatters light that bounces off of it, which softens
        /// and spreads out the highlights.
        ///
        /// This initializer creates an object that specifies the clearcoat
        /// roughness for a material using a single value for the entire
        /// material.
        ///
        /// - Parameters:
        ///   - value: The clearcoat roughness value to use for the entire material.
        public init(floatLiteral value: Float)

        /// A type that represents a floating-point literal.
        ///
        /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
        /// where available.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias FloatLiteralType = Float
    }

    /// An object that specifies an entity’s normal map.
    ///
    /// The `normal` property of a RealityKit entity holds an optional _normal
    /// map_, which stores fine details about the entity’s surface, using a
    /// texture rather than increasing the number of polygons in the model. If
    /// you provide a normal map, RealityKit uses the vectors from that normal
    /// map when rendering the entity, resulting in greater detail and more
    /// accurate highlights, shadows, and reflections.
    @available(macOS 12.0, iOS 15.0, *)
    public struct Normal {

        /// The material’s normal map.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates an object from a specified texture.
        ///
        /// - Parameters:
        ///   - texture: The image’s texture.
        public init(texture: PhysicallyBasedMaterial.Texture? = nil)
    }

    /// An object that defines the ambient occlusion of an entity’s surface.
    @available(macOS 12.0, iOS 15.0, *)
    public struct AmbientOcclusion {

        /// The amount of ambient occlusion specified using a UV-mapped image.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates an object from an image texture.
        ///
        /// - Parameters:
        ///   - texture: The ambient occlusion texture map.
        public init(texture: PhysicallyBasedMaterial.Texture? = nil)
    }

    /// An object that defines the degree to which an entity reflects light to
    /// create stretched or oblong highlights.
    ///
    /// By default, PBR materials are isotropic; in other words, an entity that
    /// uses ``PhysicallyBasedMaterial`` reflects light uniformly in all
    /// directions, mimicking the behavior of most real-world objects. Some
    /// objects, including those with many small parallel striations such as
    /// vinyl records, CDs, or straight hair, reflect light more in some
    /// directions than others, resulting in stretched or oblong specular
    /// highlights, as shown in the following figure.
    ///
    /// ![An illustration showing 11 metallic spheres in a horizontal row. The
    /// left-most sphere is isotropic. The spheres represent increasing
    /// anisotropy from left to right, with the sphere furthest to the right
    /// displaying a long, stretched highlight.
    /// ](PhysicallyBasedMaterial-AnisotropyLevel-swift-struct-1)
    ///
    /// Use this object to specify the
    /// ``PhysicallyBasedMaterial/anisotropyLevel-swift.property`` for a
    /// material.
    @available(macOS 12.0, iOS 15.0, *)
    public struct AnisotropyLevel : ExpressibleByFloatLiteral {

        /// The anistropy level specified as a single value.
        public var scale: Float

        /// The anisotropy level values specified using a UV-mapped image.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates an anisotropy level object using a single value or a
        /// texture.
        ///
        /// By default, PBR materials are isotropic; in other words, an entity
        /// that uses ``PhysicallyBasedMaterial`` reflects light uniformly in
        /// all directions, mimicking the behavior of most real-world objects.
        /// Some objects, including those with many small parallel striations
        /// such as vinyl records, CDs, or straight hair, reflect light more in
        /// some directions than others, resulting in stretched or oblong
        /// specular highlights, as shown in the following figure.
        ///
        /// ![An illustration showing 11 metallic spheres in a horizontal row.
        /// The left-most sphere is isotropic. The spheres represent increasing
        /// anisotropy from left to right, with the sphere furthest to the right
        /// displaying a long, stretched highlight.
        /// ](PhysicallyBasedMaterial-AnisotropyLevel-swift-struct-init(scale:texture:)-1)
        ///
        /// Use this initializer to create an object to set the
        /// ``PhysicallyBasedMaterial/anisotropyLevel-swift.property`` for a
        /// material using either a single value for the entire material, or a
        /// UV-mapped image. If you specify `texture`, RealityKit calculates the
        /// anistotropy level for the entity by UV-mapping `texture` onto the
        /// entity and multiplying the value of each mapped pixel by `scale`. If
        /// you don’t specify `texture`, then RealityKit uses `scale` as the
        /// entire entity’s anisotropy level. If you provide a color image for
        /// `texture` rather than a grayscale image, RealityKit only uses the
        /// intensity of the image’s red channel.
        ///
        /// - Parameters:
        ///   - scale: The anisotropy level value for the entire material.
        ///
        ///   - texture: The anisotropy level values as a UV-mapped image.
        public init(scale: Float = 1.0, texture: PhysicallyBasedMaterial.Texture? = nil)

        /// Creates an anisotropy level object from a single value.
        ///
        /// - Parameters:
        ///   - value: The anisotropy level.
        public init(floatLiteral value: Float)

        /// A type that represents a floating-point literal.
        ///
        /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
        /// where available.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias FloatLiteralType = Float
    }

    /// An object used to define a material’s anisotropy angle.
    @available(macOS 12.0, iOS 15.0, *)
    public struct AnisotropyAngle : ExpressibleByFloatLiteral {

        /// The anistropy angle specified as a single value.
        public var scale: Float

        /// The anisotropy angle values specified using a UV-mapped image.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates an anisotropy angle object using a single value or a
        /// texture.
        ///
        /// This initializer allows you to create an instance using either a
        /// single value for the entire material, or a UV-mapped image.
        ///
        /// If you specify `texture`, RealityKit calculates the anisotropy angle
        /// for the entity by UV-mapping `texture` onto the entity and
        /// multiplying the value of each mapped pixel by `scale`. If you don’t
        /// specify `texture`, then RealityKit uses `scale` as the entire
        /// entity’s anisotropy angle. If you provide a color image for
        /// `texture` rather than a grayscale image, RealityKit only uses the
        /// intensity of the image’s red channel.
        ///
        /// - Parameters:
        ///   - scale: The anisotropy angle value for the entire material.
        ///
        ///   - texture: The anisotropy angle values as a UV-mapped image.
        public init(scale: Float = 1.0, texture: PhysicallyBasedMaterial.Texture? = nil)

        /// Creates an anisotropy angle object from a single value.
        ///
        /// - Parameters:
        ///   - value: The anisotropy angle.
        public init(floatLiteral value: Float)

        /// A type that represents a floating-point literal.
        ///
        /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
        /// where available.
        @available(iOS 15.0, macOS 12.0, *)
        public typealias FloatLiteralType = Float
    }

    /// An object that defines the color of an entity’s sheen.
    ///
    /// Use `sheen` to add specular highlights that simulate subtle reflections,
    /// like the ones that occur on materials such as fabrics. Use this object
    /// to define the color of the highlights.
    @available(macOS 12.0, iOS 15.0, *)
    public struct SheenColor {

        /// An optional image texture for defining the property.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic
    }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension PhysicallyBasedMaterial {

    /// An object that represents the backing shader compilation required for
    /// physically based materials.
    ///
    /// You can use this type to control when RealityKit compiles shaders,
    /// and to initialize `PhysicallyBasedMaterial` objects with more predicitable loading performance.
    ///
    /// When initializing a `PhysicallyBasedMaterial` this way, a `Program` object is
    /// created first asynchronously, which is used to cache the material's shader program so
    /// the `PhysicallyBasedMaterial` can be loaded immediately later.
    ///
    /// For example:
    ///
    /// ```swift
    /// // Initialize descriptor with desired properties
    /// var descriptor = PhysicallyBasedMaterial.Descriptor()
    /// descriptor.blendMode = .add
    ///
    /// // Create program object
    /// let program = await PhysicallyBasedMaterial.Program(descriptor: descriptor)
    ///
    /// // Create material (returns immediately)
    /// let material = PhysicallyBasedMaterial(program: program)
    /// ```
    final public class Program : Equatable, Hashable, Sendable {

        final public let descriptor: PhysicallyBasedMaterial.Program.Descriptor

        /// Specifies all parameters necessary to initialize `PhysicallyBasedMaterial` programs
        public struct Descriptor : Equatable, Hashable, Sendable {

            /// Describes how materials using the created `PhysicallyBasedMaterial.Program` will be blended with content behind them.
            ///
            /// Default value is nil, which will cause this material to render opaque, and not blend with background content.
            public var blendMode: MaterialParameterTypes.BlendMode?

            public init()

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: PhysicallyBasedMaterial.Program.Descriptor, b: PhysicallyBasedMaterial.Program.Descriptor) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public init(descriptor: PhysicallyBasedMaterial.Program.Descriptor) async

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: PhysicallyBasedMaterial.Program, rhs: PhysicallyBasedMaterial.Program) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        final public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        final public var hashValue: Int { get }
    }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension PhysicallyBasedMaterial {

    /// An object that defines the clearcoat normal map texture.
    ///
    /// An entity in RealityKit can display a clearcoat, which is a separate
    /// layer of transparent specular highlights used to simulate a clear
    /// coating, like on a car or the surface of lacquered objects. Use this
    /// object to specify a clearcoat normal and vary the normal used
    /// to calculate the clearcoat. This can be used to add imperfections and
    /// waviness to the clearcoat layer.
    ///
    /// For information, see
    /// ``PhysicallyBasedMaterial/clearcoatNormal-swift.property``.
    public struct ClearcoatNormal {

        /// The material’s clearcoat normal map.
        public var texture: PhysicallyBasedMaterial.Texture?

        /// The intended use of the object’s texture property.
        public static let textureSemantic: TextureResource.Semantic

        /// Creates an object from a specified texture.
        ///
        /// - Parameters:
        ///   - texture: The clearcoat normals as the texture of a UV-mapped image.
        public init(texture: PhysicallyBasedMaterial.Texture? = nil)
    }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension PhysicallyBasedMaterial {

    /// A boolean value that determines whether this material writes its depth into RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will occlude objects behind them by writing their depth
    /// into RealityKit's depth buffer.
    ///
    /// If false, meshes with this material will not write their depth into
    /// RealityKit's depth buffer, and may be overwritten by objects drawn behind them, depending on
    /// draw order.
    ///
    /// The default value is true.
    public var writesDepth: Bool

    /// A boolean value that determines whether this material performs the depth test by reading RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will depth test each of their fragments when being rendered.
    /// If an object that writes depth is in front of this material, this material will be hidden.
    ///
    /// If false, meshes with this material will ignore the depth test, and always render all of their
    /// fragments during their draw call, regardless of the positioning of other objects in the scene.
    /// Note that other objects may still render on top of this material, depending on draw order.
    ///
    /// The default value is true.
    public var readsDepth: Bool
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension PhysicallyBasedMaterial {

    public var program: PhysicallyBasedMaterial.Program

    public init(program: PhysicallyBasedMaterial.Program)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension PhysicallyBasedMaterial {

    /// Waviness and imperfections for the top clearcoat.
    ///
    /// An entity in RealityKit can display a clearcoat, which is a separate
    /// layer of transparent specular highlights used to simulate a clear
    /// coating, like on a car or the surface of lacquered objects. This
    /// property allows you to specify a clearcoat normal and add
    /// waviness and imperfections to the top clearcoat.
    ///
    /// To use clearcoat rendering, set `clearcoat` to a value greater than `0.0`.
    ///
    /// This example shows how to set the `clearcoatNormal` using a UV-mapped
    /// image:
    ///
    /// ```swift
    /// if let clearcoatNormalTextureResource = try?
    /// TextureResource.load(named: "entity_cc_normalMap") {
    ///     let ccNormalMap = MaterialParameters.Texture(clearcoatNormalTextureResource)
    ///     material.clearcoatNormal = .init(texture: ccNormalMap)
    /// }
    /// ```
    public var clearcoatNormal: PhysicallyBasedMaterial.ClearcoatNormal
}

/// A component that defines an entity’s behavior in physics body simulations.
///
/// Only entities with a ``RealityKit/PhysicsBodyComponent``
/// and a ``RealityKit/CollisionComponent``
/// can participate in a scene's physics simulation.
/// If you need to move an entity that participates
/// in the physics system, it also needs a ``RealityKit/PhysicsMotionComponent``.
///
/// Add a physics body component to an entity by adopting the ``HasPhysicsBody`` protocol, which
/// allows RealityKit’s physics simulation to compute behavior in response to forces acting upon the body,
/// following basic rules of Newtonian mechanics.
///
/// Note the following when considering applying a non-uniform scale to an entity:
/// - Non-uniform scaling is applicable only to box, convex mesh and triangle mesh collision shapes.
/// - Non-uniform scaling is not supported for all other types of collision shapes. In this case the scale.x
/// value is duplicated to the scale's y and z components as well to force scale uniformity based on the x component.
/// - If the entity has a non-uniform scale assigned to its transform then that entity should not
/// have any descendants assigned that contain rotations in their transforms. A good rule of thumb is to
/// assign the non-uniform scale to the entity that has the collision shape, and avoid adding children below
/// that entity.
///
/// - Note: Model entities have a physics body component by default.
@available(macOS 10.15, iOS 13.0, *)
public struct PhysicsBodyComponent : Component, Equatable {

    /// The behavioral mode that controls the way the physics body moves
    /// and interacts with other physics bodies in a simulation.
    ///
    /// The property's default value is ``PhysicsBodyMode/dynamic``, which means
    /// the physics body responds to forces and can collide with all other
    /// physics bodies in the simulation.
    ///
    /// - Important: Improve the performance of your app by applying `dynamic`
    /// mode to the physics bodies for just entities that need to interact with
    /// all other physics bodies, because each dynamic physics body can be
    /// computationally expensive.
    ///
    /// To configure the physics body so that an entity can move around the
    /// simulation without reacting to forces, set the property to
    /// ``PhysicsBodyMode/kinematic``. Apps typically use
    /// kinematic mode for entities the app programmatically controls,
    /// such as in response to a control or a person's interaction.
    /// For entities that don't need to move at all, set its physics body's mode
    /// to ``PhysicsBodyMode/static``.
    ///
    /// Physics bodies in `static` or `kinematic` mode can't collide with other
    /// physics bodies with either mode, by default.
    /// Optionally, you can add collision support for entities that have a
    /// physics body in either static or kinematic mode by adding a
    /// ``PhysicsSimulationComponent`` to an entity that's a common ancestor to
    /// the entities you want to collide. Then you can set
    /// ``PhysicsSimulationComponent/CollisionOptions`` to your preference.
    ///
    /// You can change the mode of an entity's physics body at any time, but
    /// changing it from `static` to another mode can affect your app's performance
    /// because the transition to a non-static mode can trigger the simulation
    /// to rebuild its state.
    ///
    /// - Tip: Set the mode of an entity's physics body to `static` if you know
    /// the entity doesn't ever need to move; otherwise, set the mode to
    /// `kinematic` or `dynamic`, even if the entity isn't currently moving.
    public var mode: PhysicsBodyMode

    /// The physics body’s mass properties, like inertia and center of mass.
    ///
    /// By default, the mass properties value is
    /// ``PhysicsMassProperties/default``, which matches the properties of a
    /// unit sphere with mass of 1 kilogram.
    public var massProperties: PhysicsMassProperties

    /// The physics body’s material properties, like friction.
    ///
    /// By default, the body’s material resource is set to
    /// ``PhysicsMaterialResource/default``, which provides a modest amount of
    /// friction and restitution (bounciness).
    public var material: PhysicsMaterialResource

    /// A tuple of Boolean values that you use to lock the position of the
    /// physics body along any of the three axes.
    ///
    /// You can restrict movement of the body along one or more axes by setting
    /// the corresponding item in the tuple to `true`. For example, if you set
    /// the `x` and the `z` items in the tuple to `true`, then the body can move
    /// only along the y-axis. By default, movement isn’t restricted.
    public var isTranslationLocked: (x: Bool, y: Bool, z: Bool)

    /// A tuple of Boolean values that you use to lock rotation of the physics
    /// body around any of the three axes.
    ///
    /// For any one of the three Booleans in the tuple that you set to `true`,
    /// rotation is restricted on the axis represented by that item. For
    /// example, if you set the `x` item to true, then the body can’t rotate
    /// around the x-axis. By default, rotation isn’t restricted.
    public var isRotationLocked: (x: Bool, y: Bool, z: Bool)

    /// A Boolean that controls whether the physics simulation performs
    /// continuous collision detection.
    ///
    /// Set the value to `true` to perform continuous collision detection. The
    /// value is `false` by default, indicating the simulation should apply
    /// discrete collision detection.
    ///
    /// Discrete collision detection considers only the position of a body once
    /// per rendered frame, or about every 16 milliseconds at 60 frames per
    /// second. Continuous collision detection considers the position of the
    /// body throughout the frame interval. The latter is more computationally
    /// expensive, but can help to avoid missing a collision for a quickly
    /// moving object, like a projectile.
    public var isContinuousCollisionDetectionEnabled: Bool

    /// Creates a physics body component with default settings.
    ///
    /// For the default settings used in a new physics body component, see the
    /// discussions of the component’s individual properties.
    public init()

    /// Creates a physics body component with the given mass properties,
    /// material, and mode.
    ///
    /// - Parameters:
    ///   - massProperties: The mass properties, like inertia.
    ///
    ///   - material: The material properties, like friction.
    ///
    ///   - mode: The simulation mode that indicates how a body responds to
    ///     forces.
    public init(massProperties: PhysicsMassProperties = .default, material: PhysicsMaterialResource? = nil, mode: PhysicsBodyMode = .dynamic)

    /// Creates a physics body component deriving mass properties from shape and
    /// density.
    ///
    /// - Parameters:
    ///   - shapes: The shape for which to estimate the mass, rotational inertia,
    ///     and center of mass.
    ///
    ///   - density: The density of the object in kilograms per cubic meter.
    ///
    ///   - material: The material properties, like friction.
    ///
    ///   - mode: The simulation mode that indicates how a body responds to
    ///     forces.
    @MainActor @preconcurrency public init(shapes: [ShapeResource], density: Float, material: PhysicsMaterialResource? = nil, mode: PhysicsBodyMode = .dynamic)

    /// Creates a physics body component deriving mass properties from shape and
    /// mass.
    ///
    /// - Parameters:
    ///   - shapes: The shape for which to estimate the rotational inertia and center of mass.
    ///
    ///   - mass: The mass of the object in kilograms.
    ///
    ///   - material: The material properties, like friction.
    ///
    ///   - mode: The simulation mode that indicates how a body responds to
    ///     forces.
    @MainActor @preconcurrency public init(shapes: [ShapeResource], mass: Float, material: PhysicsMaterialResource? = nil, mode: PhysicsBodyMode = .dynamic)

    /// Indicates whether two physics body components are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first physics body component to compare.
    ///
    ///   - rhs: The second physics body component to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two physics body
    /// components are equal.
    public static func == (lhs: PhysicsBodyComponent, rhs: PhysicsBodyComponent) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension PhysicsBodyComponent {

    /// A Boolean value that indicates whether gravity acts on dynamic rigid bodies.
    public var isAffectedByGravity: Bool

    /// The value that controls how fast a dynamic rigid body's translation motion approaches the zero rest state.
    ///
    /// - Important: Use a non-negative value for linear damping.
    public var linearDamping: Float

    /// The value that controls how fast a dynamic rigid body's rotational motion approaches the zero rest state.
    ///
    /// - Important: Use a non-negative value for angular damping.
    public var angularDamping: Float
}

/// The ways that a physics body can move in response to physical forces.
@available(macOS 10.15, iOS 13.0, *)
public enum PhysicsBodyMode : Hashable {

    /// The body never moves.
    case `static`

    /// The user controls body movement.
    case kinematic

    /// Forces and collisions control body movement.
    case dynamic

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsBodyMode, b: PhysicsBodyMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Defines which rigid body inputs are required by a force effect's update handler.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsBodyParameterTypes : Codable, OptionSet {

    /// The center of mass of each rigid body relative to the effect origin.
    public static let position: PhysicsBodyParameterTypes

    /// The orientation of each rigid body relative to the effect orientation.
    public static let orientation: PhysicsBodyParameterTypes

    /// The linear velocity of each rigid body.
    public static let velocity: PhysicsBodyParameterTypes

    /// The angular velocity of each rigid body.
    public static let angularVelocity: PhysicsBodyParameterTypes

    /// The distance of each rigid body from the effect origin.
    public static let distance: PhysicsBodyParameterTypes

    /// The mass of each rigid body,
    public static let mass: PhysicsBodyParameterTypes

    /// The inertia tensor of each rigid body.
    public static let inertiaTensor: PhysicsBodyParameterTypes

    /// The backing storage for force effect inputs.
    public let rawValue: UInt32

    /// - Parameters:
    ///
    ///   - rawValue: The backing data value for force effect inputs.
    public init(rawValue: UInt32)

    /// The type of the elements of an array literal.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias ArrayLiteralElement = PhysicsBodyParameterTypes

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = PhysicsBodyParameterTypes

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias RawValue = UInt32
}

/// A joint with six degrees of freedom that can be individually specified.
///
/// A custom joint allows you to choose the restraints of all 6 degrees of freedom.
/// You can set a ``MotionLimit`` for each degrees' motion.
///
/// - Note: By default all degrees of freedom are locked, similar to ``PhysicsFixedJoint``.
///
/// For example, you can constrain the motion of ``pin1`` in the xy-plane of ``pin1``,
/// set movement along the x-axis to ``MotionLimit/unlimited``,
/// and leave all rotations as the default value of ``MotionLimit/fixed``.
///
/// - Note: The xy-plane is a plane that aligns with the x and y axes.
///
///```swift
/// let joint = PhysicsCustomJoint(
///     pin0: entity0pin,
///     pin1: entity1pin,
///     linearMotionAlongX: .unlimited,
///     linearMotionAlongY: .range(-5...5)
/// )
///```
///
/// If ``pin0`` is in a fixed location for the example above,
/// this joint allows ``pin1`` to move
/// anywhere along the x-axis of ``pin0``,
/// and can move up to 5 local meters above or below the y-axis of ``pin0``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsCustomJoint : PhysicsJoint {

    /// The pin that defines a local position and orientation on the first entity.
    public var pin0: GeometricPin

    /// The pin that defines a local position and orientation on the second entity.
    public var pin1: GeometricPin

    /// A Boolean that indicates whether the joint checks and reports collisions between the two entity instances.
    ///
    /// - Note: This does not affect how collisions of the two entities referenced in ``pin0`` and ``pin1``
    /// interact with other entities.
    public var checksForInternalCollisions: Bool

    /// A Boolean that indicates whether the joint is active.
    ///
    /// Inactive joints do not participate in the physics simulation.
    ///
    /// One example is a joint that does not reference any ``Entity`` with ``PhysicsBodyMode/dynamic``,
    /// or when one or both the referenced entities are not active.
    public var isActive: Bool { get }

    /// Specifies allowed linear or angular motion.
    public enum MotionLimit : Equatable {

        case fixed

        case unlimited

        case range(ClosedRange<Float>)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PhysicsCustomJoint.MotionLimit, b: PhysicsCustomJoint.MotionLimit) -> Bool
    }

    /// The linear motion limits along the x-axis.
    ///
    /// This property sets the limits of ``pin1`` along the x-axis of ``pin0``.
    public var linearMotionAlongX: PhysicsCustomJoint.MotionLimit

    /// The linear motion limits along the y-axis.
    ///
    /// This property sets the limits of ``pin1`` along the y-axis of ``pin0``.
    public var linearMotionAlongY: PhysicsCustomJoint.MotionLimit

    /// The linear motion limits along the z-axis.
    ///
    /// This property sets the limits of ``pin1`` along the z-axis of ``pin0``.
    public var linearMotionAlongZ: PhysicsCustomJoint.MotionLimit

    ///  The angular motion limits around the x-axis.
    ///
    ///  This property sets the limits of ``pin1`` around the x-axis of ``pin0``.
    public var angularMotionAroundX: PhysicsCustomJoint.MotionLimit

    ///  The angular motion limits around the y-axis.
    ///
    ///  This property sets the limits of ``pin1`` around the y-axis of ``pin0``.
    public var angularMotionAroundY: PhysicsCustomJoint.MotionLimit

    ///  The angular motion limits around the z-axis.
    ///
    ///  This property sets the limits of ``pin1`` around the z-axis of ``pin0``.
    public var angularMotionAroundZ: PhysicsCustomJoint.MotionLimit

    /// Creates a new custom joint.
    ///
    /// - Parameters:
    ///   - pin0: The local position and orientation on the first entity.
    ///   - pin1: The local position and orientation on the second entity.
    ///   - linearMotionAlongX: The linear motion limits along the x-axis.
    ///   - linearMotionAlongY: The linear motion limits along the y-axis.
    ///   - linearMotionAlongZ: The linear motion limits along the z-axis.
    ///   - angularMotionAroundX: The angular motion limits around the x-axis.
    ///   - angularMotionAroundY: The angular motion limits around the y-axis.
    ///   - angularMotionAroundZ: The angular motion limits around the z-axis.
    ///   - checksForInternalCollisions: A Boolean that indicates whether the joint
    ///     checks for collisions between the two ``Entity`` instances.
    public init(pin0: GeometricPin, pin1: GeometricPin, linearMotionAlongX: PhysicsCustomJoint.MotionLimit = .fixed, linearMotionAlongY: PhysicsCustomJoint.MotionLimit = .fixed, linearMotionAlongZ: PhysicsCustomJoint.MotionLimit = .fixed, angularMotionAroundX: PhysicsCustomJoint.MotionLimit = .fixed, angularMotionAroundY: PhysicsCustomJoint.MotionLimit = .fixed, angularMotionAroundZ: PhysicsCustomJoint.MotionLimit = .fixed, checksForInternalCollisions: Bool = false)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsCustomJoint, b: PhysicsCustomJoint) -> Bool
}

/// A joint that maintains a minimum and maximum distance between two entity pins.
///
/// A distance joint restricts the distance between ``pin0`` and ``pin1``.
/// The joint determines this closed range according to ``distanceLimit``.
///
/// This joint allows full rotational freedom between ``pin0`` and ``pin1``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsDistanceJoint : PhysicsJoint {

    /// The pin that defines a local position and orientation on the first entity.
    public var pin0: GeometricPin

    /// The pin that defines a local position and orientation on the second entity.
    public var pin1: GeometricPin

    /// A Boolean that indicates whether the joint checks and reports collisions between the two entity instances.
    ///
    /// - Note: This does not affect how collisions of the two entities referenced in ``pin0`` and ``pin1``
    /// interact with other entities.
    public var checksForInternalCollisions: Bool

    /// A Boolean that indicates whether the joint is active.
    ///
    /// Inactive joints do not participate in the physics simulation.
    ///
    /// One example is a joint that does not reference any ``Entity`` with ``PhysicsBodyMode/dynamic``,
    /// or when one or both the referenced entities are not active.
    public var isActive: Bool { get }

    /// Specifies the minimum and maximum allowed distance between the pins.
    public var distanceLimit: ClosedRange<Float>

    /// An extension of the distance limit, as a percentage-based error tolerance.
    ///
    /// For example, a tolerance of `0.01` extends the distance limit by `1` percent.
    /// When the pins exceed this distance,
    /// the joint constrains the pins until they are within the distance limit.
    ///
    /// - Important: Use a non-negative value for the tolerance.
    public var tolerance: Float

    /// Creates a new distance joint.
    ///
    /// - Parameters:
    ///   - pin0: The local position and orientation on the first entity.
    ///   - pin1: The local position and orientation on the second entity.
    ///   - distanceLimit: Specifies the minimum and maximum allowed
    ///     distance between the two pins.
    ///   - checksForInternalCollisions: A Boolean that indicates whether the joint
    ///     checks for collisions between the two ``Entity`` instances.
    public init(pin0: GeometricPin, pin1: GeometricPin, distanceLimit: ClosedRange<Float>, checksForInternalCollisions: Bool = false)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsDistanceJoint, b: PhysicsDistanceJoint) -> Bool
}

/// A joint that rigidly connects two entity pins, with zero degrees of freedom.
///
/// A fixed joint connects two ``GeometricPin`` instances,
/// ``pin0`` and ``pin1``, so that their poses coincide.
///
/// There are zero degrees of rotational or linear freedom between the two pins.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsFixedJoint : PhysicsJoint {

    /// The pin that defines a local position and orientation on the first entity.
    public var pin0: GeometricPin

    /// The pin that defines a local position and orientation on the second entity.
    public var pin1: GeometricPin

    /// A Boolean that indicates whether the joint checks and reports collisions between the two entity instances.
    ///
    /// The entities that ``PhysicsFixedJoint`` references are not checked or reported,
    /// so this property only returns `false`.
    public let checksForInternalCollisions: Bool

    /// A Boolean that indicates whether the joint is active.
    ///
    /// Inactive joints do not participate in the physics simulation.
    ///
    /// One example is a joint that does not reference any ``Entity`` with ``PhysicsBodyMode/dynamic``,
    /// or when one or both the referenced entities are not active.
    public var isActive: Bool { get }

    /// Creates a new fixed joint.
    ///
    /// - Parameters:
    ///   - pin0: The local position and orientation on the first entity.
    ///   - pin1: The local position and orientation on the second entity.
    public init(pin0: GeometricPin, pin1: GeometricPin)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsFixedJoint, b: PhysicsFixedJoint) -> Bool
}

/// A type that describes physics joints.
///
/// `PhysicsJoint` objects are transient and define physics joints properties.
/// ``PhysicsJointsComponent`` stores physics joints when added to an entity.
///
/// Each `PhysicsJoint` references two entities at local poses (position and orientation) specified on each ``Entity``.
///
/// The two pins of a physics joint, ``pin0`` and ``pin1``, each reference poses on the entities that make up each point on a `PhysicsJoint`.
/// Use two unique entities that both have a ``PhysicsBodyComponent``,
/// and belong to the same physics simulation.
///
/// Joints specify linear and angular limits of motion, limiting the motion of the second pin (``pin1``)
/// relative to the first pin (``pin0``).
///
/// To become active, the `PhysicsJoint` needs to be added to a ``PhysicsJointsComponent``  This is achieved by either directly on the component,
/// or by calling ``addToSimulation()``.
/// Once you add the joint to the simulation context, you no longer need to reference `PhysicsJoint` directly in your code.
///
/// For example, a ``PhysicsRevoluteJoint`` that connects a window, `windowEntity`, to a window frame, `frameEntity`:
///
///```swift
/// let parentSimulationEntity = Entity()
/// // Add PhysicsSimulationComponent to parentSimulationEntity...
///
/// let frameEntity = Entity()
/// let windowEntity = Entity()
/// // Add PhysicsBodyComponents to the entities...
///
/// // Create a hinge the references points on the entities.
/// let windowWidth: Float = 1
/// let framePin = frameEntity.pins.set(
///     named: "FrameHinge",
///     // In this example, center of the frame is the center of its bounding box,
///     // so the hinge is half its width to the negative x direction.
///     position: [-windowWidth / 2, 0, 0],
///     // This hinge rotates around the x-axis, but this window needs to
///     // rotate around the y-axis.
///     // This rotation modifies the pin's positive x-axis to the positive y-axis.
///     orientation: simd_quatf(from: [1, 0, 0], to: [0, 1, 0])
/// )
///
/// // Get a previously created GeometricPin from `windowEntity`,
/// // or a new one create one as above.
/// let windowPin = GeometricPin(entity: windowEntity, pinName: "WindowHinge")
///
/// let windowHingeJoint = PhysicsRevoluteJoint(
///     pin0: framePin,
///     pin1: windowPin,
///     // Allow the hinge to rotate up to 90º.
///     angularLimit: 0...Float.pi
/// )
/// try windowHingeJoint.addToSimulation()
/// ```
///
/// **Best practices:**
///
/// - When creating a joint, make sure that the jointed entities are initially positioned so that they satisfy the joint.
///   If not done so, the physics solver may have difficulty bringing the entities together to satisfy the joint.
///
/// - When connecting a ``PhysicsBodyMode/kinematic`` and a ``PhysicsBodyMode/dynamic`` entities by a joint,
///   use ``pin0`` as the pin on the kinematic entity.\
///   If both are ``PhysicsBodyMode/dynamic``, set the heavier entity as ``pin0``.
///
/// - Aim to make the entities connected by joints similar in mass.
///
/// - Add a ``PhysicsSimulationComponent`` to a common ancestor when creating
/// `PhysicsJoint` instances, to make it clear which physics simulation is used to solve the joints.
///
/// - To improve the the solving of the joints, adjust the value of the ``PhysicsSimulationComponent/solverIterations-swift.property`` property.
///
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public protocol PhysicsJoint : Equatable {

    /// The pin that defines a local position and orientation on the first entity.
    var pin0: GeometricPin { get set }

    /// The pin that defines a local position and orientation on the second entity.
    var pin1: GeometricPin { get set }

    /// A Boolean that indicates whether the joint checks and reports collisions between the two entity instances.
    ///
    /// - Note: This does not affect how collisions of the two entities referenced in ``pin0`` and ``pin1``
    /// interact with other entities.
    var checksForInternalCollisions: Bool { get }

    /// A Boolean that indicates whether the joint is active.
    ///
    /// Inactive joints do not participate in the physics simulation.
    ///
    /// One example is a joint that does not reference any ``Entity`` with ``PhysicsBodyMode/dynamic``,
    /// or when one or both the referenced entities are not active.
    var isActive: Bool { get }
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension PhysicsJoint {

    /// Adds this joint to the simulation.
    ///
    /// This method looks for an ancestral ``Entity`` that has ``PhysicsJointsComponent``
    /// by traversing upwards from the entity referenced by ``pin0``.
    ///
    /// If found, it adds the joint to that ancestor's ``PhysicsJointsComponent``.
    ///
    /// The traversal stops when reaching an ``Entity`` with ``PhysicsSimulationComponent``,
    /// or when it cannot traverse up anymore.
    /// In the former case it adds the joint to ``PhysicsJointsComponent/joints``.
    /// In the latter case it adds ``PhysicsJointsComponent``
    /// to the first ``Entity`` referenced by the joint, and adds the joint to the newly created ``PhysicsJointsComponent``.
    ///
    /// - Returns: The entity that owns the ``PhysicsJointsComponent``, which this joint has been added to.
    ///
    /// - Throws: When the joint contains invalid data.
    @discardableResult
    @MainActor public func addToSimulation() throws -> Entity
}

/// A collection of physics joints.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsJoints : BidirectionalCollection, MutableCollection, RangeReplaceableCollection, Equatable, ExpressibleByArrayLiteral {

    /// Creates a new, empty collection.
    public init()

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral: any PhysicsJoint...)

    public init(_ sequence: any Sequence<any PhysicsJoint>)

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public let startIndex: Int

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// A type representing the sequence's elements.
    public typealias Element = PhysicsJoint

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// For example, you can replace an element of an array by using its
    /// subscript.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one
    /// past the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: Int) -> any PhysicsJoint

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    public mutating func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: C) where C : Collection, C.Element == any PhysicsJoint

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: PhysicsJoints, rhs: PhysicsJoints) -> Bool

    /// The type of the elements of an array literal.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias ArrayLiteralElement = any PhysicsJoint

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = DefaultIndices<PhysicsJoints>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Iterator = IndexingIterator<PhysicsJoints>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<PhysicsJoints>
}

/// A component that stores physics joints which RealityKit simulates.
///
/// Add this component to an entity, or any child of an entity, that has a ``PhysicsSimulationComponent``.
/// All joints in the `PhysicsJointsComponent` need to reference entities
/// under the same ``PhysicsSimulationComponent`` tree.
///
/// Add a joint to the correct `PhysicsJointsComponent` instance
/// by calling its ``PhysicsJoint/addToSimulation()-886c4`` method.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsJointsComponent : Component, Equatable {

    /// Creates a new physics joints component.
    ///
    /// The initializer sets the component's ``PhysicsJointsComponent/joints`` property to an empty set.
    public init()

    /// The set of joints the physics joints component stores.
    ///
    /// Add a joint to the correct ``PhysicsJointsComponent`` instance
    /// by calling its ``PhysicsJoint/addToSimulation()-886c4`` method.
    public var joints: PhysicsJoints

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsJointsComponent, b: PhysicsJointsComponent) -> Bool
}

/// Mass properties of a physics body.
@available(macOS 10.15, iOS 13.0, *)
public struct PhysicsMassProperties : Equatable {

    /// The default mass properties, equivalent to a unit sphere with a mass of
    /// 1 kilogram.
    public static let `default`: PhysicsMassProperties

    /// The mass in kilograms.
    ///
    /// For a mass of `0` or infinity, the simulation treats the object as
    /// ``PhysicsBodyMode/kinematic``. That is, the object doesn’t respond to
    /// forces.
    public var mass: Float

    /// The inertia in kilograms per square meter.
    ///
    /// The vector contains the diagonal elements of the diagonalized inertia
    /// matrix.
    public var inertia: SIMD3<Float>

    /// The position of the center of mass and the orientation of the principal
    /// axes.
    ///
    /// The `position` defines the center of mass with a default value of `(0,
    /// 0, 0)`, which means that the local origin of the model is the center of
    /// mass.
    ///
    /// The `orientation` defines the principal axes, such the inertia matrix is
    /// a diagonal.
    public var centerOfMass: (position: SIMD3<Float>, orientation: simd_quatf)

    /// Creates a mass properties instance with default settings.
    public init()

    /// Creates a mass properties instance with the given settings.
    ///
    /// - Parameters:
    ///   - mass: The mass in kilograms. If you use a mass of `0` or infinity, the
    ///     simulation treats the object as ``PhysicsBodyMode/kinematic``. That is,
    ///     the object doesn’t respond to forces.
    ///
    ///   - inertia: The inertia in kilograms per square meter. The vector
    ///     contains the diagonal elements of the diagonalized inertia matrix.
    ///
    ///   - centerOfMass: The center of mass and the orientation of the principal
    ///     axes, defined in the local space of the rigid body.
    ///
    ///     The `position` defines the center of mass with a default value of `(0, 0, 0)`, which
    ///     means that the local origin of the model is the center of mass.
    ///
    ///     The `orientation` defines the principal axes, such the inertia matrix is a diagonal.
    public init(mass: Float, inertia: SIMD3<Float> = SIMD3<Float>(x: 0.1, y: 0.1, z: 0.1), centerOfMass: (position: SIMD3<Float>, orientation: simd_quatf) = (SIMD3<Float>(x: 0, y: 0, z: 0), simd_quatf(ix: 0, iy: 0, iz: 0, r: 1)))

    /// Creates the mass properties for a solid shape with the specified
    /// density.
    ///
    /// - Parameters:
    ///   - shape: The shape for which to calculate the mass frame.
    ///
    ///   - density: The density of the object in kilograms per cubic meter.
    @MainActor @preconcurrency public init(shape: ShapeResource, density: Float)

    /// Creates the mass properties for a solid shape with the specified mass.
    ///
    /// - Parameters:
    ///   - shape: The shape for which to calculate the mass frame.
    ///
    ///   - mass: The mass of the object in kilograms.
    @MainActor @preconcurrency public init(shape: ShapeResource, mass: Float)

    /// Indicates whether two physics mass properties are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first set of physics mass properties to compare.
    ///
    ///   - rhs: The second set of physics mass properties to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two physics mass
    /// properties are equal.
    public static func == (lhs: PhysicsMassProperties, rhs: PhysicsMassProperties) -> Bool
}

/// Material properties, like friction, of a physically simulated object.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class PhysicsMaterialResource : Resource {

    /// A default material resource.
    @MainActor @preconcurrency public static let `default`: PhysicsMaterialResource

    /// Generates a new material with the given characteristics.
    ///
    /// - Parameters:
    ///   - friction: The coefficient of friction, in the range `[0, infinity)`.
    ///
    ///   - restitution: The coefficient of restitution, in the range `[0, 1]`.
    ///     Use values at the high end of the range to indicate materials that
    ///     experience elastic collisions, meaning that objects bounce off each
    ///     other and kinetic energy is conserved after a collision. Use low values
    ///     to indicate materials that lose kinetic energy when they collide.
    ///
    /// - Returns: A physics material resource.
    @MainActor @preconcurrency public static func generate(friction: Float = 0.8, restitution: Float = 0.8) -> PhysicsMaterialResource

    /// Creates a new material with the specified static friction, dynamic friction, and restitution.
    ///
    /// - Parameters:
    ///   - staticFriction:     The static (stationary) friction coefficient in the range [0, ∞).
    ///   - dynamicFriction:     The dynamic (moving) friction coefficient in the range [0, ∞).
    ///   - restitution:  The coefficient of restitution (bounciness) in the range [0, 1].
    @available(macOS 10.15.4, iOS 13.4, *)
    @MainActor @preconcurrency public static func generate(staticFriction: Float, dynamicFriction: Float, restitution: Float) -> PhysicsMaterialResource
}

/// A component that controls the motion of the body in physics simulations.
///
/// You specify velocities in the coordinate space of the physics simulation
/// defined by ``PhysicsSimulationComponent/nearestSimulationEntity(for:)``.
///
/// The behavior of an entity with a physics motion component depends on the
/// entity’s ``PhysicsBodyComponent/mode`` setting:
///
/// - term ``PhysicsBodyMode/static``: The physics simulation ignores the
/// velocities. The entity doesn’t move.
/// - term ``PhysicsBodyMode/kinematic``:
/// The physics simulation moves the body according to the values you set for
/// ``PhysicsMotionComponent/angularVelocity`` and
/// ``PhysicsMotionComponent/linearVelocity``.
/// - term ``PhysicsBodyMode/dynamic``: The physics simulation overwrites the velocity
/// values based on simulation, and ignores any values that you write.
@available(macOS 10.15, iOS 13.0, *)
public struct PhysicsMotionComponent : Component, Equatable {

    /// The linear velocity of the body in the physics simulation.
    public var linearVelocity: SIMD3<Float>

    /// The angular velocity of the body around the center of mass.
    public var angularVelocity: SIMD3<Float>

    /// Creates a physics motion component at rest.
    public init()

    /// Creates a physics motion component with the given velocities.
    public init(linearVelocity: SIMD3<Float> = .zero, angularVelocity: SIMD3<Float> = .zero)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsMotionComponent, b: PhysicsMotionComponent) -> Bool
}

/// A joint that allows movement along a straight line, similar to a sliding drawer.
///
/// `PhysicsPrismaticJoint`, also called a "slider joint",
/// allows one linear degree of freedom along the x-axis between two ``Entity`` pins.
///
/// - Tip: Pass an orientation when creating the ``GeometricPin`` instances to change the axis of rotation.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsPrismaticJoint : PhysicsJoint {

    /// The pin that defines a local position and orientation on the first entity.
    public var pin0: GeometricPin

    /// The pin that defines a local position and orientation on the second entity.
    public var pin1: GeometricPin

    /// A Boolean that indicates whether the joint checks and reports collisions between the two entity instances.
    ///
    /// - Note: This does not affect how collisions of the two entities referenced in ``pin0`` and ``pin1``
    /// interact with other entities.
    public var checksForInternalCollisions: Bool

    /// A Boolean that indicates whether the joint is active.
    ///
    /// Inactive joints do not participate in the physics simulation.
    ///
    /// One example is a joint that does not reference any ``Entity`` with ``PhysicsBodyMode/dynamic``,
    /// or when one or both the referenced entities are not active.
    public var isActive: Bool { get }

    /// A limit of the translation between the pins in the direction of the x-axis.
    ///
    /// If defined, this limits the translation of ``pin1`` from ``pin0``, in the direction of the x-axis of ``pin0``.
    /// There is no limit if this property is `nil`.
    public var linearLimit: ClosedRange<Float>?

    /// Creates a new prismatic joint.
    ///
    /// - Parameters:
    ///   - pin0: The local position and orientation on the first entity.
    ///   - pin1: The local position and orientation on the second entity.
    ///   - linearLimit: A limit of the the translation of `pin1` from `pin0`
    ///     in the direction of the x-axis of `pin0`.
    ///   - checksForInternalCollisions: A Boolean that indicates whether the joint
    ///     checks for collisions between the two ``Entity`` instances.
    public init(pin0: GeometricPin, pin1: GeometricPin, linearLimit: ClosedRange<Float>? = nil, checksForInternalCollisions: Bool = false)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsPrismaticJoint, b: PhysicsPrismaticJoint) -> Bool
}

/// A joint that allows one degree of rotational freedom between two entity pins,
/// similar to a door swinging on its hinges.
///
/// `PhysicsRevoluteJoint` allows one rotational degree of freedom
/// along the x-axis of two entity pins.
///
/// > Tip: Pass an orientation when creating the ``GeometricPin`` instances to change the axis of rotation.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsRevoluteJoint : PhysicsJoint {

    /// The pin that defines a local position and orientation on the first entity.
    public var pin0: GeometricPin

    /// The pin that defines a local position and orientation on the second entity.
    public var pin1: GeometricPin

    /// A Boolean that indicates whether the joint checks and reports collisions between the two entity instances.
    ///
    /// - Note: This does not affect how collisions of the two entities referenced in ``pin0`` and ``pin1``
    /// interact with other entities.
    public var checksForInternalCollisions: Bool

    /// A Boolean that indicates whether the joint is active.
    ///
    /// Inactive joints do not participate in the physics simulation.
    ///
    /// One example is a joint that does not reference any ``Entity`` with ``PhysicsBodyMode/dynamic``,
    /// or when one or both the referenced entities are not active.
    public var isActive: Bool { get }

    /// A limit of the rotational freedom between the pins around the x-axis.
    ///
    /// If defined, this limits the rotation of ``pin1`` around the x-axis of ``pin0``.
    /// There is no limit if this property is `nil`.
    public var angularLimit: ClosedRange<Float>?

    /// Creates a new revolute joint.
    ///
    /// - Parameters:
    ///   - pin0: The local position and orientation on the first entity.
    ///   - pin1: The local position and orientation on the second entity.
    ///   - angularLimit: Limits of the rotation around the pin's x-axis if defined.
    ///   - checksForInternalCollisions: A Boolean that indicates whether the joint
    ///     checks for collisions between the two ``Entity`` instances.
    public init(pin0: GeometricPin, pin1: GeometricPin, angularLimit: ClosedRange<Float>? = nil, checksForInternalCollisions: Bool = false)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsRevoluteJoint, b: PhysicsRevoluteJoint) -> Bool
}

/// A component that controls localized physics simulations.
///
/// Simulate local physics by adding a ``PhysicsSimulationComponent`` to an entity.
/// The component gives your app the ability to customize the physics simulation
/// by configuring its properties, such as ``gravity`` and ``collisionOptions``.
///
/// - Important: Each physics simulation component uses meters as its unit of distance,
/// which can be important to other types in the physics simulation, such as
/// ``ShapeResource`` instances.
///
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct PhysicsSimulationComponent : Component, Equatable {

    /// The options set that defines how a physics simulation reports collisions.
    public struct CollisionOptions : OptionSet {

        /// Opts out of reporting collisions.
        public static let none: PhysicsSimulationComponent.CollisionOptions

        /// Reports collisions between kinematic objects and static objects.
        public static let reportKinematicVsStatic: PhysicsSimulationComponent.CollisionOptions

        /// Reports collisions between kinematic objects.
        public static let reportKinematicVsKinematic: PhysicsSimulationComponent.CollisionOptions

        /// Reports collisions between kinematic objects and both static and kinematic objects.
        public static let all: PhysicsSimulationComponent.CollisionOptions

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: UInt8

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: UInt8)

        /// The type of the elements of an array literal.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias ArrayLiteralElement = PhysicsSimulationComponent.CollisionOptions

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias Element = PhysicsSimulationComponent.CollisionOptions

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias RawValue = UInt8
    }

    /// The parameters that control the accuracy of solving physics simulations.
    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    public struct SolverIterations : Equatable {

        /// Creates a solver iterations configuration.
        ///
        /// - Parameters:
        ///   - positionIterations: The number of position iterations the solver performs,
        ///     in the inclusive range `[1, 255]`.
        ///     The default value is `6`.
        ///   - velocityIterations: The number of velocity iterations the solver performs,
        ///     in the inclusive range `[1, 255]`.
        ///     The default value is `1`.
        public init(positionIterations: Int = 6, velocityIterations: Int = 1)

        /// The number of position iterations the solver performs.
        ///
        /// Use a value in the inclusive range `[1, 255]`.
        /// The default value is `6`.
        public var positionIterations: Int

        /// The number of velocity iterations the solver performs.
        ///
        /// Use a value in the inclusive range `[1, 255]`.
        /// The default value is `1`.
        public var velocityIterations: Int

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PhysicsSimulationComponent.SolverIterations, b: PhysicsSimulationComponent.SolverIterations) -> Bool
    }

    /// The parameters that control the accuracy of solving physics simulations.
    @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
    public var solverIterations: PhysicsSimulationComponent.SolverIterations

    /// Obtains the entity containing the physics simulation origin.
    ///
    /// The simulation origin is the nearest parent object where a ``PhysicsSimulationComponent``
    /// exists, or the root entity (normally the anchor) where the default simulation is embedded.
    ///
    ///  - Parameters:
    ///    - entity: The entity to find the physics simulation origin for.
    ///
    ///  - Returns:The entity containing the physics simulation origin or `nil` if the entity doesn't have a parent object in the scene.
    public static func nearestSimulationEntity(for entity: Entity) -> Entity?

    public init()

    /// The gravity for the simulation relative to the simulation entity.
    ///
    /// The value stored in this property is the gravitational acceleration applied to dynamic physics body entities every frame along the negative world y-axis.
    /// The default value is `-9.81` meters per second squared.
    public var gravity: SIMD3<Float>

    /// Options for kinematic collision reporting.
    public var collisionOptions: PhysicsSimulationComponent.CollisionOptions

    /// A custom clock which drives the physics simulation, defaults to the engine clock.
    public var clock: CMClockOrTimebase

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PhysicsSimulationComponent, b: PhysicsSimulationComponent) -> Bool
}

/// Types of events that fire during physics simulations
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public enum PhysicsSimulationEvents {

    /// The event raised before the simulation advances to the current frame.
    public struct WillSimulate : Event {

        /// The time between the last fixed update event and this one.
        public let deltaTime: TimeInterval

        /// The root simulation entity associated with the simulation that raised the event.
        public let simulationEntity: Entity
    }

    /// The event raised after the simulation advances to the current frame.
    public struct DidSimulate : Event {

        /// The time between last fixed update event and this one.
        public let deltaTime: TimeInterval

        /// The root simulation entity associated with the simulation that raised the event.
        public let simulationEntity: Entity
    }
}

/// A spherical joint that allows free rotational movement between two entities' pins.
///
/// This joint has three rotational degrees of freedom and
/// removes all translational degrees of freedom by making the positions of
/// ``pin0`` and ``pin1`` coincide.
/// This is also called a "ball-socket joint".
///
/// To add limits to the rotational freedom of ``pin1``,
/// define a tuple value for ``angularLimitInYZ``.
/// This tuple defines an elliptical cone shape around the x-axis of ``pin0``,
/// which limits the rotational freedom of ``pin1``.
/// The rotation around the x-axis is never limited with this joint.
///
/// > Tip: Pass an orientation when creating the ``GeometricPin`` instances to change the axis of rotation.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PhysicsSphericalJoint : PhysicsJoint {

    /// The pin that defines a local position and orientation on the first entity.
    public var pin0: GeometricPin

    /// The pin that defines a local position and orientation on the second entity.
    public var pin1: GeometricPin

    /// A Boolean that indicates whether the joint checks and reports collisions between the two entity instances.
    ///
    /// - Note: This does not affect how collisions of the two entities referenced in ``pin0`` and ``pin1``
    /// interact with other entities.
    public var checksForInternalCollisions: Bool

    /// A Boolean that indicates whether the joint is active.
    ///
    /// Inactive joints do not participate in the physics simulation.
    ///
    /// One example is a joint that does not reference any ``Entity`` with ``PhysicsBodyMode/dynamic``,
    /// or when one or both the referenced entities are not active.
    public var isActive: Bool { get }

    /// A cone-shaped limit of rotational freedom.
    ///
    /// The maximum value of rotation in radians from the y and z axes, or `nil` for unlimited.
    ///
    /// This pair defines an elliptical cone limit around the x-axis of the pose on the first entity, ``pin0``.
    /// If defined, the x-axis of the pose on the second entity (``pin1``) is limited to stay within this cone.
    public var angularLimitInYZ: (Float, Float)?

    /// Creates a new spherical joint.
    ///
    /// An elliptical cone is formed around the x-axis to limit the motion of `pin1`
    /// if `angularLimitInYZ` is defined.
    ///
    /// If `angularLimitInYZ` is undefined, `pin1` has full 360º rotational freedom in all axes.
    ///
    /// - Parameters:
    ///   - pin0: The local position and orientation on the first entity.
    ///   - pin1: The local position and orientation on the second entity.
    ///   - angularLimitInYZ: A maximum value of rotation in radians from the y and z axes if defined.
    ///   - checksForInternalCollisions: A Boolean that indicates whether the joint
    ///     checks for collisions between the two ``Entity`` instances.
    public init(pin0: GeometricPin, pin1: GeometricPin, angularLimitInYZ: (Float, Float)? = nil, checksForInternalCollisions: Bool = false)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: PhysicsSphericalJoint, rhs: PhysicsSphericalJoint) -> Bool
}

/// An action that plays an animation on the given target entity with a range of playback options.
///
/// Use this action to initiate the playback of animations in a data-driven way.
/// For example, this action can play an animation group which contains a nested action, which plays
/// another animation with specific playback properties.
///
/// This action plays the ``AnimationResource`` from the``AnimationLibraryComponent`` on the
/// ``PlayAnimationAction/targetEntity``. Add all animations to the animation library
/// component that this action will play, ensuring the name of the animation matches the ``PlayAnimationAction/animationName``
/// being supplied.
///
/// ``PlayAnimationAction/useParentedControllers`` is used to determine the playback
/// behavior of the animation this action is playing. Set this to `true` to control the playback of the
/// animation. Calling methods such as ``AnimationPlaybackController/pause()`` and
/// ``AnimationPlaybackController/resume()`` on the animation playback controller generated
/// from this action will give you control of the animation being played. When the action ends, the animation playback
/// also ends.
/// Set this to `false` to ensure the animation being played runs independently of the action. This would behave as
/// a one shot animation.
///
/// The example below is the animation group that the action will play. This contains a sequence containing
/// a single ``FromToByAnimation<Transform>``, and character animation.
///
///```swift
/// // Create an animation group sequence from a range of animations.
/// let finalAnimation = try AnimationResource
///     .group(with: [walkAnimation, moveToAnimation])
///```
///
/// The example below creates an animation sequence. The final animation in the sequence is an animation generated from the action.
/// This action plays an animation that exist within the ``PlayAnimationAction/targetEntity`` ``AnimationLibraryComponent``.
///
/// ```swift
/// // An action which plays an animation, with parented controllers.
/// let playAnimationAction = PlayAnimationAction(animationName: "finalAnimation",
///                                               transitionDuration: 0.2,
///                                               useParentedControllers: true)
///
/// // Creates an animation from the action.
/// //
/// // Parented controllers is active. This ensures the action
/// // plays the entire length of the animation that is being played.
/// //
/// // The parameter `finalAnimationDuration` is set to the length
/// // of the animation group to play.
/// let finalPlayAnimation = try AnimationResource
///     .makeActionAnimation(for: playAnimationAction,
///                          duration: finalAnimationDuration)
///
/// // Create a sequence of animations that will play. 
/// //
/// // The action will play last in the sequence.
/// let animationSequence = try AnimationResource
///     .sequence(with: [idleAnimation, startWalkAnimation, finalPlayAnimation])
///
/// // Play the sequence animation that will play the action last.
/// let animationPlaybackController = entity.playAnimation(animationSequence)
/// ```
///
/// - Note: If ``PlayAnimationAction/useParentedControllers`` is set to `true`, the animation will play for the
///         duration of the action. Set the duration of the action to match the length of the animation being played
///         to ensure the entire animation plays.
///
/// - Important: This action does not animate a bound property, such as ``BindTarget/transform``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PlayAnimationAction : EntityAction, Codable {

    /// The name of the animation resource within the target entity animation library component to start playing.
    public var animationName: String

    /// The duration in seconds over which the animation fades in or cross-fades.
    public var transitionDuration: TimeInterval

    /// An integer that specifies the order in which to apply animations when more than one animation is playing.
    ///
    /// Animations in a lower layer are applied before animations in a higher layer. Animations in
    /// the same layer are applied in the order in which the animations where started.
    public var blendLayer: Int

    /// When set to false, this value indicates that the animation will write directly to the entity's base value.
    /// When set to true, this value indicates that the animation will write to an interim value for
    /// the duration of the animation. If this value is set to true then when the
    /// animation completes, the entity's value will be reset to the base value.
    public var separateAnimatedValue: Bool

    /// Type of handoff behavior between a currently-playing animation
    /// and the new animation.
    public var handoffType: AnimationHandoffType

    /// The entity to play the animation.
    public var targetEntity: ActionEntityResolution

    /// A Boolean that indicates whether to parent the new animation's controller to the controller managing this action.
    ///
    /// Setting the value of this property to true indicates the action has control over the playback of the animation.
    /// Setting this to false indicates the animation plays independently from the action, behaving as a one shot animation
    public var useParentedControllers: Bool

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public var animatedValueType: (any AnimatableData.Type)? { get }

    /// Creates a new play animation action.
    ///
    /// - Parameters:
    ///    - animationName: The name of the animation resource within the target entity animation library component to start playing.
    ///    - targetEntity: The entity to play the animation.
    ///    - transitionDuration: The duration in seconds over which the animation fades in or cross-fades.
    ///    - blendLayer: An integer that specifies the order in which to apply animations when more than one animation is playing.
    ///    - separateAnimatedValue: When set to false, this value indicates that the animation will write directly to the entity's base value.
    ///                              When set to true, this value indicates that the animation will write to an interim value for
    ///                              the duration of the animation. If this value is set to true then when the
    ///                              animation completes, the entity's value will be reset to the base value.
    ///    - useParentedControllers: Whether to parent the new animation's controller to the controller managing this action.
    ///    - handoffType: Type of handoff behavior between a currently-playing animation and the new animation.
    public init(animationName: String, targetEntity: ActionEntityResolution = .sourceEntity, transitionDuration: TimeInterval = 0.0, blendLayer: Int = 0, separateAnimatedValue: Bool = true, useParentedControllers: Bool = false, handoffType: AnimationHandoffType = .compose)

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// An action which plays an audio resource on the given target entity.
///
/// Use this action to initiate the playback of audio in a data-driven way.
/// For example, this action can play an animation group which contains a nested action,
/// which plays audio with specific playback properties.
///
/// This action plays the ``AudioResource`` from the ``AudioLibraryComponent`` on the
/// ``PlayAudioAction/targetEntity``. Add all audio resources to the audio library
/// component that this action will play, ensuring the name of the audio matches the ``PlayAudioAction/audioResourceName``
/// being supplied.
///
/// ``PlayAudioAction/useControlledPlayback`` is used to determine the playback behavior of
/// the audio this action is playing. Set this to `true` to control the playback of the audio.
/// Calling methods such as ``AnimationPlaybackController/pause()`` and
/// ``AnimationPlaybackController/resume()`` on the animation playback controller
/// generated from this action will give you control of the audio being played. When the action ends,
/// the audio playback also ends.
/// Set this to `false` to ensure the audio being played runs independently of the action. This would behave
/// as a one shot audio.
///
/// The example below creates an animation which will play an audio resource after five seconds.
///
/// ```swift
/// // Create an action which plays a specified audio resource.
/// //
/// // The audio resource exists within the target entity's
/// // animation library component.
/// //
/// // Control playback is set to false, audio will
/// // play independently of the animation.
/// let snapAudioAction = PlayAudioAction(audioResourceName: "snap",
///                                       useControlledPlayback: false)
///
/// // Creates an animation from the action, with a five second delay.
/// let snapAudioAnimation = try AnimationResource
///     .makeActionAnimation(for: snapAudioAction,
///                          delay: 5.0)
///
/// // Play the animation which will play the audio after five seconds.
/// entity.playAnimation(snapAudioAnimation)
/// ```
///
/// - Note: If ``PlayAudioAction/useControlledPlayback`` is set to `true`, the animation will play
///         for the duration of the action. Set the duration of the action to match the length of the audio being played
///         to ensure the entire audio plays.
///
/// - Important: This action does not directly animate a bound property, such as ``BindTarget/transform``.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct PlayAudioAction : EntityAction, Codable {

    /// The entity to play the audio.
    public var targetEntity: ActionEntityResolution

    /// The name of the audio stored in audio library component of the target entity to start playing.
    public var audioResourceName: String

    /// The individual gain in decibels of the audio.
    public var gain: Audio.Decibel

    /// A Boolean that indicates whether this action has control over the playback of the audio.
    ///
    /// Setting the value of this property to true indicates the action has control over the playback of the audio.
    /// Setting this to false indicates the audio plays independently from the action, behaving like a one shot audio.
    public var useControlledPlayback: Bool

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public var animatedValueType: (any AnimatableData.Type)? { get }

    /// Creates a new play audio action.
    ///
    /// - Parameters:
    ///   - targetEntity: The entity to play the audio.
    ///   - audioResourceName: The name of the audio stored in audio library component of the target entity to start playing.
    ///   - gain: The individual gain in decibels of the audio.
    ///   - useControlledPlayback: Determines whether this action has control over the playback of the audio.
    public init(targetEntity: ActionEntityResolution = .sourceEntity, audioResourceName: String, gain: Audio.Decibel = 0, useControlledPlayback: Bool = true)

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// An entity that produces an omnidirectional light for virtual objects.
///
/// During an AR session, RealityKit automatically lights your virtual objects
/// to match real-world lighting.
/// You can also explicitly add virtual lights that act upon your virtual content.
/// This is typically most useful outside of an AR session on iOS or macOS,
/// where your ``RealityViewCameraContent`` ``RealityViewCameraContent/camera``
/// property is set to ``RealityViewCamera/virtual``.
///
/// The point light is an omnidirectional light that illuminates all the virtual
/// content within a configurable radius from the light.
/// This is equivalent to creating an ``Entity``, and then adding
/// a ``PointLightComponent`` to its ``Entity/components`` set.
///
/// A RealityKit scene can contain up to eight dynamic lights, which are
/// entities that contain a
/// ``SpotLightComponent``, ``PointLightComponent``, or a ``DirectionalLightComponent``.
/// This limit doesn’t include light from image-based lighting.
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
@MainActor @preconcurrency public class PointLight : Entity, HasPointLight {

    /// Creates a new entity.
    @MainActor @preconcurrency required public init()
}

/// A component that defines a point light source.
///
/// The strength of a point light depends on a combination of its
/// ``intensity`` and ``attenuationRadius``.
/// The default values for these properties make this light
/// comparable to high-power streetlights, or outdoor floodlights.
///
/// This table shows a few examples of common scenarios similar to a point light source:
///
/// | Scenario | Approximate lumens | Attenuation radius | Description |
/// |-|-|-|-|
/// | Candle flame | 10-15 lumens | ~1 meter | Very small light source |
/// | Nightlight | 20-30 lumens | 1-2 meters | Low-level lighting |
/// | 25W lightbulb | 200-300 lumens | 2-3 meters | Small room lighting  |
/// | 40W lightbulb | 400-500 lumens | 3-4 meters | Moderate room lighting |
/// | 60W lightbulb | 700-800 lumens | 4-5 meters | General-purpose lighting |
/// | 100W lightbulb | 1,500-1,700 lumens | 5-6 meters | Bright room lighting |
/// | LED flashlight | 300-600 lumens | 50-70 meters | Long distance illumination |
/// | Car headlights (each, low-beam) | 700-1,200 lumens | 100-150 meters | Illuminates the road ahead |
/// | LED streetlight | 8,000-10,000 lumens | 20-30 meters | Illuminates large outdoor areas |
/// | Stadium lighting | ~100,000 lumens | 100-200 meters | Lights-up large outdoor areas |
///
/// Use this component by applying it to an entity's ``Entity/components`` set.
/// In this example, the light's color is red:
///
/// ```swift
/// let lightEntity = Entity()
///
/// let redLightComponent = PointLightComponent(color: .red)
/// lightEntity.components.set(redLightComponent)
/// ```
///
/// The point light illuminates entities based on its distance from them.
/// Here is a visual example of how a red `PointLightComponent` illuminates elements based on distance:
///
/// | ![A screenshot of a RealityKit scene with a dark gray floor, a light gray cube, and a small green sphere to the left of the cube above the floor. The green sphere is emitting a red light, which slightly illuminates the close side of the cube and the floor below.](pointlight-cube-far) | ![A screenshot of a RealityKit scene with a dark gray floor, a light gray cube, and a small green sphere to the left of the cube above the floor. The green sphere is emitting a red light, which strongly illuminates the close side of the cube and the floor below.](pointlight-cube-closer) | ![A screenshot of a RealityKit scene with a dark gray floor, a light gray cube, and a small green sphere to the left of the cube above the floor. The green sphere is emitting a red light, which intensely illuminates the close side of the cube and the floor below.](pointlight-cube-closest)
/// |-|-|-|
///
/// - Note: The green dot in the above illustrations is only a visual representation of the light's position.
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
public struct PointLightComponent : Component, Equatable {

    /// The intensity of the point light, measured in lumen.
    ///
    /// The default value is `26963.76` lumens.
    ///
    /// See ``PointLightComponent`` for more information about how the
    /// `intensity` and ``attenuationRadius`` properties affect this light.
    public var intensity: Float

    /// The distance from the light source where its intensity reaches zero.
    ///
    /// Any objects at or beyond this distance do not receive illumination.
    /// The default value is `10.0` meters.
    ///
    /// See ``PointLightComponent`` for more information about how the
    /// ``intensity`` and `attenuationRadius` properties affect this light.
    public var attenuationRadius: Float

    /// Creates a new instance with the specified color, intensity and attenuation.
    /// - Parameters:
    ///   - cgColor: The color of the light.
    ///   - intensity: The light's brightness.
    ///   - attenuationRadius: The distance from the light source where its intensity reaches zero.
    ///     Any objects at or beyond this distance do not receive illumination.
    public init(cgColor: CGColor, intensity: Float = 26963.76, attenuationRadius: Float = 10.0)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PointLightComponent, b: PointLightComponent) -> Bool
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension PointLightComponent {

    /// The exponent value for the light's intensity falloff-transition curve.
    public var attenuationFalloffExponent: Float
}

/// A component that turns mesh surfaces into portals to a different world.
///
/// A RealityKit portal defines a way to look into a different, immersive world. You define an entity as a portal
/// when it also has a ``ModelComponent`` that contains a mesh part with ``PortalMaterial``.
///
/// To create a portal, set its ``targetEntity`` property to an entity with a
/// ``WorldComponent``. Entities under that world only render within the portal.
///
/// ```swift
///let world = Entity()
///world.components.set(WorldComponent())
///
///let portal = Entity()
///portal.components.set(
///    ModelComponent(
///        mesh: .generatePlane(width: 0.5, height: 0.5, cornerRadius: 0.1),
///        materials: [PortalMaterial()]
///    )
///)
///portal.components.set(PortalComponent(target: world))
///
///content.add(world)
///content.add(portal)
/// ```
///
/// ### Clipping and Crossing
///
/// You can enable clipping by configuring ``clippingMode-swift.property`` to something
/// other than ``ClippingMode-swift.enum/disabled``.
/// For example, you can use ``ClippingMode-swift.enum/plane(_:)``.
/// This ensures that the contents of the portal world don't render beyond
/// the portal boundary, causing depth confusion.
///
/// Entities inside the portal world with a ``PortalCrossingComponent`` can freely
/// cross in and out of the portal boundary in any of the following platforms:
/// - iOS 18 and later
/// - macOS 15 and later
/// - visionOS 2 and later
///
/// You can enable the crossing feature by configuring ``crossingMode-swift.property``
/// to something other than ``CrossingMode-swift.enum/disabled``.
/// Such as ``CrossingMode-swift.enum/plane(_:)``.
///
///```swift
///let world = Entity()
///world.components.set(WorldComponent())
///
///// Create an entity that doesn't cross beyond the portal bounds.
///let notCrossing = Entity()
///
///// Create an entity that crosses beyond the portal bounds.
///let willCross = Entity()
///willCross.components.set(PortalCrossingComponent())
///
///world.addChild(notCrossing)
///world.addChild(willCross)
///
///// Set up a crossable portal, without a near clip.
///let portal = Entity()
///portal.components.set(
///    ModelComponent(
///        mesh: .generatePlane(width: 0.5, height: 0.5, cornerRadius: 0.1),
///        materials: [PortalMaterial()]
///    )
///)
///var portalComp = PortalComponent(target: world)
///portalComp.clippingMode = .plane(.positiveZ)
///portalComp.crossingMode = .plane(.positiveZ)
///portal.components.set(portalComp)
///
///content.add(world)
///content.add(portal)
///```
///
/// The spaceships below have a ``PortalCrossingComponent``.
/// @Video(
///     source: portal-crossing-video,
///     alt: "Four videos of space ships poking out of portals looking into outer space. Each video is in a grid formation. The top left video have both clipping and crossing mode disabled, so the space ship is being bounded by the portal geometry. The bottom left video have clipping mode set to plane and crossing mode disabled, so the space ship is clipped by the portal plane. The two videos on the right column have crossing mode enabled, so the spaceship is rendered outside the portal geometry.",
///     poster: portal-crossing-video-poster
/// )
///
/// The spaceships below *don't* have a ``PortalCrossingComponent``.
///
/// @Video(
///     source: portal-clipping-video,
///     alt: "Four videos of space ships poking out of portals looking into outer space. Each video is in a grid formation. The two videos on the top row have clipping mode disabled so the space ships are bounded by the portal geometry. The two videos on the bottom row have clipping mode enabled so the space ships are clipped by the portal plane.",
///     poster: portal-clipping-video-poster
/// )
///
/// ### Lighting
///
/// You define the lighting in a portal world with ``ImageBasedLightComponent`` and
/// ``ImageBasedLightReceiverComponent``.
///
/// RealityKit provides a default IBL if you don't specify one with ``ImageBasedLightReceiverComponent``.
///
/// Contents within a portal world don't receive real-world probe lighting. However, you can achieve a  similar
/// effect in the portal world using ``VirtualEnvironmentProbeComponent``.
///
/// You can configure this virtual probe lighting contribution with
/// ``EnvironmentLightingConfigurationComponent``.
///
/// Dynamic lights, such as ``PointLightComponent`` and ``DirectionalLightComponent``,
/// don't cross world bounds.
///
/// Different lighting environments light the portal crossing entities based on which side of the portal they
/// are on:
/// - When inside the portal, the portal world's lighting lights the entity.
/// - When outside the portal, the default world's lighting lights the entity.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct PortalComponent : Component {

    /// The root entity for the portal's target world.
    ///
    /// When the target entity is valid and has a ``WorldComponent``,
    /// the portal renders with the target entity and its hierarchy tree.
    ///
    /// When the target entity doesn't have a ``WorldComponent``,
    /// the portal doesn't render.
    public var targetEntity: Entity?

    /// A representation of a portal as an infinite plane.
    ///
    /// Use this type with ``PortalComponent/init(target:clippingPlane:)`` to initialize a portal
    /// component with the clipping feature in an enabled state.
    public struct ClippingPlane {

        /// The position of the clipping plane.
        public var position: SIMD3<Float>

        /// The normal of the clipping plane.
        public var normal: SIMD3<Float>

        /// Creates a clipping plane at a position and normal direction.
        /// - Parameters:
        ///   - position: The position of the clipping plane.
        ///   - normal: The normal of the clipping plane.
        public init(position: SIMD3<Float>, normal: SIMD3<Float>)
    }

    /// The clipping plane of the portal, using the entity's local coordinates.
    ///
    /// When you define this property, the portal clips meshes inside the world,
    /// which are in front of the clipping plane.
    public var clippingPlane: PortalComponent.ClippingPlane?

    /// Creates a portal component with a target entity and a clipping plane.
    ///
    /// This initializes the ``PortalComponent`` with the given target entity,
    /// and an optional clipping plane.
    /// The target entity needs a ``WorldComponent`` in its component set.
    ///
    /// To render a portal, an entity needs a ``PortalComponent`` and a
    /// ``ModelComponent``, using one or more ``PortalMaterial`` instances.
    ///
    /// This initializer is equivalent to setting ``PortalComponent/clippingMode-swift.property`` with
    /// the same ``PortalComponent/Plane``.
    ///
    /// - Parameters:
    ///   - target: A target world entity the portal is looking into.
    ///   - clippingPlane: A planar representation of a portal to enable the clipping feature.
    ///     When `nil`, ``PortalComponent/clippingMode-swift.property`` is ``ClippingMode-swift.enum/disabled``.
    public init(target: Entity, clippingPlane: PortalComponent.ClippingPlane? = nil)
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension PortalComponent {

    /// A representation of a portal as an infinite plane.
    ///
    /// Enable the corresponding clipping and crossing features by passing this value in
    /// ``ClippingMode-swift.enum/plane(_:)`` or
    /// ``CrossingMode-swift.enum/plane(_:)``.
    ///
    /// RealityKit defines the ``position`` and ``normal`` properties in entity local space.
    ///
    /// The following default values are available:
    /// - ``positiveX``
    /// - ``negativeX``
    /// - ``positiveY``
    /// - ``negativeY``
    /// - ``positiveZ``
    /// - ``negativeZ``
    ///
    /// See ``PortalComponent`` for example usage.
    public struct Plane : Equatable {

        /// The position of the portal plane, in entity local space.
        public var position: SIMD3<Float>

        /// The normal of the portal plane, in entity local space.
        public var normal: SIMD3<Float>

        /// Creates a portal plane with position and normal.
        public init(position: SIMD3<Float>, normal: SIMD3<Float>)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PortalComponent.Plane, b: PortalComponent.Plane) -> Bool
    }

    /// Specifies the mode of clipping for a portal.
    ///
    /// This type can be passed into ``PortalComponent/clippingMode-swift.property`` to 
    /// configure the portal component's clipping feature.
    ///
    /// With ``disabled``, contents in portal world are not clipped
    ///
    /// With ``plane(_:)``, contents within portal are clipped by the edge of the plane.
    public enum ClippingMode : Equatable {

        /// Disables clipping of the contents within the portal.
        case disabled

        /// Clips the contents within the portal by the edge of the plane.
        case plane(PortalComponent.Plane)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PortalComponent.ClippingMode, b: PortalComponent.ClippingMode) -> Bool
    }

    /// The clipping behavior of the portal component.
    ///
    /// Provide a ``ClippingMode-swift.enum`` to configure the clipping behaviors.
    public var clippingMode: PortalComponent.ClippingMode

    /// Specifies the mode of crossing for a portal.
    ///
    /// You pass this type to ``PortalComponent/crossingMode-swift.property`` to
    /// configure the portal component's crossing feature.
    ///
    /// Use ``disabled`` to disallow contents within the portal to cross out of the portal boundary.
    ///
    /// Use ``plane(_:)`` to allow contents within the portal world with a ``PortalCrossingComponent`` to
    /// cross out of this planar definition of the portal boundary.
    public enum CrossingMode : Equatable {

        /// Disallows contents within the portal to cross out of the portal boundary.
        case disabled

        /// Allows contents within the portal to cross out of the portal along the provided plane.
        case plane(PortalComponent.Plane)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PortalComponent.CrossingMode, b: PortalComponent.CrossingMode) -> Bool
    }

    /// The crossing behavior of the portal component.
    ///
    /// Provide a ``CrossingMode-swift.enum`` to configure the crossing behaviors.
    public var crossingMode: PortalComponent.CrossingMode

    /// Creates a portal component with a target entity, clipping mode, and crossing mode.
    ///
    /// To render a portal, an entity needs a ``PortalComponent`` and a ``ModelComponent``, using one or
    /// more ``PortalMaterial`` instances.
    ///
    /// The target entity needs to have a ``WorldComponent`` or the portal does not render.
    ///
    /// Provide ``ClippingMode-swift.enum`` and ``CrossingMode-swift.enum`` to configure the corresponding
    /// clipping and crossing features.
    ///
    /// Using this initializer is equivalent to setting ``targetEntity``, ``clippingMode-swift.property`` and
    /// ``crossingMode-swift.property`` properties directly.
    ///
    /// See ``PortalComponent`` for example usage.
    ///
    /// - Parameters:
    ///   - target: A target world entity the portal is looking into.
    ///   - clippingMode: A configuration for the portal's clipping feature.
    ///   - crossingMode: A configuration for the portal's crossing feature.
    public init(target: Entity, clippingMode: PortalComponent.ClippingMode, crossingMode: PortalComponent.CrossingMode)

    /// Options to toggle the portal features on and off.
    ///
    /// This option set is equivalent to setting
    /// ``PortalComponent/clippingMode-swift.property`` and
    /// ``PortalComponent/crossingMode-swift.property`` directly.
    ///
    /// Use this type with ``PortalComponent/init(target:plane:options:)``.
    public struct Options : OptionSet {

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: UInt)

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: UInt

        /// An option that enables the clipping feature.
        ///
        /// If this option is in the option set, the user-defined geometry for ``clippingMode``
        /// clips the contents within the portal world.
        public static let clipContents: PortalComponent.Options

        /// An option that enables the crossing feature.
        ///
        /// Objects within the portal world with a ``PortalCrossingComponent`` can cross
        /// the portal when the `allowCrossing` option is in an enabled state.
        /// Crossing behavior is based on the user-defined geometry for ``crossingMode``.
        public static let allowCrossing: PortalComponent.Options

        /// The type of the elements of an array literal.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias ArrayLiteralElement = PortalComponent.Options

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Element = PortalComponent.Options

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias RawValue = UInt
    }

    /// Creates a portal component with a target entity, a single planar definition, and portal options.
    ///
    /// Use this initializer to toggle ``clippingMode-swift.property`` and
    /// ``crossingMode-swift.property``
    /// with the same ``PortalComponent/Plane``.
    ///
    /// - Parameters:
    ///   - target: A target world entity the portal is looking into.
    ///   - plane: A plane for configuring clipping and crossing features.
    ///   - options: An option set that determines which clipping and crossing features to enable.
    public init(target: Entity, plane: PortalComponent.Plane, options: PortalComponent.Options)
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension PortalComponent.Plane {

    /// A portal plane sitting at the origin facing the positive x direction.
    public static let positiveX: PortalComponent.Plane

    /// A portal plane sitting at the origin facing the negative x direction.
    public static let negativeX: PortalComponent.Plane

    /// A portal plane sitting at the origin facing the positive y direction.
    public static let positiveY: PortalComponent.Plane

    /// A portal plane sitting at the origin facing the negative y direction.
    public static let negativeY: PortalComponent.Plane

    /// A portal plane sitting at the origin facing the positive z direction.
    public static let positiveZ: PortalComponent.Plane

    /// A portal plane sitting at the origin facing the negative z direction.
    public static let negativeZ: PortalComponent.Plane
}

/// A component that allows entities to cross portal boundaries.
///
/// You use this with ``PortalComponent/CrossingMode-swift.enum`` to
/// enable portal crossing features.
///
/// When you set this on an entity, this component defines whether the entity is capable of crossing
/// the portal boundary.
///
/// Entities without this component, entities where ``Entity/isEnabled`` is `false`,
/// and entities without a containing entity that specifies inherited portal crossing,
/// aren't able to cross portals.
///
/// See ``PortalComponent`` for detailed usage.
@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
public struct PortalCrossingComponent : Component {

    public init()
}

/// A material that makes the mesh part a portal to a different world.
///
/// You use a `PortalMaterial` with ``PortalComponent`` and ``WorldComponent`` to enable portal features.
///
/// You can set this material on individual mesh parts. For example, create a box with
/// ``MeshResource/generateBox(width:height:depth:cornerRadius:splitFaces:)-7m6ha``.
/// It can have some faces using ``PhysicallyBasedMaterial`` and some faces using `PortalMaterial`.
///
/// ```swift
/// let portal = Entity()
/// // When you set `splitFaces` to `true`, each face takes up a different material slot.
/// let cyanMaterial = SimpleMaterial(color: .cyan, isMetallic: false)
/// portal.components.set(ModelComponent(
///     mesh: .generateBox(width: 0.5, height: 0.5, depth: 0.5, splitFaces: true),
///     materials: [PortalMaterial(),
///                 cyanMaterial,
///                 cyanMaterial,
///                 cyanMaterial,
///                 cyanMaterial,
///                 cyanMaterial]
/// ))
/// // Because the box has `0.5 x 0.5 x 0.5` dimensions,
/// // offset the portal plane on the z-axis by 0.25 so that
/// // it's at the front of the cube.
/// // Make sure it faces toward the positive z-direction.
/// portal.components.set(PortalComponent(
///     target: world,
///     clippingMode: .disabled,
///     crossingMode: .plane(PortalComponent.Plane(position: [0, 0, 0.25], normal: [0, 0, 1]))
/// ))
/// ```
///
/// ![A screenshot of cyan color box with only one face using portal material and a spaceship poking out of it](portal-material-box)
///
/// RealityKit treats each mesh part with a `PortalMaterial` as a different portal, even if they
/// are pointing to the same world. Beware of the performance impact of this usage.
///
/// See ``PortalComponent`` for example usage.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct PortalMaterial : Material, Sendable {

    public init()

    /// An alias for the triangle fill mode object that’s appropriate for this
    /// material class.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public typealias TriangleFillMode = MaterialParameterTypes.TriangleFillMode

    /// The object that controls how RealityKit draws triangles.
    ///
    /// A value of ``MaterialParameterTypes/TriangleFillMode/fill`` causes RealityKit
    /// to draw triangles normally, while a value of  ``MaterialParameterTypes/TriangleFillMode/lines``
    /// turns on wireframe rendering.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public var triangleFillMode: PortalMaterial.TriangleFillMode
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension PortalMaterial {

    /// An alias for the cull mode object that’s appropriate for this material class.
    public typealias FaceCulling = MaterialParameterTypes.FaceCulling

    /// A process in which the system specifies polygons to remove before
    /// rendering a mesh using this material.
    ///
    /// To improve performance, RealityKit culls polygons, or faces, that it
    /// determines won’t be visible. Discarding faces that aren’t part of the
    /// final render eliminates the need to do any calculations for those
    /// faces.
    ///
    /// RealityKit recognizes when a face aims toward the camera (a front face)
    /// or away from the camera (a back face). This value controls the type of
    /// faces RealityKit culls.
    ///
    /// This value defaults to ``MaterialParameterTypes/FaceCulling/back``,
    /// which means RealityKit removes faces that point away from the camera.
    /// Most of the time, this is the correct behavior, because back faces are
    /// usually obscured by other front-facing polygons.
    ///
    /// You can change the culling behavior to cull front faces instead or to
    /// turn off face culling altogether, but be aware that turning off face
    /// culling results in less efficient rendering and may negatively impact
    /// your app’s frame rate.
    public var faceCulling: PortalMaterial.FaceCulling
}

/// A component that defines a virtual camera with a custom projection matrix.
///
/// ## Overview
/// Each scene requires a camera, which defines the viewpoint from which RealityKit renders the scene. The projective transform camera
/// renders the entities in the scene based on a custom user defined matrix.
/// To create a projective transform camera, add this component to an entity.
///
/// ```swift
/// // Create an entity to hold the camera component.
/// let cameraEntity = Entity()
///
/// // Create a projective transform camera component with a custom matrix.
/// var projectiveCameraComponent = ProjectiveTransformCameraComponent(projectionMatrix: customMatrix)
///
/// // Add it to the camera entity.
/// cameraEntity.components.set(projectiveCameraComponent)
/// 
/// // Set the entity's position and orientation to look at the subject.
/// let cameraPosition: SIMD3<Float> = [0, 1, 3]
///
/// // The subject in this case is the origin.
/// let target: SIMD3<Float> = .zero
/// cameraEntity.look(at: target, from: cameraPosition, relativeTo: nil)
///
/// // Add the camera entity to your scene.
/// content.add(cameraEntity)
/// ```
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct ProjectiveTransformCameraComponent : Component, Equatable {

    /// The custom projection RealityKit applies to objects in the scene.
    ///
    /// The value defaults to `4x4` zero matrix.
    /// Swap the near and far values to use a reverse depth matrix.
    public var transform: float4x4

    /// Creates a new custom matrix camera component with the given settings.
    ///
    /// The matrix uses reverse depth.
    /// - Parameters:
    ///   - projectionMatrix: The custom projection matrix the user wants to use.
    @available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
    public init(projectionMatrix: float4x4)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ProjectiveTransformCameraComponent, b: ProjectiveTransformCameraComponent) -> Bool
}

/// An object that defines the criteria for an entity query.
///
/// Query predicates specify the entities an ``EntityQuery`` returns from a
/// scene. Predicates describe entities based on which components they contain,
/// or on the entity’s relationship to other entities in the scene. For example,
/// you can build a predicate to retrieve the model entities from a scene.
///
/// ```swift
/// let modelPredicate = QueryPredicate.has(ModelComponent.self)
/// ```
///
/// ### Create compound predicates
///
/// You can combine predicates using Swift’s logical operators to create
/// compound predicates. ``QueryPredicate`` supports Swift’s logical `AND`
/// (`&&`), logical `OR` (`||`), and logical `NOT` (`!`) operators. The
/// following code shows how to build a compound predicate that returns all
/// entities that are either model entities or anchor entities:
///
/// ```swift
/// let orPredicate: QueryPredicate<Entity> =
///     .has(ModelComponent.self) || .has(AnchorComponent.self)
/// ```
///
/// Use parentheses to control the order of operations when combining
/// predicates. For example, you can create a query that returns any entity that
/// has both a model component and a physics body component, or any entity that
/// has only an anchor component.
///
/// ```swift
/// let multiPredicate: QueryPredicate<Entity> =
///     .has(ModelComponent.self) && .has(PhysicsBodyComponent.self) ||
///     .has(AnchorComponent.self)
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct QueryPredicate<Value> {
}

/// .has() predicate support.
extension QueryPredicate {

    /// Creates a new predicate that describes entities that have a specific
    /// component.
    ///
    /// To create a `has` predicate, pass the component class’s `self` property.
    ///
    /// ```swift
    /// let myPredicate = QueryPredicate.has(ModelComponent.self)
    /// ```
    ///
    /// - Parameters:
    ///   - t: The type of component.
    ///
    /// - Returns: A predicate that describes entities with a specified
    /// component.
    @available(macOS 12.0, iOS 15.0, *)
    public static func has<T>(_ t: T.Type) -> QueryPredicate<Entity> where T : Component
}

/// An object that returns the results of an entity query.
///
/// You can’t create query result objects. Instead, call
/// ``Scene/performQuery(_:)``, which returns a ``QueryResult`` containing the
/// entities that meet your specified query criteria.
///
/// ```swift
/// // Ask the scene to perform the query and iterate over the returned entities.
/// scene.performQuery(query).forEach { entity in
///     print("Returned entity: \(entity)")
/// }
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct QueryResult<Element> {
}

@available(macOS 12.0, iOS 15.0, *)
extension QueryResult : Sequence {

    /// The type of iterator used for entity query results.
    @available(macOS 12.0, iOS 15.0, *)
    public struct Iterator : IteratorProtocol {

        /// Advances to the next entity and returns it.
        ///
        /// - Returns: Calling this method advances the iterator to the next
        /// entity and returns it. If there is no next element, returns `nil`.
        public mutating func next() -> Element?
    }

    /// Returns an iterator for the contained entities.
    ///
    /// - Returns: The iterator.
    @available(macOS 12.0, iOS 15.0, *)
    public func makeIterator() -> QueryResult<Element>.Iterator
}

/// A force effect that pulls objects toward its center with a spring-like (distance dependent) force.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct RadialForceEffect : ForceEffectProtocol, Codable {

    /// Creates a radial force effect.
    ///  - Parameters:
    ///     - strength: The magnitude of the spring effect—a larger strength simulates a stiffer spring.
    ///     - restDistance: Objects at this distance will receive zero radial force.
    ///                     Otherwise they will gravitate toward this distance along the radial direction.
    ///                     Objects will be attracted to the origin directly if this property is set to zero.
    public init(strength: Double, restDistance: Double)

    /// Calculates the radial forces for rigid bodies from the force effect.
    ///
    /// - Parameter parameters: On input, the parameters that calculate forces to the affected physics bodies; on output, the updates to those forces.
    ///
    /// The framework automatically calls this method for you at each physics simulation step,
    /// so you don't need to call it yourself.
    public func update(parameters: inout ForceEffectParameters)

    /// The magnitude of the force.
    public let strength: Float

    /// A distance at which the rigid bodies receive zero radial force.
    ///
    /// Use a **non-negative** rate.
    /// The force field pulls rigid bodies to the effect's origin along the radial direction if this value is `0`.
    public let restDistance: Float

    /// The input rigid body parameters.
    public var parameterTypes: PhysicsBodyParameterTypes { get }

    /// The type of force this effect applies.
    public var forceMode: ForceMode

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A 3D coordinate space that exists within a RealityKit hierarchy.
/// 
/// Any `RealityCoordinateSpaceConverting` can convert spatial data between
/// a <doc://com.apple.documentation/documentation/swiftui>
/// `CoordinateSpace` and a `RealityCoordinateSpace`.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public protocol RealityCoordinateSpace {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension RealityCoordinateSpace where Self == SceneRealityCoordinateSpace {

    /// The coordinate space that represents ARKit world space.
    ///
    /// In a visionOS window or volume,
    /// or when using the ``RealityViewCamera/virtual``
    /// camera on any other platform, this space represents
    /// the center of the scene's owning ``RealityView``.
    ///
    /// When in a visionOS Immersive Space, or using the
    /// ``RealityViewCamera/worldTracking`` camera in iOS,
    /// the `scene` coordinate space is the
    /// <doc://com.apple.documentation/documentation/arkit> world origin.
    ///
    /// - Note: This static type is equivalent to a
    ///   ``SceneRealityCoordinateSpace`` instance.
    public static var scene: SceneRealityCoordinateSpace { get }
}

/// A renderer that displays a RealityKit scene in an existing Metal workflow.
///
/// All RealityKit APIs for loading resources, creating entities and adding components are compatible and work with
/// `RealityRenderer`.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public class RealityRenderer {

    /// A collection of entities in a ``RealityRenderer``.
    ///
    /// This collection is used by ``RealityRenderer/entities``.
    @MainActor public struct EntityCollection : EntityCollection {

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        @MainActor public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        @MainActor public var endIndex: Int { get }

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        @MainActor public var count: Int { get }

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        @MainActor public subscript(index: Int) -> Entity { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        @MainActor public func index(after i: Int) -> Int

        /// Adds the specified sequence of entities to this collection in order,
        /// directly before the entity at the given index.
        ///
        /// - Parameters:
        ///   - sequence:                  A sequence of entities to add to the collection.
        ///   - index:                     The index of an entity to insert in front
        ///                                of. If `endIndex` is provided, the
        ///                                entities will be appended.
        ///
        /// > Note: This operation can invalidate the index order of any extant entities.
        @MainActor public mutating func insert<S>(contentsOf sequence: S, beforeIndex index: Int) where S : Sequence, S.Element : Entity

        /// Adds the specified sequence of entities to the end of this collection,
        /// in order.
        ///
        /// - Parameters:
        ///   - sequence:                 The entities to add to the collection.
        ///
        /// > Note: This operation can invalidate the index order of any extant entities.
        @MainActor public mutating func append<S>(contentsOf sequence: S) where S : Sequence, S.Element : Entity

        /// Removes the entity from the collection.
        ///
        /// - Parameters:
        ///   - entity:                    The entity to remove from the collection.
        ///
        /// > Note: This operation can invalidate the index order of any remaining entities.
        @MainActor public mutating func remove(_ child: Entity)

        /// Removes the entity at the given index from this collection.
        ///
        /// - Parameters:
        ///   - index:                    The index of the entity to remove from the collection.
        ///
        /// > Note: This operation can invalidate the index order of any remaining entities.
        @MainActor public mutating func remove(at index: Int)

        /// Removes all entities from this collection.
        @MainActor public mutating func removeAll()

        /// Replaces all entities in this collection with those from the given
        /// sequence.
        ///
        /// - Parameters:
        ///   - entities:                 The sequence of entities that will replace
        ///                               the collection's current contents.
        ///
        /// > Note: This operation might not maintain the new entities' index order.
        @MainActor public mutating func replaceAll<S>(_ children: S) where S : Sequence, S.Element : Entity

        /// A type representing the sequence's elements.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias Element = Entity

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias Index = Int

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias Indices = DefaultIndices<RealityRenderer.EntityCollection>

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias Iterator = IndexingIterator<RealityRenderer.EntityCollection>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
        public typealias SubSequence = Slice<RealityRenderer.EntityCollection>
    }

    /// Settings for rendering with a camera.
    public struct CameraSettings {

        /// Specifies if tone mapping is enabled.
        public var isToneMappingEnabled: Bool

        /// Defines the background
        public struct ColorBackground {

            /// Use a solid color as background.
            /// - Parameter color: The color to use for background.
            public static func color(_ color: CGColor) -> RealityRenderer.CameraSettings.ColorBackground

            /// Use the corresponding `CameraOutput` colorTexture as background.
            public static func outputTexture() -> RealityRenderer.CameraSettings.ColorBackground
        }

        /// The background to use for rendering with a camera.
        public var colorBackground: RealityRenderer.CameraSettings.ColorBackground
    }

    /// Output produced by rendering with a camera.
    public struct CameraOutput {

        /// Structure defining a viewport for rendering with a camera.
        ///
        /// The units are relative to output texture size.
        /// To map normalized-device coordinates to the whole texture:
        ///
        /// ```swift
        /// viewport = RealityRenderer.CameraOutput.RelativeViewport(originX: 0.0, originY: 0.0, width: 1.0, height: 1.0)
        /// ```
        ///
        /// Assigning values more than 1.0 to ``RealityRenderer/CameraOutput/RelativeViewport/width``
        /// or ``RealityRenderer/CameraOutput/RelativeViewport/height``
        /// stretches the viewport in horizontal and vertical directions.
        ///
        /// Assigning values less than 0.0 to ``RealityRenderer/CameraOutput/RelativeViewport/originX``
        /// or ``RealityRenderer/CameraOutput/RelativeViewport/originY``
        /// shifts the viewport into negative X and negative Y directions.
        public struct RelativeViewport {

            public var originX: Double

            public var originY: Double

            public var width: Double

            public var height: Double

            public init(originX: Double, originY: Double, width: Double, height: Double)
        }

        /// Describes the output of rendering with a camera.
        public struct Descriptor {

            /// Textures to store color output.
            public var colorTextures: [any MTLTexture]

            /// Viewports to use for rendering with a camera.
            public var viewports: [RealityRenderer.CameraOutput.RelativeViewport]

            /// Creates a descriptor for single projection output.
            public static func singleProjection(colorTexture: any MTLTexture) -> RealityRenderer.CameraOutput.Descriptor
        }

        /// Textures to store color output.
        public var colorTextures: [any MTLTexture] { get }

        /// Viewports to use for rendering with a camera.
        public var viewports: [RealityRenderer.CameraOutput.RelativeViewport] { get }

        /// Create a new output instance for rendering with a camera.
        ///
        /// - Parameter descriptor: A descriptor object that describes the output to be created.
        public init(_ descriptor: RealityRenderer.CameraOutput.Descriptor) throws
    }

    /// A collection of RealityKit entities that this renderer
    /// renders within the scene.
    @MainActor public var entities: RealityRenderer.EntityCollection

    /// Subscribes to an event type, optionally limited to
    /// events affecting a source entity or scene,
    /// or limited to
    /// a specific component type for component events.
    ///
    /// - Parameters:
    ///   - event: The event type to subscribe to.
    ///     For example ``SceneEvents/Update`` or ``ComponentEvents/DidAdd``.
    ///   - sourceObject: An optional source for the event, such as an entity or a scene.
    ///     Set to `nil` to listen for all events of the event type within the ``RealityRenderer``.
    ///   - componentType: An optional component type to filter events to if the event is of the type ``ComponentEvents``.
    ///     Set to `nil` to listen for all events of the event type within the ``RealityRenderer``.
    ///   - handler: A closure that runs when the `event` occurs.
    ///
    /// - Returns: An object that represents the subscription to this event stream.
    public func subscribe<E>(to event: E.Type, on sourceObject: (any EventSource)? = nil, componentType: (any Component.Type)? = nil, _ handler: @escaping (E) -> Void) -> EventSubscription where E : Event

    /// Describe the lighting properties for the scene.
    public struct ImageBasedLight {

        /// The corresponding `EnvironmentResource` used for your Image Based Light.
        public var resource: EnvironmentResource?

        /// The intensity value of the light.
        /// The intensity modulates the intensity specified in the diffuse and specular textures
        /// An intensity of 0 means using the diffuse/specular intensities as-is
        /// Otherwise the intensity is multiplied by 2^intensity
        public var intensityExponent: Float
    }

    /// The lighting used in the environment of a particular scene.
    @MainActor public var lighting: RealityRenderer.ImageBasedLight

    /// The camera to be used for rendering.
    public var activeCamera: Entity?

    /// The settings to be used for rendering with `activeCamera`.
    public var cameraSettings: RealityRenderer.CameraSettings

    /// The structure describing an event and value to be signaled or waited for.
    public struct MetalEventAction {

        /// The metal event object to be signaled or waited for.
        public let event: any MTLEvent

        /// The value to be signaled or waited for.
        public let value: UInt64

        /// Returns an action that represents waiting for an event to reach the value.
        public static func wait(for event: any MTLEvent, value: UInt64) -> RealityRenderer.MetalEventAction

        /// Returns an action that represents signaling event with the value.
        public static func signal(_ event: any MTLEvent, value: UInt64) -> RealityRenderer.MetalEventAction
    }

    @MainActor public init() throws

    /// Tick the simulation
    ///
    /// - Parameter deltaTime: The delta time to advance the simulation
    @MainActor public func update(_ deltaTime: TimeInterval) throws

    /// Tick the simulation and render using activeCamera and the camera rendering output.
    ///
    /// - Parameters:
    ///   - deltaTime: The delta time to advance the simulation
    ///
    ///   - cameraOutput: Specifies output for rendering with ``activeCamera``
    ///
    ///   - whenScheduled: A handler that is called when the corresponding MTLCommandBuffer is scheduled
    ///
    ///   - onComplete: A handler that is called when the corresponding MTLCommandBuffer is complete
    ///
    ///   - actionsBeforeRender: Array of events and values to wait before GPU rendering work
    ///
    ///   - actionsAfterRender: Array of events and values to signal after GPU rendering work
    @MainActor public func updateAndRender(deltaTime: TimeInterval, cameraOutput: RealityRenderer.CameraOutput, whenScheduled: ((RealityRenderer) -> Void)? = nil, onComplete: ((RealityRenderer) -> Void)? = nil, actionsBeforeRender: [RealityRenderer.MetalEventAction] = [], actionsAfterRender: [RealityRenderer.MetalEventAction] = []) throws
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension RealityRenderer.EntityCollection : Sendable {
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension RealityRenderer.CameraSettings {

    public var antialiasing: AntialiasingMode
}

/// A component that can load another entity from a file.
///
/// You can use a `ReferenceComponent` to load other entities from files in your app's main bundle.
/// This allows you to load complex scenes incrementally, resulting in more responsive apps.
/// It also enables collaborative workflows so you can split a complex scene into separate pieces that
/// different teams own.
///
/// Use a `ReferenceComponent` by adding it to an entity when building up a scene programmatically.
/// Then call ``Entity/write(to:)`` to save the scene to a `.reality` file.
///
/// ```swift
/// // Create the root entity.
/// let root = Entity()
///
/// // Create an entity that references another entity file.
/// let earth = Entity()
/// earth.setParent(root)
///
/// // Add a reference to another entity that loads immediately
/// // when the root entity loads.
/// earth.components.set(ReferenceComponent(
///     named: "Earth",
///     loadingPolicy: .immediate))
///
/// // Add a reference to another entity that loads on demand.
/// let mars = Entity()
/// mars.name = "mars"
/// mars.components.set(ReferenceComponent(
///     named: "Mars",
///     loadingPolicy: .onDemand))
///
/// // Write the root entity to a `.reality` file.
/// try await root.write(to: fileURL)
/// ```
///
/// When your app loads the `.reality` file, it can dynamically load referenced entities from files.
/// For references that have a ``ReferenceComponent/LoadingPolicy-swift.enum`` of
/// ``ReferenceComponent/LoadingPolicy-swift.enum/onDemand``, you can use
/// ``ReferenceComponent/loadReference(at:)-1en8b`` to load content on demand.
///
/// ```swift
/// if let entity = root.findEntity(named: "mars") {
///     try ReferenceComponent.loadReference(at: entity)
/// }
/// ```
///
/// Conversely, use ``ReferenceComponent/releaseReference(at:)`` to unload content
/// and free up memory.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct ReferenceComponent : Component {

    /// Describes when a referenced entity loads.
    public enum LoadingPolicy {

        /// Loads the contents from the referenced entity file immediately when the root entity loads.
        case immediate

        /// Loads the contents from the referenced entity file when your app tells it to.
        ///
        /// Use ``ReferenceComponent/loadReference(at:)-1en8b`` to load the referenced
        /// entity.
        case onDemand

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ReferenceComponent.LoadingPolicy, b: ReferenceComponent.LoadingPolicy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Defines the current loading state of the referenced entity.
    public enum ReferenceState {

        /// The reference isn't loaded.
        case notLoaded

        /// The reference is loading.
        case loading

        /// The reference is loaded.
        case loaded

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ReferenceComponent.ReferenceState, b: ReferenceComponent.ReferenceState) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A policy that defines when a referenced entity loads.
    ///
    /// The default loading policy is ``ReferenceComponent/LoadingPolicy-swift.enum/onDemand``.
    public var loadingPolicy: ReferenceComponent.LoadingPolicy { get }

    /// A variable that indicates the loading state of the referenced entity.
    public var state: ReferenceComponent.ReferenceState { get }

    /// The root entity of the referenced entity file.
    ///
    /// This property returns `nil` when the referenced entity isn't loaded.
    public var reference: Entity? { get }

    /// Creates a reference component with a name, loading policy, and
    /// bundle path.
    ///
    /// - Parameters:
    ///   - name: The name of the entity to load.
    ///   - bundlePath: The bundle path to search for the resource.
    ///                 Specify the path relative to the Resources directory.
    ///   - loadingPolicy: A loading policy that indicates when the app loads the entity.
    public init(named name: String, at bundlePath: String = "", loadingPolicy: ReferenceComponent.LoadingPolicy = .onDemand)

    /// Creates a reference component with a name, loading policy, and bundle.
    ///
    /// - Parameters:
    ///   - name: The name of the entity to load.
    ///   - bundle: The bundle to search for the resource.
    ///   - loadingPolicy: A loading policy indicating when the app loads the entity.
    public init(named name: String, in bundle: Bundle, loadingPolicy: ReferenceComponent.LoadingPolicy = .onDemand)

    /// Creates a reference component with a name and loading policy.
    ///
    /// Place references in the app's main bundle.
    ///
    /// - Parameters:
    ///   - name: The name of the entity to load.
    ///   - loadingPolicy: A loading policy indicating when the app loads the entity.
    public init(named name: String, loadingPolicy: ReferenceComponent.LoadingPolicy = .onDemand)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ReferenceComponent {

    /// Synchronously loads another entity file that an entity depends on.
    ///
    /// - Parameter entity: The entity that holds the ``ReferenceComponent`` to load.
    public static func loadReference(at entity: Entity) throws

    /// Asynchronously loads another entity file that an entity depends on.
    ///
    /// - Parameter entity: The entity that holds the ``ReferenceComponent`` to load.
    @MainActor public static func loadReference(at entity: Entity) async throws

    /// Releases the reference an entity holds.
    ///
    /// - Parameter entity: The entity that holds the ``ReferenceComponent`` to release.
    public static func releaseReference(at entity: Entity) throws
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ReferenceComponent.LoadingPolicy : Equatable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ReferenceComponent.LoadingPolicy : Hashable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ReferenceComponent.ReferenceState : Equatable {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ReferenceComponent.ReferenceState : Hashable {
}

/// A shared resource you use to configure a component, like a material, mesh,
/// or texture.
///
/// Resources can be costly to load or create. Share and reuse resources as much as possible.
@available(macOS 10.15, iOS 13.0, *)
@preconcurrency public protocol Resource : Sendable {
}

/// The reverberation RealityKit applies to spatial audio sources.
///
/// You can configure the reverb for spatial audio sources in your RealityKit content with the ``ReverbComponent``.
///
/// ```swift
/// let cinema = Entity()
/// let reverb: Reverb = .preset(.mediumRoomDry)
/// cinema.components.set(ReverbComponent(reverb: reverb)
/// ```
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct Reverb : Hashable, Sendable {

    /// A reverb instance that applies no reverberation to spatial audio sources.
    /// - Warning: ``Reverb/anechoic`` will cause spatial audio sources to lose externalization,
    /// or the sense that an audio source is in a person's space. Only use this case when when the immersive
    /// environment is abstract or otherwise unrealistic.
    public static let anechoic: Reverb

    /// Returns a reverb instance that you can set on a reverb component.
    /// - Parameter preset: A reverberation preset.
    /// - Returns: Reverb that can be set on a ``ReverbComponent``.
    public static func preset(_ preset: Reverb.Preset) -> Reverb

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Reverb, b: Reverb) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension Reverb {

    /// Reverbs defined by a preset environment.
    public struct Preset : Hashable, Sendable {

        /// The reverb of an outside environment.
        public static let outside: Reverb.Preset

        /// The reverb of a concert hall.
        public static let concertHall: Reverb.Preset

        /// The reverb of a very large room.
        public static let veryLargeRoom: Reverb.Preset

        /// The reverb of a large room.
        public static let largeRoom: Reverb.Preset

        /// The reverb of a large room with acoustical treatment.
        public static let largeRoomTreated: Reverb.Preset

        /// The reverb of a medium-sized room with a significant amount of acoustical treatment.
        public static let mediumRoomDry: Reverb.Preset

        /// The reverb of a medium-sized room with acoustic treatment.
        public static let mediumRoomTreated: Reverb.Preset

        /// The reverb of a small room with reflective surfaces.
        public static let smallRoomBright: Reverb.Preset

        /// The reverb of a small room with furniture and other common household items.
        public static let smallRoom: Reverb.Preset

        /// The reverb of a very small room with reflective surfaces.
        public static let verySmallRoomBright: Reverb.Preset

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Reverb.Preset, b: Reverb.Preset) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

/// A component that defines the reverberation of spatial audio sources.
///
/// Bring your spatial audio to life by setting a reverb appropriate for your immersive environment.
/// In visionOS, an acoustic simulation of a person's real environment reverberates the spatial audio sources
/// by default.
/// When presenting your content in
/// <doc://com.apple.documentation/documentation/swiftui/immersionstyle/progressive>
/// and <doc://com.apple.documentation/documentation/swiftui/immersionstyle/full>
/// immersive spaces, consider setting a reverb component to make your spatial audio sound like it
/// exists within the environment that your visuals represent.
///
/// For example, a desert, living room, and concert hall each have unique acoustical
/// characteristics. When the visuals and acoustic properties of sounds in your
/// content are congruent, the environment becomes more effective as a whole.
///
/// ```swift
/// // Create an entity to hold the reverb component and
/// // use the concert hall preset.
/// let reverbEntity = Entity()
/// reverbEntity.components.set(ReverbComponent(reverb: .preset(.concertHall)))
///
/// // Add the reverb entity to the reality view.
/// content.add(reverbEntity)
///
/// // Load an audio file of a violin.
/// if let violin = try? await AudioFileResource(named: "violin") {
///
///     // Create an entity for playing the violin audio and
///     // set the spatial audio component.
///     let violinEntity = Entity()
///     violinEntity.components.set(
///         SpatialAudioComponent(
///             directivity: .beam(focus: 0.2)
///         )
///     )
///     violinEntity.playAudio(violin)
///
///     // Add the violin entity to the reality view.
///     content.add(violinEntity)
/// }
/// ```
///
/// Use the ``SpatialAudioComponent/reverbLevel`` property to adjust the level
/// of audio you send to the spatial modeler. 
/// Use the ``SpatialAudioComponent/directLevel`` property to adjust the level of audio you
/// send directly to a person's ears, without additional reverberation.
/// Use the ``SpatialAudioComponent/directivity`` property
/// to define the pattern that disperses sound into the acoustic environment.
///
/// In macOS and iOS, only one `ReverbComponent` can be active at a time per ``ARView`` or ``RealityView``.
/// In visionOS, a `ReverbComponent` is only active while an app has a
/// <doc://com.apple.documentation/documentation/swiftui/immersionstyle/progressive> or
/// <doc://com.apple.documentation/documentation/swiftui/immersionstyle/full>
/// immersive space open.
///
/// When the content is within a <doc://com.apple.documentation/documentation/swiftui/immersionstyle/progressive>
/// immersive space, the Digital Crown adjusts how RealityKit blends:
/// - The acoustics simulation of a person's real-world environment
/// - The reverberation the `ReverbComponent` generates
///
/// When your app is in a Shared Space <doc://com.apple.documentation/documentation/swiftui/windowgroup>
/// or an <doc://com.apple.documentation/documentation/swiftui/immersivespace>
/// using a <doc://com.apple.documentation/documentation/swiftui/immersionstyle/mixed> style,
/// RealityKit reverberates the spatial audio from the acoustics simulation
/// and ignores the reverberation from the `ReverbComponent`.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct ReverbComponent : Component, Hashable, Sendable {

    /// A reverberation setting the component applies to spatial audio.
    public var reverb: Reverb

    /// Creates a component from a reverberation setting.
    /// - Parameter reverb: A setting the component uses to reverberate spatial audio.
    public init(reverb: Reverb)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ReverbComponent, b: ReverbComponent) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// An animation that cycles through a series of frames at a constant interval.
///
/// To specify the data that the animation samples, set one of the `frames`
/// properties that matches the animated property's type. For example, set the
/// ``SampledAnimation/frames-2j4nj`` property to interpolate
/// <doc://com.apple.documentation/documentation/swift/float> values.
///
/// The following code designates a ``SampledAnimation`` to animate a propery of
/// type <doc://com.apple.documentation/documentation/swift/float> by specifying
/// the generic typed syntax. The code queues an array of values: `1.0`, `2.0`,
/// and `3.0`.
///
/// ```swift
/// // Define the animation type.
/// typealias SampledAnimationType = SampledAnimation<Float>
///
/// // Define the animated property values.
/// let frameArray: [Float] = [1.0, 2.0, 3.0]
/// ```
///
/// To determine how fast the animation progresses from frame to frame, define
/// this structure's ``SampledAnimation/frameInterval`` property. The following
/// code specifies a one-second delay between value changes before initializing
/// the animation object.
///
/// ```swift
/// // Define a one-second frame interval.
/// let interval: TimeInterval = 1
///
/// // Create the animation.
/// let sampleAnim = SampledAnimationType(
///     frames: frameArray,
///     name: "sampledAnim1",
///     frameInterval: interval
///     isAdditive: true,
///     bindTarget: .transform,
///     blendLayer: 100,
///     repeatMode: .autoReverse,
///     fillMode: .backwards,
///     trimStart: 1.0,
///     trimEnd: 10.0,
///     trimDuration: 9.0,
///     offset: 2.0,
///     delay: 1.0,
///     speed: 2.0
/// )
/// ```
@available(macOS 12.0, iOS 15.0, *)
public struct SampledAnimation<Value> : AnimationDefinition where Value : AnimatableData {

    /// A textual name for the animation.
    public var name: String

    /// The order in which the framework composites the animation.
    ///
    /// The framework applies multiple animations on the same target in
    /// ascending order of this property’s value. Animations in a lower layer
    /// run before animations in a higher layer. Animations that share the same
    /// value apply in the order that they execute.
    public var blendLayer: Int32

    /// A textual name that identifies the particular property that animates.
    ///
    /// The property name is a key path. For more information on key paths, see
    /// <doc://com.apple.documentation/documentation/swift/swift_standard_library/key-path_expressions>.
    public var bindTarget: BindTarget

    /// An option that determines which data displays outside of the normal
    /// duration.
    ///
    /// This property determines what to display when the framework samples the
    /// animation outside of the range defined by its underlying duration. The
    /// animation applies this property when:
    ///
    /// - Playback progresses toward, but hasn't yet reached, a nonzero
    /// ``AnimationDefinition/offset``. - A range determined by
    /// ``AnimationDefinition/trimStart``, ``AnimationDefinition/trimEnd``, or
    /// ``AnimationDefinition/trimDuration`` exceeds the animation's underlying
    /// duration.
    public var fillMode: AnimationFillMode

    /// A Boolean value that indicates whether the animation builds on the
    /// current state of the target entity or resets the state before running.
    public var additive: Bool

    /// The optional time, in seconds, at which the animation plays.
    ///
    /// This property is `nil` by default, which plays the animation from the
    /// starting frame defined by ``SampledAnimation/start``.
    ///
    /// If you set a value for this property, the animation visually begins from
    /// an additional seconds offset from the starting frame and decreases the
    /// duration by that amount.
    ///
    /// If you set a negative value for this property, the duration increases
    /// and the additional animation data fills in based on the
    /// ``SampledAnimation/fillMode`` you choose.
    public var trimStart: TimeInterval?

    /// The optional time, in seconds, at which the animation stops.
    ///
    /// This property is `nil` by default, which plays the animation until the
    /// ``SampledAnimation/end`` frame interval. If you set a value, the
    /// animation subtracts an additional seconds duration from the animation
    /// data that the ``SampledAnimation/end`` frame interval references.
    public var trimEnd: TimeInterval?

    /// An optional duration that overrides the calculated duration.
    ///
    /// This property is `nil` by default, which indicates that the animation
    /// stops after one play that spans ``SampledAnimation/duration``.
    ///
    /// If you set a value for this property and both
    /// ``SampledAnimation/trimStart`` and ``SampledAnimation/trimEnd`` are
    /// `nil`, the animation observes this property as an edited duration.
    ///
    /// A value greater than ``SampledAnimation/duration`` causes the animation
    /// to repeat, applying the characteristics defined by
    /// ``SampledAnimation/repeatMode``. Assign this property
    /// <doc://com.apple.documentation/documentation/swift/double/1849607-greatestfinitemagnitude>
    /// to repeat indefinitely.
    public var trimDuration: TimeInterval?

    /// The time, in seconds, at which the animation begins within the duration.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no offset. Setting a value for this property moves the animation data
    /// along the timeline and doesn't change timing. If you set a
    /// ``SampledAnimation/fillMode`` other than ``AnimationFillMode/none``, the
    /// animation fills the vacant area created by the offset according to the
    /// characteristics of the specified fill mode.
    public var offset: TimeInterval

    /// An amount of time that elapses before the animation plays.
    ///
    /// The default value is `0`, which indicates that the animation plays with
    /// no delay. If you set a value for this property, the animation plays from
    /// its start time after the specified delay lapses.
    ///
    /// During the delayed time, the animation doesn't update. However, to fill
    /// the delayed time with some portion of animation, set a negative
    /// ``SampledAnimation/trimStart`` instead and choose a
    /// ``SampledAnimation/fillMode`` that displays the desired portion of
    /// animation.
    public var delay: TimeInterval

    /// A factor that changes the animation’s rate of playback.
    ///
    /// The default value is `1.0`, which doesn’t alter the animation’s
    /// duration. A value of `2.0` indicates that the duration is half the
    /// normal rate. A value of `0.5` indicates that the duration is twice the
    /// normal rate. Negative values play the animation in reverse.
    ///
    /// This property doesn’t affect the animation’s ``SampledAnimation/delay``.
    public var speed: Float

    /// An option that determines how the animation repeats.
    ///
    /// If you call ``SampledAnimation/trimmed(start:end:duration:)`` with a
    /// `start` or `end` that lies outside of the timeline defined by
    /// ``SampledAnimation/duration``, the animation fills the additional
    /// playback by applying this property.
    public var repeatMode: AnimationRepeatMode

    /// An option that determines how animation frames transition.
    public var tweenMode: TweenMode

    /// The duration within the animation timeline for each frame in the frames
    /// array.
    public var frameInterval: Float

    /// An integer multiple of the frame interval at which the animation plays.
    ///
    /// When calculating the visual beginning of a sampled animation, the
    /// framework first evaluates this property, and then applies the optional
    /// ``SampledAnimation/trimStart``, in seconds.
    ///
    /// The framework requires this property to contain an integer multiple of
    /// ``SampledAnimation/frameInterval``. Note that the value of this property
    /// can be irrational because frame interval is of type
    /// <doc://com.apple.documentation/documentation/foundation/timeinterval>.
    public var start: TimeInterval

    /// An integer multiple of the frame interval at which the animation stops.
    ///
    /// When calculating the visual beginning of a sampled animation, the
    /// framework first evaluates this property, and then applies the optional
    /// ``SampledAnimation/trimEnd``, in seconds.
    ///
    /// The framework requires this property to contain an integer multiple of
    /// ``SampledAnimation/frameInterval``. Note that the value of this property
    /// can be irrational because frame interval is of type
    /// <doc://com.apple.documentation/documentation/foundation/timeinterval>.
    public var end: TimeInterval

    /// The total playback time of the animation.
    ///
    /// The framework sets a value for this property depending on the underlying
    /// animation data and the specified ``SampledAnimation/speed``.
    ///
    /// You can override the default duration by defining
    /// ``SampledAnimation/trimStart``, ``SampledAnimation/trimEnd``, or
    /// ``SampledAnimation/trimDuration``.
    public var duration: TimeInterval

    /// Creates an animation with a collection of frames that represent
    /// incremental steps in the overall timeline.
    ///
    /// - Parameters:
    ///   - frames: An array of values in which each element represents a discrete
    ///     state of the animated property at a given point in the animation’s timeline.
    ///
    ///   - name: A textual name for the animation.
    ///
    ///   - tweenMode: An option that determines how animation frames transition.
    ///
    ///   - frameInterval: The duration within the animation timeline for each
    ///     frame in the frames array.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     builds on the current state of the target entity or resets the state
    ///     before running.
    ///
    ///   - bindTarget: A textual name that identifies the particular property
    ///     that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation
    ///     into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - trimStart: The optional time, in seconds, at which the animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that elapses before the animation plays.
    ///
    ///   - speed: A factor that changes the animation’s rate of playback.
    public init(frames: [Value], name: String = "", tweenMode: TweenMode = .linear, frameInterval: Float = 1.0 / 30.0, isAdditive: Bool = false, bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)
}

@available(macOS 12.0, iOS 15.0, *)
extension SampledAnimation where Value == Float {

    /// An array of floating-point values in which each element represents a
    /// discrete state of the animated property at a given point in the
    /// animation’s timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of `Float` values.
    public var frames: [Float]
}

@available(macOS 12.0, iOS 15.0, *)
extension SampledAnimation where Value == Double {

    /// An array of double-precision values in which each element represents a
    /// discrete state of the animated property at a given point in the
    /// animation’s timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of `Double` values.
    public var frames: [Double]
}

@available(macOS 12.0, iOS 15.0, *)
extension SampledAnimation where Value == SIMD2<Float> {

    /// An array of floating-point pairs in which each element represents a
    /// discrete state of the animated property at a given point in the
    /// animation’s timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of
    /// <doc://com.apple.documentation/documentation/accelerate/simd>
    /// floating-point pairs.
    public var frames: [SIMD2<Float>]
}

@available(macOS 12.0, iOS 15.0, *)
extension SampledAnimation where Value == SIMD3<Float> {

    /// An array of floating-point triplets in which each element represents a
    /// discrete state of the animated property at a given point in the
    /// animation’s timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of
    /// <doc://com.apple.documentation/documentation/accelerate/simd>
    /// floating-point triplets.
    public var frames: [SIMD3<Float>]
}

@available(macOS 12.0, iOS 15.0, *)
extension SampledAnimation where Value == SIMD4<Float> {

    /// An array of floating-point quadruples in which each element represents a
    /// discrete state of the animated property at a given point in the
    /// animation’s timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of
    /// <doc://com.apple.documentation/documentation/accelerate/simd>
    /// floating-point quadruplets.
    public var frames: [SIMD4<Float>]
}

@available(macOS 12.0, iOS 15.0, *)
extension SampledAnimation where Value == simd_quatf {

    /// An array of quaternions in which each element represents a discrete
    /// state of the animated property at a given point in the animation’s
    /// timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of quaternions.
    public var frames: [simd_quatf]
}

@available(macOS 12.0, iOS 15.0, *)
extension SampledAnimation where Value == Transform {

    /// An array of transforms in which each element represents a discrete state
    /// of the target entity at a given point in the animation’s timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of tranforms.
    public var frames: [Transform]
}

@available(macOS 12.0, iOS 15.0, *)
extension SampledAnimation where Value == JointTransforms {

    /// Creates an animation that interpolates between two configurations of the
    /// given joints.
    ///
    /// - Parameters:
    ///   - jointNames: The names of the joints to animate.
    ///
    ///   - frames: The value of the joints to animate.
    ///
    ///   - name: A textual name for the animation.
    ///
    ///   - tweenMode: An option that determines how animation frames transition.
    ///
    ///   - frameInterval: The duration within the animation timeline for each
    ///     frame in the frames array.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     builds on the current state of the target entity or resets the state
    ///     before running.
    ///
    ///   - isScaleAnimated: A Boolean value that indicates whether the animation
    ///     observes changes in the entity’s size.
    ///
    ///   - isRotationAnimated: A Boolean value that indicates whether the
    ///     animation observes rotational changes in the entity’s transform.
    ///
    ///   - isTranslationAnimated: A Boolean value that indicates whether the
    ///     animation observes translational changes in the entity’s transform.
    ///
    ///   - bindTarget: A textual name that identifies the particular property
    ///     that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation
    ///     into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - trimStart: The optional time, in seconds, at which the animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that elapses before the animation plays.
    ///
    ///   - speed: A factor that changes the animation’s rate of playback.
    public init(jointNames: [String], frames: [Value], name: String = "", tweenMode: TweenMode = .linear, frameInterval: Float = 1.0 / 30.0, isAdditive: Bool = false, isScaleAnimated: Bool = true, isRotationAnimated: Bool = true, isTranslationAnimated: Bool = true, bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)

    /// A Boolean value that indicates whether the animation observes changes in
    /// the entity’s size.
    ///
    /// If you set this property to `true`, the animation accommodates scale
    /// differences in the entity’s transform by interpolating to the target
    /// scale across the animation timeline.
    public var isScaleAnimated: Bool

    /// A Boolean value that indicates whether the animation observes rotational
    /// changes in the entity’s transform.
    ///
    /// If you set this property to `true`, the animation accommodates
    /// rotational differences in the entity's transform by interpolating to the
    /// target rotation across the animation timeline.
    public var isRotationAnimated: Bool

    /// A Boolean value that indicates whether the animation observes
    /// translational changes in the entity's transform.
    ///
    /// If you set this property to `true`, the animation accommodates
    /// translation differences in the entity’s transform by interpolating to
    /// the target translation across the animation timeline.
    public var isTranslationAnimated: Bool

    /// An array of joint transforms in which each element represents a discrete
    /// state of the target entity at a given point in the animation's timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of joint transforms.
    public var frames: [JointTransforms]

    /// The names of the joints to animate.
    public var jointNames: [String]
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension SampledAnimation where Value == BlendShapeWeights {

    /// Creates an animation that blends between a configuration of blend targets.
    ///
    /// - Parameters:
    ///   - weightNames: The names of the weights in the animated blend shape.
    ///
    ///   - frames: The value of the weights to animate.
    ///
    ///   - name: A textual name for the animation.
    ///
    ///   - tweenMode: An option that determines how animation frames transition.
    ///
    ///   - frameInterval: The duration within the animation timeline for each
    ///     frame in the frames array.
    ///
    ///   - isAdditive: A Boolean value that indicates whether the animation
    ///     builds on the current state of the target entity or resets the state
    ///     before running.
    ///
    ///   - bindTarget: A textual name that identifies the particular property
    ///     that animates.
    ///
    ///   - blendLayer: The order in which the framework composites the animation
    ///     into the view.
    ///
    ///   - repeatMode: An option that determines how the animation repeats.
    ///
    ///   - fillMode: The playback behavior outside of the normal duration.
    ///
    ///   - trimStart: The optional time, in seconds, at which the animation plays.
    ///
    ///   - trimEnd: The optional time, in seconds, at which the animation stops.
    ///
    ///   - trimDuration: An optional duration that overrides the calculated duration.
    ///
    ///   - offset: The time, in seconds, at which the animation begins within the duration.
    ///
    ///   - delay: An amount of time that elapses before the animation plays.
    ///
    ///   - speed: A factor that changes the animation’s rate of playback.
    public init(weightNames: [String], frames: [Value], name: String = "", tweenMode: TweenMode = .linear, frameInterval: Float = 1.0 / 30.0, isAdditive: Bool = false, bindTarget: BindTarget? = nil, blendLayer: Int32 = 0, repeatMode: AnimationRepeatMode = .none, fillMode: AnimationFillMode = [], trimStart: TimeInterval? = nil, trimEnd: TimeInterval? = nil, trimDuration: TimeInterval? = nil, offset: TimeInterval = 0, delay: TimeInterval = 0, speed: Float = 1.0)

    /// An array of weights in which each element represents a discrete
    /// state of the target entity at a given point in the animation's timeline.
    ///
    /// This array contains sequential values for the animated property when
    /// ``AnimationDefinition/bindTarget`` is an array of weights.
    public var frames: [BlendShapeWeights]

    /// The names of the weights to animate.
    public var weightNames: [String]
}

/// A container that holds the collection of entities that an AR view renders.
///
/// You don’t create a ``Scene`` instance directly. Instead, you get the one and
/// only scene associated with a view from the ``ARView/scene`` property of an
/// ``ARView`` instance.
///
/// ![Block diagram showing the scene as a property of an AR view, with anchor
/// entities as the scene’s children.](Scene-1)
///
/// To add content to the view’s scene, you first create and add one or more
/// ``AnchorEntity`` instances to the scene’s ``RealityKit/Scene/anchors`` collection.
/// Anchors tell RealityKit how to pin virtual content to real world objects,
/// like flat surfaces or images. You then add a hierarchy of other ``RealityKit/Entity``
/// instances to each anchor to indicate the geometry and behaviors that
/// RealityKit should render at a given anchor point.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class Scene {

    /// A name for the scene.
    @MainActor @preconcurrency public var name: String { get }

    /// Searches the scene’s anchor entity hierarchies for an entity with the
    /// given name.
    ///
    /// The ``Scene/findEntity(named:)`` method conducts a depth-first,
    /// recursive search over all of the scene’s entities for one whose
    /// ``Entity/name`` property matches the given name. The method returns the
    /// first match. Entity names need not be unique.
    ///
    /// - Parameters:
    ///   - name: The name of the entity for which to search.
    ///
    /// - Returns: The first entity found with the given name, or `nil` if none
    /// is found.
    @MainActor @preconcurrency public func findEntity(named name: String) -> Entity?

    /// Returns `Entity` with the given `Entity.ID` in the `Scene`.
    /// - Parameters:
    ///    - id:   `Entity.ID` obtained from `Entity.id`
    /// - Returns: `Entity` with the given `Entity.ID`, or `nil` if no such `Entity` is found in the `Scene`.
    /// - Note:    This method uses efficient mapping from `Entity.ID` to `Entity`, not linear traversal of all Entities in the `Scene`.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public func findEntity(id: Entity.ID) -> Entity?

    /// The service to use for network synchronization.
    @MainActor @preconcurrency public var synchronizationService: (any SynchronizationService)?
}

extension Scene {

    /// Returns all entities of the scene which pass the query.
    ///
    /// When in ``System/update(context:)-69f86``, call ``SceneUpdateContext/entities(matching:updatingSystemWhen:)``
    /// instead of `performQuery`.
    /// This allows the ``System`` to sleep on some platforms
    /// when there is no matching component,
    /// reducing unnecessary work.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public func performQuery(_ query: EntityQuery) -> QueryResult<Entity>
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene {

    /// Subscribes to an event type, optionally limited to
    /// events affecting a source entity or scene.
    ///
    /// - Parameters:
    ///   - event: The event type to subscribe to.
    ///     For example ``SceneEvents/Update`` or ``ComponentEvents/DidAdd``.
    ///   - sourceObject: An optional source for the event, such as an entity or a scene.
    ///     Set to `nil` to listen for all events of the event type within the ``Scene``.
    ///   - handler: A closure that runs when the `event` occurs.
    ///
    /// - Returns: An object that represents the subscription to this event stream.
    @MainActor @preconcurrency public func subscribe<E>(to event: E.Type, on sourceObject: (any EventSource)? = nil, _ handler: @escaping (E) -> Void) -> any Cancellable where E : Event

    /// Generates a publisher for events of the specified type.
    ///
    /// - Parameters:
    ///   - event: The event, like `SceneEvents.Update.self`.
    ///
    ///   - sourceObject: The source of the event. Set to `nil` to publish all
    ///     events of the given type within the scene.
    ///
    /// - Returns: A publisher for events of the specified type.
    @MainActor @preconcurrency public func publisher<E>(for event: E.Type, on sourceObject: (any EventSource)? = nil) -> Scene.Publisher<E> where E : Event
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene {

    /// Subscribes to an event type, optionally limited to
    /// events affecting a source entity or scene,
    /// or limited to
    /// a specific component type for component events.
    ///
    /// - Parameters:
    ///   - event: The event type to subscribe to.
    ///     For example ``SceneEvents/Update`` or ``ComponentEvents/DidAdd``.
    ///   - sourceObject: An optional source for the event, such as an entity or a scene.
    ///     Set to `nil` to listen for all events of the event type within the ``Scene``.
    ///   - componentType: An optional component type to filter events to if the event is of the type ``ComponentEvents``.
    ///     Set to `nil` to listen for all events of the event type within the ``Scene``.
    ///   - handler: A closure that runs when the `event` occurs.
    ///
    /// - Returns: An object that represents the subscription to this event stream.
    @MainActor @preconcurrency public func subscribe<E>(to event: E.Type, on sourceObject: (any EventSource)? = nil, componentType: (any Component.Type)?, _ handler: @escaping (E) -> Void) -> any Cancellable where E : Event

    /// Returns a `Publisher` for events of the specified type in a `Scene`.
    ///
    /// - Parameters:
    ///   - event:        The event type to subscribe to. For example, ``SceneEvents/Update``.
    ///   - sourceObject: The event source – usually the entity you are interested in. `nil` to
    ///                     listen all events of this type that occur in the scene.
    ///   - componentType: The component type, or `nil` for all (for ComponentEvents).
    ///
    /// - Returns: A `Publisher` for events of the specified type.
    @MainActor @preconcurrency public func publisher<E>(for event: E.Type, on sourceObject: (any EventSource)? = nil, componentType: (any Component.Type)?) -> Scene.Publisher<E> where E : Event
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene {

    /// A publisher for the given event type in the scene.
    public struct Publisher<E> : Publisher where E : Event {

        /// The kind of values published by this publisher.
        public typealias Output = E

        /// The kind of errors this publisher might publish.
        ///
        /// Use `Never` if this `Publisher` does not publish errors.
        public typealias Failure = Never

        /// Attaches the specified subscriber to this publisher.
        ///
        /// Implementations of ``Publisher`` must implement this method.
        ///
        /// The provided implementation of ``Publisher/subscribe(_:)-4u8kn``calls this method.
        ///
        /// - Parameter subscriber: The subscriber to attach to this ``Publisher``, after which it can receive values.
        public func receive<S>(subscriber: S) where E == S.Input, S : Subscriber, S.Failure == Never
    }
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene {

    /// A collection of anchor entities.
    @MainActor @preconcurrency public struct AnchorCollection : Collection {

        /// The type of element traversed by the iterator.
        public typealias Element = HasAnchoring

        /// A type that represents a position in the collection.
        public typealias Index = Int

        /// A type that represents the indices that are valid for subscripting
        /// the collection, in ascending order.
        public typealias Indices = DefaultIndices<Scene.AnchorCollection>

        /// An iterator that presents the elements of the collection.
        public typealias Iterator = Entity.ChildCollection.IndexingIterator<Scene.AnchorCollection>

        /// A sequence that represents a contiguous subrange of the collection’s
        /// elements.
        public typealias SubSequence = Slice<Scene.AnchorCollection>

        /// Returns an iterator over the elements of the collection.
        @MainActor @preconcurrency public func makeIterator() -> Scene.AnchorCollection.Iterator

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        @MainActor @preconcurrency public var startIndex: Int { get }

        /// The position one greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of an array,
        /// use the half-open range operator (`..<`) with
        /// ``Scene/AnchorCollection/endIndex``. The `..<` operator creates a
        /// range that doesn’t include the upper bound, so it’s safe to
        /// use with ``Scene/AnchorCollection/endIndex``.
        ///
        /// If the array is empty, ``Scene/AnchorCollection/endIndex`` is equal
        /// to ``Scene/AnchorCollection/startIndex``.
        @MainActor @preconcurrency public var endIndex: Int { get }

        /// Returns the position immediately after the given index.
        ///
        /// - Parameters:
        ///   - i: A valid index of the collection. Use a value less than ``endIndex``.
        ///
        /// - Returns: The index value immediately after i.
        @MainActor @preconcurrency public func index(after i: Int) -> Int

        /// Accesses the element at the specified position.
        @MainActor @preconcurrency public subscript(index: Int) -> any HasAnchoring

        /// Adds a new anchor at the end of the collection.
        ///
        /// - Parameters:
        ///   - entity: The element to append to the collection.
        @MainActor @preconcurrency public func append(_ entity: any HasAnchoring)

        /// Adds anchors from an array to the end of this collection.
        ///
        /// - Parameters:
        ///   - array: The array of anchor entities to add.
        @MainActor @preconcurrency public func append(contentsOf array: [any HasAnchoring])

        /// Adds anchors from a sequence to the end of this collection.
        ///
        /// - Parameters:
        ///   - sequence: The sequence of anchor entities to add.
        @MainActor @preconcurrency public func append<S>(contentsOf sequence: S) where S : Sequence, S.Element : HasAnchoring

        /// Removes the anchor at the specified position.
        ///
        /// - Parameters:
        ///   - entity: The anchor to remove from the collection.
        @MainActor @preconcurrency public func remove(_ entity: any HasAnchoring)

        /// Removes and returns the anchor at the specified position.
        ///
        /// - Parameters:
        ///   - index: The position of the anchor to remove.
        ///     Use a valid index of the collection.
        @MainActor @preconcurrency public func remove(at index: Int)

        /// Removes all anchors from the collection.
        ///
        /// - Parameters:
        ///   - keepCapacity: Pass true to keep the existing capacity of the array
        ///     after removing its elements. The default value is false.
        @MainActor @preconcurrency public func removeAll(keepCapacity: Bool = false)

        /// Removes all anchors from the collection.
        @MainActor @preconcurrency public func removeAll()

        /// Replaces the existing anchor collection with a provided collection.
        ///
        /// This method removes all anchors currently in the collection, then
        /// appends all the elements in `entities` to the collection.
        ///
        /// - Parameters:
        ///   - entities: An array of anchors to replace the existing collection.
        @MainActor @preconcurrency public func replaceAll(_ entities: [any HasAnchoring])

        /// Replaces the existing anchor collection with a provided sequence.
        ///
        /// - Parameters:
        ///   - entities: A sequence of anchors to replace the existing
        ///     collection.
        @MainActor @preconcurrency public func replaceAll<S>(_ entities: S) where S : Sequence, S.Element : HasAnchoring
    }
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene : Hashable {

    /// Hashes the essential components of the scene by feeding them into the
    /// given hash function.
    ///
    /// - Parameters:
    ///   - hasher: The hash function to use when combining the components of the
    ///     scene.
    nonisolated public func hash(into hasher: inout Hasher)

    /// Indicates whether two scenes are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first scene to compare.
    ///
    ///   - rhs: The second scene to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two scenes are equal.
    nonisolated public static func == (lhs: Scene, rhs: Scene) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    nonisolated public var hashValue: Int { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene : Identifiable {

    /// The stable identity of the entity associated with this instance.
    nonisolated public var id: UInt64 { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    @available(iOS 13.0, macOS 10.15, *)
    public typealias ID = UInt64
}

/// Scene is a class that can be used as an object
/// on which events can be published and subscribed.
@available(macOS 10.15, iOS 13.0, *)
extension Scene : EventSource {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Scene {

    /// The default timebase for the scene, useful for driving custom
    /// times managed by the user which are derived from the scene time.
    @MainActor @preconcurrency public var timebase: CMTimebase { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene {

    /// Performs a ray cast against all the geometry in the scene for a
    /// ray of a given origin, direction, and length.
    ///
    /// The method ignores entities that lack a ``CollisionComponent``.
    ///
    /// The ``CollisionCastHit/normal`` property on returned result objects
    /// contains the surface normal at the point of intersection with the
    /// entity’s collision shape.
    ///
    /// The following are some details to keep in mind.
    /// * The ray needs to fully intersect a primitive for a hit to be detected. In particular, it is not enough for the ray to precisely tangent or end at the primitive's surface. This becomes especially important when ray casting against primitives that are far away from the ray origin.
    /// * Due to numerical imprecision, it may be necessary to use a slightly longer ray length than your desired maximum distance in order to ensure that a full intersection occurs with your target primitive. Moreover, the length of the ray needs to be a positive finite number that is smaller than ``greatestFiniteMagnitude``.
    ///
    /// - Parameters:
    ///   - origin: The origin of the ray relative to `referenceEntity`.
    ///
    ///   - direction: The direction of the ray relative to `referenceEntity`.
    ///
    ///   - length: The length of the ray relative to `referenceEntity`.
    ///
    ///   - query: A query type.
    ///
    ///   - mask: A collision mask that you can use to prevent collisions with
    ///     certain objects.
    ///
    ///   - referenceEntity: An entity that defines the frame of reference. The
    ///     method returns results relative to this entity. Set to `nil` to use the
    ///     world space origin `(0, 0, 0)`.
    ///
    /// - Returns: An array of collision cast hit results. Each hit indicates
    ///     where the ray, starting at a given point and traveling in a given
    ///     direction, hit a particular entity in the scene.
    @MainActor @preconcurrency public func raycast(origin: SIMD3<Float>, direction: SIMD3<Float>, length: Float = 100, query: CollisionCastQueryType = .all, mask: CollisionGroup = .all, relativeTo referenceEntity: Entity? = nil) -> [CollisionCastHit]

    /// Performs a ray cast against all the geometry in the scene for a
    /// ray between two end points.
    ///
    /// The method ignores entities that lack a ``CollisionComponent``.
    ///
    /// The ``CollisionCastHit/normal`` property on returned result objects
    /// contains the surface normal at the point of intersection with the
    /// entity’s collision shape.
    ///
    /// The following are some details to keep in mind.
    /// * The ray needs to fully intersect a primitive for a hit to be detected. In particular, it is not enough for the ray to precisely tangent or end at the primitive's surface. This becomes especially important when ray casting against primitives that are far away from the ray origin.
    /// * Due to numerical imprecision, it may be necessary to use a slightly longer ray length than your desired maximum distance in order to ensure that a full intersection occurs with your target primitive. Moreover, the length of the ray needs to be a positive finite number that is smaller than ``greatestFiniteMagnitude``.
    ///
    /// - Parameters:
    ///   - startPosition: The start position of the ray relative to
    ///     `referenceEntity`.
    ///
    ///   - endPosition: The end position of the ray relative to
    ///     `referenceEntity`.
    ///
    ///   - query: A query type.
    ///
    ///   - mask: A collision mask that you can use to prevent collisions with
    ///     certain objects.
    ///
    ///   - referenceEntity: An entity that defines the frame of reference. The
    ///     method returns results relative to this entity. Set to `nil` to use the
    ///     world space origin `(0, 0, 0)`.
    ///
    /// - Returns: An array of collision cast hit results. Each hit indicates
    /// where the ray, starting at `startPosition` and ending at `endPosition`,
    /// hit a particular entity in the scene.
    @MainActor @preconcurrency public func raycast(from startPosition: SIMD3<Float>, to endPosition: SIMD3<Float>, query: CollisionCastQueryType = .all, mask: CollisionGroup = .all, relativeTo referenceEntity: Entity? = nil) -> [CollisionCastHit]

    /// Performs a convex shape cast against all the geometry in the scene.
    ///
    /// - Parameters:
    ///   - convexShape: The convex shape to cast.
    ///
    ///   - fromPosition: The starting position of `convexShape` relative to
    ///     `referenceEntity`.
    ///
    ///   - fromOrientation: The starting orientation of `convexShape` relative to
    ///     `referenceEntity`.
    ///
    ///   - toPosition: The ending position of `convexShape` relative to
    ///     `referenceEntity`.
    ///
    ///   - toOrientation: The ending orientation of `convexShape` relative to
    ///     `referenceEntity`.
    ///
    ///   - query: The query type.
    ///
    ///   - mask: A collision mask that you can use to prevent collisions with
    ///     certain objects.
    ///
    ///   - referenceEntity: An entity that defines the frame of reference. The
    ///     method returns results relative to this entity. Set to `nil` to use the
    ///     world space origin `(0, 0, 0)`.
    ///
    /// - Returns: An array of collision cast hit results. Each hit indicates
    /// where the convex shape, starting at a given point and traveling in a
    /// given direction, collides with entities in the scene. To retrieve the
    /// hit entity from a returned ``CollisionCastHit``, use the
    /// ``CollisionCastHit/entity`` property.
    ///
    /// For objects that intersect the convex shape at its starting position and
    /// orientation, the returned collision cast hit result’s
    /// ``CollisionCastHit/position`` is `(0, 0, 0)` and the
    /// ``CollisionCastHit/normal`` points in the opposite direction of the
    /// sweep.
    @MainActor @preconcurrency public func convexCast(convexShape: ShapeResource, fromPosition: SIMD3<Float>, fromOrientation: simd_quatf, toPosition: SIMD3<Float>, toOrientation: simd_quatf, query: CollisionCastQueryType = .all, mask: CollisionGroup = .all, relativeTo referenceEntity: Entity? = nil) -> [CollisionCastHit]
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene : Sendable {
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene.AnchorCollection : CustomStringConvertible {

    /// A textual representation of this instance.
    @MainActor @preconcurrency public var description: String { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension Scene.AnchorCollection : Sendable {
}

/// Events the scene invokes.
///
/// For more information on subscribing to scene events, see ``RealityKit/Scene/Event``.
@available(macOS 10.15, iOS 13.0, *)
public enum SceneEvents {

    /// An event invoked once per frame interval that you can use to execute
    /// custom logic for each frame.
    public struct Update : Event {

        /// The updated scene.
        public let scene: Scene

        /// The elapsed time since the last update.
        public let deltaTime: TimeInterval
    }

    /// An event invoked when the anchored state of an anchoring entity
    /// changes.
    public struct AnchoredStateChanged : Event {

        /// The current anchoring state of the entity.
        public let isAnchored: Bool

        /// The entity whose anchoring state changed.
        public let anchor: any HasAnchoring
    }
}

@available(macOS 12.0, iOS 15.0, *)
extension SceneEvents {

    /// Raised after an entity is added to the scene.
    public struct DidAddEntity : Event {

        public let entity: Entity
    }

    /// Raised after an entity becomes active.
    public struct DidActivateEntity : Event {

        public let entity: Entity
    }

    /// Raised before an entity becomes inactive.
    public struct WillDeactivateEntity : Event {

        public let entity: Entity
    }

    /// Raised before an entity is removed from the scene.
    public struct WillRemoveEntity : Event {

        public let entity: Entity
    }

    /// Raised after an entity has been reparented within the same scene.
    public struct DidReparentEntity : Event {

        public let child: Entity

        public let previousParent: Entity?
    }
}

/// The coordinate space that represents the center of a RealityKit scene.
///
/// The center, or origin, of a RealityKit scene varies depending on the
/// platform and context:
///
/// - term visionOS (Window or Volume): The origin is a point that extends outward from the window, or upward from the volume.
/// - term visionOS (Immersive Space): The origin is the <doc://com.apple.documentation/documentation/arkit> world origin,
///                            which does not directly relate to any specific ``RealityView``, but rather to the
///                            broader immersive environment.
/// - term macOS and iOS (Non-AR): The origin is a point behind the RealityView.
///                           Here, the ``RealityView`` acts as a window through which you can view the scene,
///                           and the scene's origin is placed behind this by default, giving depth to the scene.
/// - term iOS (AR Mode): Similar to the Immersive Space in visionOS, ARKit determines the world origin,
///                   and does not directly relate to the ``RealityView`` position.
///
/// - Note: This object is equivalent to
///   ``RealityCoordinateSpace/scene``.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct SceneRealityCoordinateSpace : RealityCoordinateSpace {

    /// Creates a scene coordinate space.
    public init()
}

/// A component that specifies an entity is participating in the system's scene-understanding features.
///
/// Scene understanding refers to RealityKit features like physics collision, shadows, and occlusion with real-world geometry.
/// In iOS, `SceneUnderstandingComponent` is a read-only component. Manually adding
/// it doesn't have any effect.
///
/// In visionOS, `SceneUnderstandingComponent` is a write-only component.
/// Add `SceneUnderstandingComponent` to your custom entities to let it behave
/// as a virtual scene-understanding mesh.
///
/// For more information about scene-understanding features, see <doc:realitykit-scene-understanding>.
@available(iOS 13.4, macCatalyst 14.0, *)
public struct SceneUnderstandingComponent : Component {

    /// Types of real-world objects that a scene-understanding component models.
    @available(macOS 12.0, iOS 15.0, *)
    public enum EntityType : Hashable {

        /// An entity that models the physical shape of the environment within
        /// a given cubic region.
        case meshChunk

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SceneUnderstandingComponent.EntityType, b: SceneUnderstandingComponent.EntityType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a component for the given entity type that makes an entity aware
    /// of certain aspects of the physical environment.
    ///
    /// - Parameters:
    ///   - entityType: The entity type to make the component for.
    @available(macOS 12.0, iOS 15.0, *)
    public init(entityType: SceneUnderstandingComponent.EntityType?)

    /// Creates a component that makes an entity aware of certain aspects of the
    /// physical environment.
    @available(macOS 12.0, iOS 15.0, *)
    public init()

    /// The type of real-world objects that the component models.
    @available(macOS 12.0, iOS 15.0, *)
    public var entityType: SceneUnderstandingComponent.EntityType?
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension SceneUnderstandingComponent {

    /// Types of scene-understanding origins this component lives in.
    public enum Origin : Hashable {

        /// A scene-understanding component that is owned and created by the system.
        /// Component of this origin type will model an object in real world environment.
        case system

        /// A scene-understanding component that is owned and created by the developer.
        /// Component of this origin type will model an object in virtual environment.
        case user

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SceneUnderstandingComponent.Origin, b: SceneUnderstandingComponent.Origin) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The origin that RealityKit creates the component from.
    public var origin: SceneUnderstandingComponent.Origin { get }
}

/// An object that contains information about the scene to update.
///
/// RealityKit uses a ``SceneUpdateContext`` to pass information to a ``System``
/// about the scene it’s currently updating.
@available(macOS 12.0, iOS 15.0, *)
public struct SceneUpdateContext {

    /// The updating scene.
    public var scene: Scene

    /// The number of seconds elapsed since the last update.
    public var deltaTime: TimeInterval
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension SceneUpdateContext {

    /// Returns all entities which pass the query predicate of the query.
    ///
    /// Calling this function can increase the rate at which RealityKit calls
    /// the ``System/update(context:)-69f86`` method.
    /// If `condition` is not met for the current update,
    /// this method returns an empty result.
    ///
    /// - Parameters:
    ///   - query: The query identifying which entities you want to fetch.
    ///   - condition: How often the ``System`` is updated (if the query is not empty).
    public func entities(matching query: EntityQuery, updatingSystemWhen condition: SystemUpdateCondition) -> QueryResult<Entity>
}

/// An action that enables or disables the targeted entity and its descendants when played as an animation.
///
/// This action toggles the ``SetEntityEnabledAction/targetEntity`` ``Entity/isEnabled`` flag.
/// Use the animation generated from this action within an animation group to determine when the entity should be
/// enabled, and visible in the scene.
///
/// The example below creates an animation which disables the entity after five seconds.
/// In this example, the target entity starts enabled.
///
/// ```swift
/// // Create an action entity resolution.
/// //
/// // The animation will be played from the parent entity.
/// let childEntity: ActionEntityResolution = .entityNamed("childEntity")
///
/// // Create an action to disable the entity.
/// let disableEntityAction = SetEntityEnabledAction(targetEntity: childEntity,
///                                                  isEnabled: false)
///
/// // Create a small positive duration value.
/// let duration: TimeInterval = 1 / 30.0
///
/// // Create an animation to disable the target entity.
/// let disableEntityAnimation = try AnimationResource
///     .makeActionAnimation(for: disableEntityAction,
///                          duration: duration,
///                          delay: 5.0)
///
/// // Play the sequence animation that plays the actions.
/// rootEntity.playAnimation(disableEntityAnimation)
/// ```
/// @Video(
///     source: setentityenabled-action,
///     alt: "A screen recording of a red cube in a living room scene. At the start, the cube is visibly enabled in the scene. After some time, the cube is disabled; it's no longer visible in the scene.",
///     poster: setentityenabled-action-poster
/// )
///
/// - Note: Animations do not play on entities that are disabled. In order to disable, and enable the target entity,
///         play this action on another entity, such as a root entity, or its parent.
///
/// - Important: This action does not animate a bound property, such as ``BindTarget/transform``.
///
/// - Tip: This action performs instantaneously, consider supplying a small positive duration value when creating the animation.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct SetEntityEnabledAction : EntityAction, Codable {

    /// The entity to disable or enable.
    public var targetEntity: ActionEntityResolution

    /// A Boolean that you set to enable or disable the entity and its descendants.
    public var isEnabled: Bool

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public var animatedValueType: (any AnimatableData.Type)? { get }

    /// Creates a new set entity enabled action.
    ///
    /// - Parameters:
    ///   - targetEntity: The entity to disable or enable.
    ///   - isEnabled: A Boolean that you set to enable or disable the entity and its descendants.
    public init(targetEntity: ActionEntityResolution = .sourceEntity, isEnabled: Bool)

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct ShaderGraphMaterial : Material, Sendable {

    public enum Error : LocalizedError {

        case incorrectTypeForParameterName

        case parameterNameNotFound

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ShaderGraphMaterial.Error, b: ShaderGraphMaterial.Error) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    public static func parameterHandle(name: String) -> MaterialParameters.Handle

    public mutating func setParameter(handle: MaterialParameters.Handle, value newValue: MaterialParameters.Value) throws

    public func getParameter(handle: MaterialParameters.Handle) -> MaterialParameters.Value?

    public mutating func setParameter(name: String, value newValue: MaterialParameters.Value) throws

    public func getParameter(name: String) -> MaterialParameters.Value?

    public var parameterNames: [String] { get }

    /// An alias for the triangle fill mode object that’s appropriate for this
    /// material class.
    public typealias TriangleFillMode = MaterialParameterTypes.TriangleFillMode

    /// The object that controls how RealityKit draws triangles.
    ///
    /// A value of ``MaterialParameterTypes/TriangleFillMode/fill`` causes RealityKit
    /// to draw triangles normally, while a value of  ``MaterialParameterTypes/TriangleFillMode/lines``
    /// turns on wireframe rendering.
    public var triangleFillMode: ShaderGraphMaterial.TriangleFillMode
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ShaderGraphMaterial {

    public enum LoadError : LocalizedError {

        case invalidTypeFound

        case materialNameNotFound

        case invalidURL

        case resourceShareFailed

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ShaderGraphMaterial.LoadError, b: ShaderGraphMaterial.LoadError) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Loads a ShaderGraphMaterial from a named material within a USD file.
    ///
    /// - Parameters:
    ///   - name:     The name of the ShaderGraphMaterial within the USD file.
    ///   - data:     A data object containing USD file data
    ///
    /// - Returns: A ShaderGraphMaterial object from the file with the name specified.
    ///
    /// Supported file formats are USD (.usd, .usda, .usdc, .usdz)
    public init(named name: String, from data: Data) async throws

    /// Loads a ShaderGraphMaterial from a bundle.
    ///
    /// - Parameters:
    ///   - name:     The name of the ShaderGraphMaterial within the file.
    ///                 For USD files, this is the full path of the material prim (such as "/Root/MyMaterial").
    ///   - file:     The name of the file within the bundle.
    ///   - bundle:   The bundle containing the resource. Specify nil to search the app’s main
    ///                 bundle.
    ///
    /// - Returns: A ShaderGraphMaterial object from the file with the name specified.
    ///
    /// Supported file formats are USD (.usd, .usda, .usdc, .usdz) and Reality File (.reality).
    public init(named name: String, from file: String, in bundle: Bundle? = nil) async throws

    /// Loads a ShaderGraphMaterial from a url.
    ///
    /// - Parameters:
    ///   - name:     The name of the ShaderGraphMaterial within the file.
    ///                 For USD files, this is the full path of the material prim (such as "/Root/MyMaterial").
    ///   - url:      The path or address of the file containing the ShaderGraphMaterial.
    ///
    /// - Returns: A ShaderGraphMaterial object from the file with the name specified.
    ///
    /// Supported file formats are USD (.usd, .usda, .usdc, .usdz) and Reality File (.reality).
    public init(named name: String, from url: URL) async throws

    /// Loads a ShaderGraphMaterial from MaterialX data.
    ///
    /// - Parameters:
    ///   - materialXLabel: The name of the ShaderGraphMaterial in the MaterialX data.
    ///   - data:           The data containing the MaterialX file contents.
    ///
    /// - Returns: A ShaderGraphMaterial object from the data with the label specified.
    ///
    public init(materialXLabel: String, data: Data) async throws
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension ShaderGraphMaterial {

    /// An alias for the cull mode object that’s appropriate for this material class.
    public typealias FaceCulling = MaterialParameterTypes.FaceCulling

    /// A process in which the system specifies polygons to remove before
    /// rendering a mesh using this material.
    ///
    /// To improve performance, RealityKit culls polygons, or faces, that it
    /// determines won’t be visible. Discarding faces that aren’t part of the
    /// final render eliminates the need to do any calculations for those
    /// faces.
    ///
    /// RealityKit recognizes when a face aims toward the camera (a front face)
    /// or away from the camera (a back face). This value controls the type of
    /// faces RealityKit culls.
    ///
    /// This value defaults to ``MaterialParameterTypes/FaceCulling/back``,
    /// which means RealityKit removes faces that point away from the camera.
    /// Most of the time, this is the correct behavior, because back faces are
    /// usually obscured by other front-facing polygons.
    ///
    /// You can change the culling behavior to cull front faces instead or to
    /// turn off face culling altogether, but be aware that turning off face
    /// culling results in less efficient rendering and may negatively impact
    /// your app’s frame rate.
    public var faceCulling: ShaderGraphMaterial.FaceCulling

    /// A boolean value that determines whether this material writes its depth into RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will occlude objects behind them by writing their depth
    /// into RealityKit's depth buffer.
    ///
    /// If false, meshes with this material will not write their depth into
    /// RealityKit's depth buffer, and may be overwritten by objects drawn behind them, depending on
    /// draw order.
    ///
    /// The default value is true.
    public var writesDepth: Bool

    /// A boolean value that determines whether this material performs the depth test by reading RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will depth test each of their fragments when being rendered.
    /// If an object that writes depth is in front of this material, this material will be hidden.
    ///
    /// If false, meshes with this material will ignore the depth test, and always render all of their 
    /// fragments during their draw call, regardless of the positioning of other objects in the scene.
    /// Note that other objects may still render on top of this material, depending on draw order.
    ///
    /// The default value is true.
    public var readsDepth: Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ShaderGraphMaterial.Error : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ShaderGraphMaterial.Error : Hashable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ShaderGraphMaterial.LoadError : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ShaderGraphMaterial.LoadError : Hashable {
}

/// A representation of a shape.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class ShapeResource : Resource, Hashable, Sendable {

    /// Axis aligned bounding box in world space.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public var bounds: BoundingBox { get }

    /// Indicates whether two shapes are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first shape to compare.
    ///
    ///   - rhs: The second shape to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two shapes are equal.
    @MainActor @preconcurrency public static func == (lhs: ShapeResource, rhs: ShapeResource) -> Bool

    /// Hashes the essential components of the shape by feeding them into the
    /// given hash function.
    ///
    /// - Parameters:
    ///   - hasher: The hash function to use when combining the components of the
    ///     shape.
    @MainActor @preconcurrency public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    nonisolated public var hashValue: Int { get }
}

@available(macOS 10.15, iOS 13.0, *)
extension ShapeResource {

    /// Creates a new shape resource by applying a rotation.
    ///
    /// - Parameters:
    ///   - rotation: The rotation to apply to the existing shape resource.
    ///
    /// - Returns: The transformed resource.
    @MainActor @preconcurrency public func offsetBy(rotation: simd_quatf) -> ShapeResource

    /// Creates a new shape resource by applying a translation.
    ///
    /// - Parameters:
    ///   - translation: The translation to apply to the existing shape resource.
    ///
    /// - Returns: The transformed resource.
    @MainActor @preconcurrency public func offsetBy(translation: SIMD3<Float>) -> ShapeResource

    /// Creates a new shape resource by applying a rotation and a translation.
    ///
    /// - Parameters:
    ///   - rotation: The rotation to apply to the existing shape resource.
    ///   - translation: The translation to apply to the existing shape resource.
    ///
    /// - Returns: The transformed resource.
    @MainActor @preconcurrency public func offsetBy(rotation: simd_quatf = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1), translation: SIMD3<Float> = SIMD3<Float>()) -> ShapeResource

    /// Creates a box shape with the specified extent.
    ///
    /// - Parameters:
    ///   - size: The box extent in meters along the local axes.
    ///
    /// - Note: Collision shape extents that fall below 2mm are forced to be 2mm in size - this includes,
    ///   entities with negative scale values.
    ///
    /// - Returns: The new box centered at the local origin and aligned with the
    /// local axes.
    @MainActor @preconcurrency public static func generateBox(size: SIMD3<Float>) -> ShapeResource

    /// Creates a box shape with the specified dimensions.
    ///
    /// - Parameters:
    ///   - width: The extent of the box along the x-axis in meters.
    ///
    ///   - height: The extent of the box along the y-axis in meters.
    ///
    ///   - depth: The extent of the box along the z-axis in meters.
    ///
    /// - Note: Collision shape extents that fall below 2mm are forced to be 2mm in size - this includes,
    ///   entities with negative scale values.
    ///
    /// - Returns: The new box centered at the local origin and aligned with the
    /// local axes.
    @MainActor @preconcurrency public static func generateBox(width: Float, height: Float, depth: Float) -> ShapeResource

    /// Creates a capsule shape with the specified height and radius.
    ///
    /// - Parameters:
    ///   - height: The height of the capsule including the spherical caps in meters, measured along the local y-axis.
    ///
    ///   - radius: The radius of the capsule in meters.
    ///
    /// - Note: Collision shape extents that fall below 2mm are forced to be 2mm in size - this includes,
    ///   entities with negative scale values.
    ///
    /// - Returns: The new capsule.
    @MainActor @preconcurrency public static func generateCapsule(height: Float, radius: Float) -> ShapeResource

    /// Creates a convex shape from the given points.
    ///
    /// - Parameters:
    ///   - points: An array of 3D points that define the convex polyhedron.
    ///             Keep the number of points small to avoid hurting performance.
    ///
    /// - Returns: The new shape.
    @MainActor @preconcurrency public static func generateConvex(from points: [SIMD3<Float>]) -> ShapeResource

    /// Creates a convex shape from the given mesh.
    ///
    /// - Parameters:
    ///   - mesh: A mesh with the shape of the convex polyhedron. Use meshes with
    ///     a small number of vertices to avoid hurting performance.
    ///
    /// - Returns: The new shape.
    @MainActor @preconcurrency public static func generateConvex(from mesh: MeshResource) -> ShapeResource

    /// Creates a convex shape from the given mesh.
    ///
    /// - Parameters:
    ///   - mesh: A mesh with the shape of the convex polyhedron. Use meshes with a small number of vertices to
    ///     avoid hurting performance.
    ///
    /// - Returns: The new shape, defined by the convex hull of the vertices in `mesh`.
    /// - Throws: Will throw an error if `mesh` does not define a nonempty convex volume.  For example, will fail if
    ///           all the vertices in `mesh` are coplanar.
    nonisolated public static func generateConvex(from mesh: MeshResource) async throws -> ShapeResource

    /// Creates a convex shape from the given points asynchronously.
    ///
    /// - Parameters:
    ///   - points: An array of 3D points that define the convex polyhedron. Keep the number of points small to
    ///     avoid hurting performance.
    ///
    /// - Returns: A new ShapeResource object defined by the convex hull of `points`.
    /// - Throws: Will throw an error if `points` do not define a nonempty convex volume.  For example, will fail if
    ///   all of the points in `points` are coplanar.
    nonisolated public static func generateConvex(from points: [SIMD3<Float>]) async throws -> ShapeResource

    /// Creates a sphere shape with the specified radius.
    ///
    /// - Parameters:
    ///   - radius: The radius of the sphere in meters.
    ///
    /// - Note: Collision shape extents that fall below 2mm are forced to be 2mm in size - this includes,
    ///   entities with negative scale values.
    ///
    /// - Returns: The new sphere centered at the local origin.
    @MainActor @preconcurrency public static func generateSphere(radius: Float) -> ShapeResource
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ShapeResource {

    /// Creates a static collision mesh from an array of vertex positions and face indices.
    ///
    /// The triangle mesh is pre-processed into an optimized format before being used by the physics engine.
    /// The pre-processing step can take significant time if the position counts are large.
    /// To minimize this cost, the position count should be as small as possible.
    /// The returned `ShapeResource` can only be used under the following circumstances:
    /// - You can only use this shape with ``PhysicsBodyMode/static``
    ///   and not `.dynamic` or `.kinematic`.
    /// - You can't use this shape with ``CollisionComponent/Mode-swift.enum/trigger``.
    ///
    /// - Parameters:
    ///   - positions: An array of vertex positions containing discrete points on the mesh.
    ///   - faceIndices: An array of integers used to index into the position array.
    ///                  Each three indices define a polygon in the mesh.
    nonisolated public static func generateStaticMesh(positions: [SIMD3<Float>], faceIndices: [UInt16]) async throws -> ShapeResource
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension ShapeResource {

    /// Creates a static collision mesh from a mesh resource.
    ///
    /// You can use only the physics body mode ``PhysicsBodyMode/static`` and the
    /// collision component mode ``CollisionComponent/Mode-swift.enum/default`` with this shape.
    ///
    /// The code example below assumes calling this method from a synchronous block:
    ///
    /// ```swift
    /// // Use a low-priority task because generating collision meshes can take a while.
    /// let myShapeTask = Task(priority: .low) {
    ///     let meshResource = await MeshResource(
    ///         shape: .generateBox(size: [5, 5, 5])
    ///     )
    ///
    ///     guard let shape = try? await ShapeResource.generateStaticMesh(
    ///         from: meshResource
    ///     ) else { return }
    ///
    ///     // You can use the `ShapeResource` to make a
    ///     // `CollisionComponent`, and add that to an entity.
    ///     // Run this from the main thread.
    ///     await MainActor.run {
    ///         let entity = Entity()
    ///         let collision = CollisionComponent(shapes: [shape])
    ///         entity.components.set(collision)
    ///
    ///         // Note that you can't set `mode` to `.dynamic`.
    ///         // This only supports `.static`.
    ///         let physicsBody = PhysicsBodyComponent(
    ///             massProperties: .default,
    ///             material: nil,
    ///             mode: .static
    ///         )
    ///         entity.components.set(physicsBody)
    ///         // ...
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - mesh: The mesh resource for generating the collision shape.
    @MainActor @preconcurrency public static func generateStaticMesh(from mesh: MeshResource) async throws -> ShapeResource
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public enum ShapeResourceError : LocalizedError {

    case staticMeshGenerationFailed

    case convexPolyhedronGenerationFailed

    /// A localized message describing what error occurred.
    public var errorDescription: String? { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ShapeResourceError, b: ShapeResourceError) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ShapeResourceError : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension ShapeResourceError : Hashable {
}

/// A basic material that responds to lights in the scene.
///
/// `SimpleMaterial` responds to both
/// real and virtual lighting to enhance realism.
///
/// Add a `SimpleMaterial` to a model by setting it as one of the
/// ``ModelComponent/materials`` in a ``ModelComponent``.
///
/// ```swift
/// let simpleMaterial = SimpleMaterial(
///     color: .red, isMetallic: false
/// )
/// let model = ModelComponent(
///     mesh: .generateBox(size: 1),
///     materials: [simpleMaterial]
/// )
/// redBoxEntity.components.set(model)
/// ```
///
/// For example, a red `SimpleMaterial` that is not metallic, and one that is metallic:
///
/// | Not metallic | Metallic |
/// |:-:|:-:|
/// | ![A screenshot of a red cube in a living room scene. The cube is rounded on the edges and appears to be made of a reflective plastic material.](simplematerial-not-metallic) | ![A screenshot of a red cube in a living room scene. The cube is rounded on the edges and appears to be made of a reflective metal material.](simplematerial-metallic) |
@available(macOS 10.15, iOS 13.0, *)
public struct SimpleMaterial : Material {

    /// The material’s color.
    @available(macOS 12.0, iOS 15.0, *)
    public var color: SimpleMaterial.BaseColor

    /// The roughness of the material.
    public var roughness: MaterialScalarParameter

    /// A Boolean value that you set to control whether the material has a
    /// metallic look.
    ///
    /// This property defines whether a material is dielectric (`0.0`) or a metallic (`1.0`). Although
    /// this property can be set to any value between `0` and `1`, to create a realistic material, set it
    /// to either `0` or `1`.).
    ///
    /// - term Dielectric materials: These are materials that simulate real-world materials that are poor
    /// conductors. In these materials, light travels into the surface of the material and the color is mostly
    /// controlled by the color of the sub-surface. Typical examples of dielectric materaisl include organic
    /// materials, plastics, and industrial minerals such as sand, limestone,  marble, clay and salt.
    ///
    /// - term Metallic: A metallic (or *conductive*) material reflects light differently than dielectric ones.
    /// The overall color is caused by an immediate re-emission of the light from the entity's surface. Typical
    /// examples of metallic materials include aluminum, chassis metal, chromium, copper, gold, silver, and
    /// titanium
    public var metallic: MaterialScalarParameter

    /// Creates a simple material.
    public init()

    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public typealias TriangleFillMode = MaterialParameterTypes.TriangleFillMode

    /// The object that controls how RealityKit draws triangles.
    ///
    /// A value of ``MaterialParameterTypes/TriangleFillMode/fill`` causes RealityKit
    /// to draw triangles normally, while a value of  ``MaterialParameterTypes/TriangleFillMode/lines``
    /// turns on wireframe rendering.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public var triangleFillMode: SimpleMaterial.TriangleFillMode
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension SimpleMaterial {

    /// A boolean value that determines whether this material writes its depth into RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will occlude objects behind them by writing their depth
    /// into RealityKit's depth buffer.
    ///
    /// If false, meshes with this material will not write their depth into
    /// RealityKit's depth buffer, and may be overwritten by objects drawn behind them, depending on
    /// draw order.
    ///
    /// The default value is true.
    public var writesDepth: Bool

    /// A boolean value that determines whether this material performs the depth test by reading RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will depth test each of their fragments when being rendered.
    /// If an object that writes depth is in front of this material, this material will be hidden.
    ///
    /// If false, meshes with this material will ignore the depth test, and always render all of their
    /// fragments during their draw call, regardless of the positioning of other objects in the scene.
    /// Note that other objects may still render on top of this material, depending on draw order.
    ///
    /// The default value is true.
    public var readsDepth: Bool
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension SimpleMaterial {

    /// An alias for the cull mode object that’s appropriate for this material class.
    public typealias FaceCulling = MaterialParameterTypes.FaceCulling

    /// A process in which the system specifies polygons to remove before
    /// rendering a mesh using this material.
    ///
    /// To improve performance, RealityKit culls polygons, or faces, that it
    /// determines won’t be visible. Discarding faces that aren’t part of the
    /// final render eliminates the need to do any calculations for those
    /// faces.
    ///
    /// RealityKit recognizes when a face aims toward the camera (a front face)
    /// or away from the camera (a back face). This value controls the type of
    /// faces RealityKit culls.
    ///
    /// This value defaults to ``MaterialParameterTypes/FaceCulling/back``,
    /// which means RealityKit removes faces that point away from the camera.
    /// Most of the time, this is the correct behavior, because back faces are
    /// usually obscured by other front-facing polygons.
    ///
    /// You can change the culling behavior to cull front faces instead or to
    /// turn off face culling altogether, but be aware that turning off face
    /// culling results in less efficient rendering and may negatively impact
    /// your app’s frame rate.
    public var faceCulling: SimpleMaterial.FaceCulling
}

@available(macOS 12.0, iOS 15.0, *)
extension SimpleMaterial {

    /// The type used to represent base color.
    @available(macOS 12.0, iOS 15.0, *)
    public typealias BaseColor = PhysicallyBasedMaterial.BaseColor

    /// The type used to represent textures.
    @available(macOS 12.0, iOS 15.0, *)
    public typealias Texture = PhysicallyBasedMaterial.Texture
}

/// A container that holds the position and orientation of each joint in a single animation skeleton.
///
/// Each index in ``jointNames`` directly corresponds to the same index in ``jointTransforms``,
/// linking each joint name to its respective transform.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct SkeletalPose : Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = String

    /// The unique identifier of the pose.
    public var id: SkeletalPose.ID

    /// The names of the joints in the pose in specific order.
    ///
    /// Each joint name has a corresponding transformation value in ``jointTransforms`` at the same index.
    ///
    /// Updates of the value results in resizing or reordering of the pose's ``jointTransforms`` to match.
    /// New joint names add identity transformations at the matching indices.
    public var jointNames: [String]

    /// The transformations of the joints in the pose.
    ///
    /// Each joint transformation has a corresponding name in ``jointNames`` at the same index.
    ///
    /// A new value with element count not matching the element count  of ``jointNames`` is accepted but invokes
    /// special handling when the ``SkeletalPosesComponent`` is set on an entity.
    public var jointTransforms: JointTransforms

    /// Accesses a pose transformation using the index of the joint name.
    ///
    /// - Parameter joint: The joint name of transformation to access.
    /// - Note: Setting a joint to `nil` has no effect.
    public subscript(joint: String) -> Transform?

    /// Creates a skeletal pose from the rest pose of the model skeleton.
    ///
    /// - Parameters:
    ///   - id: The unique name of the pose.
    ///   - skeleton: The skeleton to extract the joint names and rest pose transformations from.
    public init(id: SkeletalPose.ID, from skeleton: MeshResource.Skeleton)

    /// Creates a pose for the joint name and transformation pairs.
    ///
    /// - Parameters:
    ///   - id: The unique name of the pose.
    ///   - joints: An array of tuples, each containing a name and its corresponding transformation, arranged in any order of your choosing.
    public init(id: SkeletalPose.ID, joints: [(String, JointTransforms.Element)])
}

/// A collection of named skeletal poses.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct SkeletalPoseSet {

    /// A type representing the sequence's elements.
    public typealias Element = SkeletalPose

    /// Creates an empty collection.
    public init()

    /// Accesses the first skeletal pose.
    ///
    /// Equivalent to accessing ``HasModel/jointNames`` and ``HasModel/jointTransforms`` if used from
    /// an entity with a skeletal model.
    public var `default`: SkeletalPoseSet.Element?

    /// The number of elements in the collection.
    public var count: Int { get }

    /// A Boolean value indicating whether the collection is empty.
    public var isEmpty: Bool { get }

    /// Accesses the element with the specified identifier.
    ///
    /// If multiple poses share the same identifier, only the one with lowest index is accessed.
    ///
    /// The update only has an effect if all of the following conditions are true:
    /// * A pose with the provided identifier exists in the collection.
    /// * The new value isn't `nil`.
    /// * The pose with the provided identifier contains the same number of elements for its ``SkeletalPose/jointTransforms``.
    /// - Parameter poseID: The identifier of the requested pose.
    public subscript(poseID: SkeletalPose.ID) -> SkeletalPoseSet.Element?

    /// Checks if the set contains a pose with the given name.
    /// - Parameter poseID: The name of the pose to look up
    /// - Returns: `true` a pose with matching name is contained in the set.
    public func contains(_ poseID: SkeletalPose.ID) -> Bool

    /// Updates a pose in the set based on its name. If pose with this ID does not exist, does nothing.
    /// - Parameter newValue: The pose to store.
    /// - Returns: The previous pose value, if named pose exists
    @discardableResult
    public mutating func set(_ newValue: SkeletalPoseSet.Element) -> SkeletalPoseSet.Element?
}

/// Conformance to Sequence
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension SkeletalPoseSet : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> SkeletalPoseSet.Element?

        /// The type of element traversed by the iterator.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Element = SkeletalPoseSet.Element
    }

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> SkeletalPoseSet.Iterator
}

/// Conformance to Collection
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension SkeletalPoseSet : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// The index of the first pose in a nonempty set.
    public var startIndex: SkeletalPoseSet.Index { get }

    /// The index of the last pose in a nonempty set.
    public var endIndex: SkeletalPoseSet.Index { get }

    /// Returns the index where the specified pose appears in the collection.
    public func index(of poseID: SkeletalPose.ID) -> SkeletalPoseSet.Index?

    /// Accesses the pose at the specified index.
    public subscript(index: SkeletalPoseSet.Index) -> SkeletalPoseSet.Element

    /// Returns the index after the given index.
    public func index(after: SkeletalPoseSet.Index) -> SkeletalPoseSet.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = DefaultIndices<SkeletalPoseSet>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<SkeletalPoseSet>
}

/// A component that exposes the collection of named animation skeletal poses.
///
/// Use the entity's skeletal poses to either read the pose evaluated from animations bound to
/// ``BindTarget/jointTransforms`` and ``BindTarget/skeletalPose(_:)``, 
/// or write your own pose to animate the skeletal model.
///
/// ### Setting updated value on an entity
/// When an updated ``SkeletalPose`` is set on an entity as part of this component, these rules are followed:
/// * If ``SkeletalPose/jointNames`` is reordered, following animation updated will match the new order.
/// * If ``SkeletalPose/jointTransforms`` contains more elements than ``SkeletalPose/jointNames``,
/// the extra transformations are ignored.
/// * If ``SkeletalPose/jointTransforms`` contains less elements than ``SkeletalPose/jointNames``,
/// the extra joint transformations are not updated.
///
/// You can use ``poses``'s ``SkeletalPoseSet/default`` accessor for the same skeletal pose as exposed by
/// ``HasModel/jointNames`` and ``HasModel/jointTransforms``. The access trough the component allows
/// the reordering, addition and removal of joints from the default pose.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct SkeletalPosesComponent : Component {

    /// The collection of the skeletal poses for a single entity.
    public var poses: SkeletalPoseSet

    /// Creates a component value with the provided poses.
    ///
    /// - Warning: When multiple poses share the same identifier, only the first one is accessible using its identifier.
    /// - Parameter poses: The pose values, arranged in any order of your choosing.
    public init(poses: [SkeletalPose])
}

/// A component that configures how sounds emit from an entity into a person's environment.
///
/// The audio system continuously updates the position and orientation of spatial audio sources automatically,
/// so sounds come from an entity wherever it goes and wherever it points.
/// Spatial audio sources incorporate a person's environment acoustics
/// so that they blend in naturally with the surrounding area.
/// The system distance-attenuates the spatial audio sources so they become quieter the farther away they
/// are from the person.
///
/// - Note: Spatial audio sources emit only a single channel (that is, mono).
/// The engine mixes any stereo or multichannel audio resources down to a single channel before spatialization.
/// To avoid any unwanted mixdown artifacts, use mono source material where possible.
///
/// RealityKit audio playback is spatial by default, so no additional configuration is necessary to opt into sophisticated spatial rendering.
///
/// ```swift
/// let entity = Entity()
/// let resource = try AudioFileResource.load(named: "MyAudioFile")
/// entity.playAudio(resource) // Audio file is played spatially from entity
/// ```
///
/// `SpatialAudioComponent` allows you to further customize the playback characteristics of spatial audio sources.
/// The ``gain``, ``directLevel``, and ``reverbLevel`` properties are in relative decibels, in the range `[-Decibel.infinity, Decibel.zero]`,
/// where `-Decibel.infinity` is silent and `Decibel.zero` is nominal.
///
/// For example, you can adjust the overall level of all sounds the entity plays with the ``gain`` property.
///
/// ```swift
/// entity.spatialAudio = SpatialAudioComponent(gain: -10)
/// ```
///
/// You can reduce the amount of reverb you apply to all sounds the entity plays with the ``reverbLevel`` property. Reduce this
/// value to make the sounds less reverberant and more intimate. Set ``reverbLevel`` to `-Decibel.infinity` to cause the sounds to
/// collapse into the head of the listener.
///
/// ```swift
/// entity.spatialAudio?.reverbLevel = -6
/// ```
///
/// You can update ``gain``, ``directLevel``, and ``reverbLevel`` properties dynamically.
/// For example, you can update them when your app's state changes,
/// or in the context of a custom RealityKit system.
///
/// The ``directivity`` property allows you to configure the radiation pattern for sound that an entity emits.
///
/// ```swift
/// entity.spatialAudio?.directivity = .beam(focus: 0.5)
/// ```
///
/// Spatial audio sources project sounds along their negative z-axis. 
/// If you colocate and co-orient a spatial audio source using visual content that you author
/// with a positive z-forward coordinate convention, you need to rotate your spatial audio source 180º about the y-axis.
///
/// ```swift
/// let parent = Entity()
///
/// // Add a model entity.
/// let model = try ModelEntity.load(named: "PositiveZForward")
/// parent.addChild(model)
///
/// // Add an audio source entity.
/// let audioSource = Entity()
/// parent.addChild(audioSource)
///
/// // Orient the audio source toward +Z.
/// audioSource.orientation = .init(angle: .pi, axis: [0, 1, 0])
/// ```
///
/// This is only a consideration if you explicitly set a ``directivity`` other than the default `.beam(focus: .zero)`, which
/// projects sound evenly for all frequencies in all directions.
///
/// The ``distanceAttenuation`` property allows you to configure the way that a sound level decreases
/// as the distance between the listener and the sound source increases.
///
///```swift
///entity.spatialAudio?.distanceAttenuation = .rolloff(factor: 2)
///```
///
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct SpatialAudioComponent {

    /// The overall level for all sounds that an entity emits.
    ///
    /// The gain level is in relative decibels, in the range  `[-Decibel.infinity, Decibel.zero]`, where `Decibel.zero` is the default.
    public var gain: Audio.Decibel

    /// The level of the direct unreverberated signal that an entity emits.
    ///
    /// The direct level is in relative decibels, in the range `[-Decibel.infinity, Decibel.zero]`, where `Decibel.zero` is the default.
    public var directLevel: Audio.Decibel

    /// The level of reverberated signal that an entity emits.
    ///
    /// The reverb level is in relative decibels, in the range  `[-Decibel.infinity, Decibel.zero]`, where `Decibel.zero` is the default.
    ///
    /// Reduce this value to make the sounds less reverberant and more intimate.
    /// Reduce this value to `-Decibel.infinity` to cause the sounds to
    /// collapse into the head of the listener.
    public var reverbLevel: Audio.Decibel

    /// The radiation pattern for sound that an entity emits.
    ///
    /// - Note: You can't update the `directivity` property dynamically. Set it before you prepare or play an audio resource on an entity.
    public var directivity: Audio.Directivity

    /// Creates a spatial audio component from a gain value, a direct level, a reverb level,
    /// and a directivity value.
    ///
    /// - Parameters:
    ///   - gain: The overall level for all sounds that an entity emits.
    ///   - directLevel: The level of the direct unreverberated signal that an entity emits.
    ///   - reverbLevel: The level of reverberated signal that an entity emits.
    ///   - directivity: The radiation pattern for sound that an entity emits.
    public init(gain: Audio.Decibel = .zero, directLevel: Audio.Decibel = .zero, reverbLevel: Audio.Decibel = .zero, directivity: Audio.Directivity = .beam(focus: .zero))
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension SpatialAudioComponent : Component {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension SpatialAudioComponent : Equatable, Hashable, Codable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SpatialAudioComponent, b: SpatialAudioComponent) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension SpatialAudioComponent {

    /// Creates a spatial audio component from a gain value, a direct level, a reverb level,
    /// a directivity value, and a distance attenuation value.
    ///
    /// - Parameters:
    ///   - gain: The overall level for all sounds that an entity emits.
    ///   - directLevel: The level of the direct unreverberated signal that an entity emits.
    ///   - reverbLevel: The level of reverberated signal that an entity emits.
    ///   - directivity: The radiation pattern for sound that an entity emits.
    ///   - distanceAttenuation: The way that a sound level reduces as a listener moves away from the source.
    public init(gain: Audio.Decibel = .zero, directLevel: Audio.Decibel = .zero, reverbLevel: Audio.Decibel = .zero, directivity: Audio.Directivity = .beam(focus: .zero), distanceAttenuation: Audio.DistanceAttenuation)

    /// A value that specifies the way that the sound level decreases as the distance between the listener
    /// and the sound source increases.
    ///
    /// - Note: You can't update the `distanceAttenuation` property dynamically. Set it before you prepare or play an
    ///         audio resource on an entity.
    public var distanceAttenuation: Audio.DistanceAttenuation
}

/// A type that modulates the force strength based on the distance of rigid bodies.
///
/// Forces applied to rigid bodies near the effect's origin have the largest strength and gradually decay to zero
/// when approaching the boundary of ``ForceEffectBounds``.
///
/// ``SpatialForceFalloff/rate`` controls how fast the force strength decays. Under the hood the rate
/// is an exponent of the normalized distance over the spatial bounds. For example when the rate is 0,
/// the falloff coefficient (i.e. distance raised to the power of 0) is constantly 1, and that implies no decay or falloff the force strength.
///
///```swift
/// let noFalloff = SpatialForceFalloff(bounds: .sphere(radius: 10), rate: 0)
///```
///
/// As another example, you can set ``rate`` to `1` to decay the force strength linearly.
///
///```swift
/// let linearFalloff = SpatialForceFalloff(bounds: .sphere(radius: 10), rate: 1)
///```
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct SpatialForceFalloff {

    /// Creates a spatial force falloff.
    ///
    /// - Parameters:
    ///    - bounds: The spatial bounds used to compute the strength falloff.
    ///    - rate: The rate at which the effect's strength diminishes.
    ///    - distanceOffset: The offset from the origin where fall begins.
    ///
    /// * When the rate is **0**, no falloff occurs. (Rigid bodies outside the bounds are culled.)
    /// * When the rate is **greater than 0 and less than 1.0**, falloff occurs slower and is sublinear.
    /// * When the rate is **1.0**, falloff is linear.
    /// * When the rate is **greater than 1**, falloff occurs faster and is nonlinear.
    public init(bounds: ForceEffectBounds, rate: Double = 1.0, distanceOffset: Double = 0)

    /// A distance from the origin where the falloff begins.
    ///
    /// Use an offset value that is less than ``bounds``.
    public var distanceOffset: Double

    /// The spatial bounds that define the area over which the force effect's strength decreases.
    public var bounds: ForceEffectBounds

    /// The spatial falloff / attenuation rate.
    ///
    /// An exponent that determines how the effect's strength diminishes with distance. Use a non-negative rate.
    /// * When the rate is **0**, no falloff occurs.
    /// * When the rate is **greater than 0 and less than 1.0**, falloff occurs slower and is sublinear.
    /// * When the rate is **1.0**, falloff is linear.
    /// * When the rate is **greater than 1**, falloff occurs faster and is nonlinear.
    public var rate: Double
}

/// An object that incorporates spatial tracking capabilities into your RealityKit apps.
///
/// `SpatialTrackingSession` helps you manage spatial tracking capabilities, such as world and hand
/// tracking, in your RealityKit app.
/// You can decide which AR data you need and how you want to use them
/// by running a corresponding ``SpatialTrackingSession/Configuration``.
///
/// You can specify the following spatial tracking capabilities in a configuration:
/// - The anchoring targets you want RealityKit to track, such as planes, images, and hands.
/// - In iOS, the scene-understanding data that system behaviors have access to, such as shadows, occlusion, and physics.
/// - In iOS, the camera feed (front or back) that ``RealityViewCamera/spatialTracking`` uses.
///
/// The following is an example of how to enable the camera, implement plane anchoring, use scene-understanding data for shadow and occlusion,
/// and use the back camera in iOS:
///
/// ```swift
/// let configuration = SpatialTrackingSession.Configuration(
///     tracking: [.camera, .plane],
///     sceneUnderstanding: [.shadow, .occlusion],
///     camera: .back)
/// let session = SpatialTrackingSession()
/// await session.run(configuration)
/// ```
///
/// `SpatialTrackingSession` configures ARKit for you based on the configuration you pass in.
/// It also checks whether a device supports certain requested capabilities, and requests user
/// authorizations if needed.
///
/// As an asynchronous function call, ``SpatialTrackingSession/run(_:)`` returns an optional ``SpatialTrackingSession/UnavailableCapabilities``,
/// which contains both unsupported capabilities and unauthorized capabilities.
/// This can help you to handle errors gracefully, such as informing someone to
/// turn on the relevant permissions or reduce the feature set.
/// Here's an example in iOS:
///
///```swift
/// let configuration = SpatialTrackingSession.Configuration(
///     tracking: [.camera, .plane],
///     sceneUnderstanding: [.shadow, .occlusion],
///     camera: .back)
/// let session = SpatialTrackingSession()
/// if let unavailableCapabilities = await session.run(configuration) {
///     if unavailableCapabilities.missingCameraAuthorization {
///         print("Camera access requires user permission.")
///         return
///     }
///     if unavailableCapabilities.anchor.contains(.plane) {
///         print("The device doesn't support plane tracking.")
///     }
///     if !unavailableCapabilities.sceneUnderstanding.isEmpty {
///         print("The device doesn't support scene understanding.")
///     }
/// }
/// ```
///
/// After running `SpatialTrackingSession`, RealityKit apps start using the AR data in the following ways:
/// - Anchor tracking starts to work for the chosen capabilities as follows:
///   - In visionOS, you can access the transform information of the entities with ``AnchoringComponent``.
///   - In iOS, entities with ``AnchoringComponent`` start to get the real-world anchors to anchor onto.
/// - System behavior starts to use scene-understanding data. In the example above, virtual contents start to cast shadows onto real-world meshes, and experience occlusion from those meshes.
/// - Setting ``RealityViewCameraContent/camera`` to `.spatialTracking` starts to show the configured camera feed as a ``RealityView`` background.
///
/// To modify the configuration, run `SpatialTrackingSession` again with the new configuration.
/// To stop `SpatialTrackingSession`, you can call ``SpatialTrackingSession/stop()``.
///
/// - Note: RealityKit stops `SpatialTrackingSession` automatically when it goes out of scope
/// and deinitializes.
///
/// ### Other methods for incorporating AR content in your apps
///
/// Although `SpatialTrackingSession` offers you an easy way to configure AR capabilities in your app,
/// there are other options available.
///
/// #### Use the default spatial tracking session
///
/// In iOS, if you don't set up `SpatialTrackingSession` manually, RealityKit runs the default session
/// with the following configuration:
///
/// ```swift
/// SpatialTrackingSession.Configuration(
///     tracking: [.camera, .world, .plane, .object, .image, .face],
///     sceneUnderstanding: [.occlusion, .shadow, .collision, .physics],
///     camera: .back)
/// ```
///
/// #### Use an anchor entity alone in visionOS
///
/// In visionOS, if you don't set up `SpatialTrackingSession` manually, the system anchors your
/// ``AnchorEntity`` in a privacy-preserving manner.
/// In other words, the app doesn't get read access to any transform information from the `AnchorEntity`.
///
/// When you set up `SpatialTrackingSession`, the app requests authorization, giving it the ability
/// to read transform information if it has permission.
///
/// #### Use an ARKit session for tracking
///
/// You can set up an ARKit session manually and receive an anchor transform directly from ARKit by
/// subscribing to the ARKit updates. You can then set the transform of your entities manually.
/// This gives you full access to the anchor properties, but requires more setup on your part.
/// With `SpatialTrackingSession`, RealityKit handles that for you and maintains your `AnchorEntity`
/// alignment to the target anchor.
/// In iOS, you manage and run the ARKit session if you run `SpatialTrackingSession` with ``SpatialTrackingSession/run(_:session:arConfiguration:)``.
@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
final public class SpatialTrackingSession : Sendable {

    /// A type for configuring the spatial tracking session.
    public struct Configuration {

        /// A type that defines various anchor tracking capabilities.
        public struct AnchorCapability : Equatable, Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: SpatialTrackingSession.Configuration.AnchorCapability, b: SpatialTrackingSession.Configuration.AnchorCapability) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }
    }

    /// A type that contains the unavailable capabilities of the current spatial tracking session.
    public struct UnavailableCapabilities : Sendable {

        /// Creates an unavailable capabilities instance.
        public init()
    }

    /// Creates a spatial tracking session with default settings.
    public init()
}

@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension SpatialTrackingSession {

    /// Runs the spatial tracking session with the specified configuration.
    /// - Parameter spatialTrackingConfiguration: An object that configures the AR data that RealityKit uses in the spatial tracking session.
    /// - Returns: The unavailable capabilities based on the hardware and the user authorization.
    @discardableResult
    final public func run(_ spatialTrackingConfiguration: SpatialTrackingSession.Configuration) async -> SpatialTrackingSession.UnavailableCapabilities?

    /// Stops the current spatial tracking session.
    final public func stop() async
}

@available(visionOS 2.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
@available(iOS, unavailable)
extension SpatialTrackingSession.Configuration {

    /// Creates a configuration with a set of anchor capabilities.
    /// - Parameter capabilities: The set of anchor capabilities
    ///   to run with a ``SpatialTrackingSession``.
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(macCatalyst, unavailable)
    @available(iOS, unavailable)
    public init(tracking capabilities: Set<SpatialTrackingSession.Configuration.AnchorCapability>)
}

@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension SpatialTrackingSession.Configuration : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A human-readable description of the configuration.
    public var debugDescription: String { get }
}

@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension SpatialTrackingSession.UnavailableCapabilities {

    /// A type that contains all unavailable anchor capabilities.
    ///
    /// The system marks certain anchor capabilities as unavailable if:
    /// - The device running your app doesn't support them.
    /// - The person using the device doesn't approve the corresponding ARKit authorization.
    public var anchor: Set<SpatialTrackingSession.Configuration.AnchorCapability> { get }
}

@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension SpatialTrackingSession.Configuration.AnchorCapability {

    /// The anchor capability that enables world tracking.
    public static let world: SpatialTrackingSession.Configuration.AnchorCapability

    /// The anchor capability that enables plane detection.
    public static let plane: SpatialTrackingSession.Configuration.AnchorCapability

    /// The anchor capability that enables image tracking.
    public static let image: SpatialTrackingSession.Configuration.AnchorCapability

    /// The anchor capability that enables object tracking.
    public static let object: SpatialTrackingSession.Configuration.AnchorCapability
}

@available(visionOS 2.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
@available(iOS, unavailable)
extension SpatialTrackingSession.Configuration.AnchorCapability {

    /// The anchor capability that enables hand tracking.
    public static let hand: SpatialTrackingSession.Configuration.AnchorCapability
}

@available(visionOS 2.0, iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension SpatialTrackingSession.Configuration.AnchorCapability : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A human-readable description of the anchor capability.
    public var debugDescription: String { get }
}

/// An action which animates the transform of an entity to rotate around a specified local axis.
///
/// This action rotates an entity around itself from a specified ``SpinAction/localAxis``
/// gradually adjusting its local transform.
/// The ``SpinAction/localAxis`` specifies which cartesian axis around which to rotate in
/// local space.
/// The full spin completes after the action has ended.
///
/// The example below creates an animation that spins an entity
/// around the x-axis two times for five seconds with a linear transition.
///
/// ```swift
/// // Create an action that performs a spin around the specified local axis
/// // with a linear transition.
/// let spinAction = SpinAction(revolutions: 2,
///                             localAxis: [1, 0, 0],
///                             timingFunction: .linear,
///                             isAdditive: false)
///
/// // A five second animation that plays an animation causing the entity to
/// // spin around a specified local axis.
/// let spinAnimation = try AnimationResource
///     .makeActionAnimation(for: spinAction,
///                          duration: 5.0,
///                          bindTarget: .transform)
///
/// // Play the five second spin animation.
/// entity.playAnimation(spinAnimation)
/// ```
///
///  - Note: Use the ``SpinAction/localAxis`` to determine whether the entity
///          spins clockwise or counterclockwise.
///
/// - Important: This action directly animates the ``BindTarget/transform`` on the bound entity.
///              Ensure a correct bind target is supplied when creating the animation.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct SpinAction : EntityAction, Codable {

    /// The number of rotations to complete before stopping.
    public var revolutions: Float

    /// A vector that describes the axis of rotation (in local space).
    ///
    /// The default value of this property is `[0, 1, 0]`, meaning the rotation
    /// occurs around the y-axis.
    public var localAxis: SIMD3<Float>

    /// A timing function that controls the progress of the animation.
    ///
    /// The default value of this property is ``AnimationTimingFunction/default``.
    /// This produces an ease transition.
    public var timingFunction: AnimationTimingFunction

    /// A Boolean value that indicates whether the animation system additively blends the action's output with the base value.
    public var isAdditive: Bool

    /// The type for the value that the action modifies over time.
    ///
    /// Set to `nil` for an action that doesn't modify a value.
    public var animatedValueType: (any AnimatableData.Type)? { get }

    /// Creates a new spin action.
    ///
    /// - Parameters:
    ///   - revolutions: The number of rotations to complete before stopping.
    ///   - localAxis: A vector that describes the axis of rotation (in local space).
    ///   - timingFunction: A timing function that controls the progress of the animation.
    ///   - isAdditive: A Boolean value that indicates whether the animation system additively blends 
    ///                 the action's output with the base value.
    public init(revolutions: Float, localAxis: SIMD3<Float> = [0, 1, 0], timingFunction: AnimationTimingFunction = .default, isAdditive: Bool = false)

    /// The associated event parameter type. 
    ///
    /// Event parameters are used when more than one event interval is defined for a single action animation.
    /// Event parameters can vary for each event interval. The parameter data associated with each event will be returned
    /// to the event handler when it is called.
    ///
    /// The default parameter type is `Never` so that it does not need to be defined for single event action animations.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias EventParameterType = Never

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// An entity that illuminates virtual content in a cone-shaped volume.
///
/// During an AR session, RealityKit automatically lights your virtual objects
/// to match real-world lighting.
/// You can also explicitly add virtual lights that act upon your virtual content.
/// This is typically most useful outside of an AR session on iOS or macOS,
/// where your ``RealityViewCameraContent`` ``RealityViewCameraContent/camera``
/// property is set to ``RealityViewCamera/virtual``.
///
/// A RealityKit scene can contain up to eight dynamic lights, which are
/// entities that contain a
/// ``SpotLightComponent``, ``PointLightComponent``, or a ``DirectionalLightComponent``.
/// This limit doesn’t include light from image-based lighting.
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
@MainActor @preconcurrency public class SpotLight : Entity, HasSpotLight {

    /// Creates a new entity.
    @MainActor @preconcurrency required public init()
}

/// A component that defines a spotlight source.
///
/// A spotlight illuminates a cone-shaped volume in the entity's local forward direction
/// along the z-axis's negative direction, or `[0.0, 0.0, -1.0]`.
/// Change the a spotlight's direction with the ``Entity/orientation`` or
/// ``HasTransform/look(at:from:upVector:relativeTo:)`` method,
/// of the ``Entity`` with a spotlight component.
///
/// The light's ``innerAngleInDegrees`` and ``outerAngleInDegrees``
/// reflect the size of the light's cone relative to the entity's forward direction.
/// The light is at full intensity between `0` degrees and ``innerAngleInDegrees``.
/// RealityKit attenuates the light's intensity between the inner angle and the outer angle.
/// The spotlight's intensity is `0.0` beyond the outer angle.
///
/// - Tip: Turn on shadows for a spotlight by adding the ``Shadow`` component
///   to an entity that has a `SpotLightComponent`.
///
/// The following table shows some real-world scenarios, to better explain how
/// you can use ``intensity`` to control the brightness of the light in lumens,
/// and ``attenuationRadius`` to control how the level of brightness
/// diminishes with distance from the light source:
///
/// | Scenario | Approximate Lumens | Attenuation Radius | Description |
/// |-|-|-|-|
/// | Small Accent Spotlight | 100-200 lumens | 5-10 meters | Highlights small objects or artwork |
/// | LED flashlight | 300-600 lumens | 50-70 meters | Beams a long distance illumination |
/// | Theatrical Spotlight | 500-1,000 lumens | 20-40 meters | Focuses attention to performers on a stage |
/// | Outdoor Security Spotlight | 1,000-2,000 lumens | 20-30 meters | Brightly illuminates specific outdoor areas |
/// | Film/TV Production Spotlight | 5,000-10,000 lumens | 50-100 meters | Provides focused, high-intensity lighting for sets |
/// | Large-Scale Event Spotlight | 50,000-100,000 lumens | 200-500 meters | Lights large outdoor events or concerts |
@available(macOS 10.15, iOS 13.0, visionOS 2.0, *)
public struct SpotLightComponent : Component, Equatable {

    /// A spotlight component that adds shadows to entities that it illuminates.
    public struct Shadow : Component, Equatable {

        /// Creates a new spot light shadow object.
        public init()

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SpotLightComponent.Shadow, b: SpotLightComponent.Shadow) -> Bool
    }

    /// The intensity of the spotlight measured in lumen.
    ///
    /// The default value is `6740.94` lumens.
    ///
    /// For more information on how the `intensity` and ``attenuationRadius``
    /// affect this light, see  ``SpotLightComponent``.
    public var intensity: Float

    /// The inner angle of the spotlight in degrees.
    ///
    /// The default value is `45.0` degrees.
    public var innerAngleInDegrees: Float

    /// The outer angle of the spotlight in degrees.
    ///
    /// The default value is `60.0` degrees.
    public var outerAngleInDegrees: Float

    /// The distance from the light source where its intensity reaches zero.
    ///
    /// Any objects at or beyond this distance do not receive illumination.
    /// The default value is `10.0` meters.
    ///
    /// See ``SpotLightComponent`` for more information about how the
    /// ``intensity`` and `attenuationRadius` properties affect this light.
    public var attenuationRadius: Float

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SpotLightComponent, b: SpotLightComponent) -> Bool
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension SpotLightComponent {

    /// The exponent value for the light's intensity falloff-transition curve.
    public var attenuationFalloffExponent: Float
}

@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
extension SpotLightComponent.Shadow {

    public typealias ShadowMapCullMode = MaterialParameterTypes.FaceCulling

    /// A constant value that RealityKit applies as a bias to its shadow calculations.
    ///
    /// Reduce visual effects such as _shadow acne_, by adjusting this property.
    /// The default value is `1.0`.
    public var depthBias: Float

    /// The light's culling mode for shadow map rendering.
    public var cullModeOverride: SpotLightComponent.Shadow.ShadowMapCullMode?

    /// An object that specifies the mode of a shadow clipping plane.
    public enum ShadowClippingPlane : Equatable {

        /// The spotlight component automatically sets the position of the shadow clipping plane.
        case automatic

        /// The shadow clipping plane's position doesn't change.
        case fixed(Float)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SpotLightComponent.Shadow.ShadowClippingPlane, b: SpotLightComponent.Shadow.ShadowClippingPlane) -> Bool
    }

    /// The near-plane of a shadow frustum.
    ///
    /// The `zNear` is the minimum distance between the light
    /// and a visible surface for casting shadows.
    /// The default value for `zNear` is ``ShadowClippingPlane/automatic``.
    public var zNear: SpotLightComponent.Shadow.ShadowClippingPlane

    /// The orthogonal plane of the shadow frustum that's furthest from the spotlight.
    ///
    /// The `zFar` is the maximum distance between the light
    /// and a visible surface for casting shadows.
    ///
    /// The spotlight applies the value from ``SpotLightComponent/attenuationRadius``,
    /// when you set this property to ``ShadowClippingPlane/automatic``,
    /// which is its default value.
    /// Setting this value to ``ShadowClippingPlane/fixed(_:)``
    /// is equivalent to assigning it to `min(zFar, attenuationRadius)`.
    public var zFar: SpotLightComponent.Shadow.ShadowClippingPlane
}

/// A component that synchronizes an entity between processes and networked
/// applications.
///
/// An entity acquires a ``SynchronizationComponent`` instance by adopting the
/// ``HasSynchronization`` protocol. All entities have this component because
/// the ``Entity`` base class adopts the protocol.
@available(macOS 10.15, iOS 13.0, *)
public struct SynchronizationComponent : Component, Equatable {

    /// Modes of ownership transfer.
    public enum OwnershipTransferMode {

        /// Grant ownership requests automatically.
        case autoAccept

        /// Require explicit ownership request confirmation.
        ///
        /// Handle the ``SynchronizationEvents/OwnershipRequest`` event to find
        /// out when a peer requests ownership of an entity, and call the method
        /// stored in the requests’s
        /// ``SynchronizationEvents/OwnershipRequest/accept`` property to
        /// confirm the transfer of ownership.
        case manual

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SynchronizationComponent.OwnershipTransferMode, b: SynchronizationComponent.OwnershipTransferMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The result of an ownership transfer request.
    public enum OwnershipTransferCompletionResult {

        /// The request is accepted and ownership is transferred.
        case granted

        /// The ownership transfer request timed out.
        ///
        /// A timeout doesn’t necessarily mean that the request is denied. It
        /// might succeed after the timeout.
        case timedOut

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SynchronizationComponent.OwnershipTransferCompletionResult, b: SynchronizationComponent.OwnershipTransferCompletionResult) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A unique identifier of an entity within a network session.
    public var identifier: UInt64 { get }

    /// A Boolean that indicates whether the calling process owns the entity.
    public var isOwner: Bool { get }

    /// The entity’s transfer ownership mode.
    ///
    /// By default, the transfer mode is
    /// ``SynchronizationComponent/OwnershipTransferMode-swift.enum/autoAccept``.
    /// You can set it to
    /// ``SynchronizationComponent/OwnershipTransferMode-swift.enum/manual`` to
    /// require explicit confirmation of the request by your app.
    public var ownershipTransferMode: SynchronizationComponent.OwnershipTransferMode

    /// Creates a synchronization component.
    public init()

    /// Indicates whether two synchronization components are equal.
    ///
    /// - Parameters:
    ///   - lhs: The first synchronization component to compare.
    ///
    ///   - rhs: The second synchronization component to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two synchronization
    /// components are equal.
    public static func == (lhs: SynchronizationComponent, rhs: SynchronizationComponent) -> Bool
}

@available(macOS 10.15, iOS 13.0, *)
extension SynchronizationComponent.OwnershipTransferMode : Equatable {
}

@available(macOS 10.15, iOS 13.0, *)
extension SynchronizationComponent.OwnershipTransferMode : Hashable {
}

@available(macOS 10.15, iOS 13.0, *)
extension SynchronizationComponent.OwnershipTransferCompletionResult : Equatable {
}

@available(macOS 10.15, iOS 13.0, *)
extension SynchronizationComponent.OwnershipTransferCompletionResult : Hashable {
}

/// Events associated with network synchronization of scene information.
///
/// For more information on subscribing to scene events, see ``RealityKit/Scene/Event``.
@available(macOS 10.15, iOS 13.0, *)
public enum SynchronizationEvents {

    /// The event raised when a network peer wants to gain ownership of an
    /// entity.
    public struct OwnershipRequest : Event {

        /// The entity over which the network peer would like to gain ownership.
        public let entity: Entity

        /// The network peer requesting ownership.
        public let requester: any SynchronizationPeerID

        /// The callback function that the current owner calls to grant
        /// ownership to the requesting peer.
        ///
        /// If an entity’s
        /// ``SynchronizationComponent/ownershipTransferMode-swift.property``
        /// property is set to
        /// ``SynchronizationComponent/OwnershipTransferMode-swift.enum/autoAccept``,
        /// the entity automatically grants ownership to any other entity that
        /// requests it.
        ///
        /// In case you configure an entity to have a transfer mode of
        /// ``SynchronizationComponent/OwnershipTransferMode-swift.enum/manual``,
        /// then when you receive an ``SynchronizationEvents/OwnershipRequest``
        /// event, call the
        /// ``SynchronizationEvents/OwnershipRequest/accept`` method to complete
        /// the transfer of ownership.
        public let accept: () -> Void
    }

    /// The event raised when ownership of an entity changes.
    public struct OwnershipChanged : Event {

        /// The entity for which ownership is changed.
        public let entity: Entity

        /// The new owner of the entity.
        public let newOwner: (any SynchronizationPeerID)?
    }
}

/// A type that represents a peer among a group of networked devices.
@available(macOS 10.15, iOS 13.0, *)
public protocol SynchronizationPeerID {
}

/// An interface that enables entity synchronization among a group of local
/// peers.
@available(macOS 10.15, iOS 13.0, *)
public protocol SynchronizationService : AnyObject {

    /// A type that represents a synchronization service identifier.
    typealias Identifier = UInt64

    /// Gets the entity with the given identifier.
    ///
    /// - Parameters:
    ///   - identifier: The identifier.
    ///
    /// - Returns: The entity with the corresponding identifier.
    @MainActor @preconcurrency func entity(for identifier: Self.Identifier) -> Entity?

    /// Gets the device that owns a given entity, if any.
    ///
    /// - Parameters:
    ///   - entity: The entity for which you want the owner.
    ///
    /// - Returns: The networked device that owns the entity. The value is `nil`
    /// if the entity isn’t synchronized or is owned locally.
    @MainActor @preconcurrency func owner(of entity: Entity) -> (any SynchronizationPeerID)?

    /// Transfers ownership of the given entity to the named network device.
    ///
    /// - Parameters:
    ///   - entity: The entity whose ownership is transferred.
    ///
    ///   - toPeer: The networked device receiving ownership.
    ///
    /// - Returns: A Boolean that’s `true` if the ownership transfer succeeds.
    @discardableResult
    @MainActor @preconcurrency func giveOwnership(of entity: Entity, toPeer: any SynchronizationPeerID) -> Bool
}

/// An object that affects multiple entities in every update of a RealityKit
/// scene.
///
/// In RealityKit’s Entity Component System (ECS), a _system_ represents
/// continuous behavior that affects multiple entities in the scene. Use systems
/// to implement any behavior or logic that updates entities every scene update,
/// such as different types of objects or characters.
/// For example, a physics simulation system calculates and applies the affect of
/// gravity, forces, and collisions for all entities.
/// A system calls the ``update(context:)-69f86`` method as
/// often as the `updatingSystemWhen` parameter of
/// ``SceneUpdateContext/entities(matching:updatingSystemWhen:)``
/// defines.
///
/// Systems often work with components.
/// You might, for example, create a system that calculates the hunger levels
/// for entities in a game capable of feeling hunger.
/// To identify which entities experience hunger, use a component that
/// stores hunger-related state data and add it to the selected entities.
/// The hunger system then iterates through all entities that contain
/// a hunger component and updates their state based on relevant factors,
/// such as when the entity last ate or how much energy it expends.
///
/// A complex game or experience may consist of many systems which need to be executed
/// in a specific order. The ``dependencies-2s31o`` property  defines when
/// the `update` method for each system is called each frame.
/// Update order is defined between system types and not between individual system instances.
///
/// Systems and their dependencies form a directed acyclic graph (DAG).
/// Custom systems are executed in dependency order.
/// Systems without dependencies are updated in the order they were registered.
/// If there are conflicting dependencies or cycles, then RealityKit ignores
/// some conflicting dependencies and logs a warning.
/// Each system instance is only run once per simulation step.
///
/// Properties of a system are never serialized to a file or synced over the network.
/// Therefore, store data on entities using components, rather than as part of the system.
///
/// For more information, see
/// <doc:implementing-systems-for-entities-in-a-scene>.
@available(macOS 12.0, iOS 15.0, *)
public protocol System {

    /// An array of dependencies for this system.
    ///
    /// If you need to specify the update order between your system and other
    /// systems in your app, you can do that using this property.
    /// If your system has no dependencies, you don’t need to declare this property.
    /// RealityKit provides a default implementation for systems with no dependencies.
    ///
    /// Here’s an example where one other system updates before this system,
    /// and another system updates after it.
    ///
    /// ```swift
    /// class SystemB : RealityKit.System {
    ///     static var dependencies: [SystemDependency] {
    ///         [.after(SystemA.self),        // Run SystemB after SystemA.
    ///          .before(SystemC.self)]       // Run SystemB before SystemC.
    ///      }
    ///     // ...
    /// }
    /// ```
    ///
    /// When the app runs, RealityKit calls ``System/update(context:)-69f86`` on
    /// `SystemA` first, then on `SystemB`, and then on `SystemC`.
    static var dependencies: [SystemDependency] { get }

    /// Creates a new system.
    ///
    /// There’s no need to instantiate your own systems, so don’t call this method.
    /// Instead, register your system with RealityKit by calling
    /// ``System/registerSystem()``.
    /// RealityKit automatically creates an instance of every
    /// registered system for every scene.
    ///
    /// - Parameters:
    ///   - scene: The scene this system affects.
    @MainActor @preconcurrency init(scene: Scene)

    /// Updates entities up to once every scene update.
    ///
    /// RealityKit calls this method on all registered systems,
    /// as often as the `updatingSystemWhen` parameter of
    /// ``SceneUpdateContext/entities(matching:updatingSystemWhen:)``
    /// defines.
    ///
    ///
    /// The `context` parameter contains a reference to the scene
    /// that the ``System`` is updating, along with the elapsed time
    /// since RealityKit last called the update method for the same scene.
    /// Use ``SceneUpdateContext/entities(matching:updatingSystemWhen:)``
    /// inside this method for the most optimized way to find the matching entities
    /// for this ``System``.
    ///
    /// - Parameters:
    ///   - context: The scene context for the scene to update.
    @MainActor @preconcurrency mutating func update(context: SceneUpdateContext)
}

extension System {

    /// Registers a system with RealityKit.
    ///
    /// Calling this method informs RealityKit of a system of defined behavior
    /// for its scenes. RealityKit automatically creates an instance of all
    /// registered systems for every scene and calls every registered system’s
    /// ``System/update(context:)-3d0qz`` method on every scene update.
    ///
    /// If you call ``System/registerSystem()`` multiple times, RealityKit
    /// ignores additional calls after the first.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public static func registerSystem()

    /// A default implementation of the dependencies array.
    ///
    /// RealityKit provides a default implementation of this property which
    /// returns an empty array. If a class that conforms to ``System`` has no
    /// dependencies, it doesn’t need to implement this property.
    @available(macOS 12.0, iOS 15.0, *)
    public static var dependencies: [SystemDependency] { get }

    /// A default implementation that does nothing.
    ///
    /// - Parameters:
    ///   - context: The scene context for the scene to update.
    @available(macOS 12.0, iOS 15.0, *)
    public mutating func update(context: SceneUpdateContext)
}

/// Defines update order relative to other systems.
/// An object that specifies the update order between multiple systems.
///
/// Add instances of `SystemDependency` to your system’s
/// ``System/dependencies-2s31o`` array to indicate whether RealityKit updates
/// another specified system before or after this system.
@available(macOS 12.0, iOS 15.0, *)
public enum SystemDependency : Equatable {

    /// An update order that requests RealityKit update this system before it
    /// updates another specified system.
    ///
    /// - Parameters:
    ///   - System: A system that this system updates before.
    case before(any System.Type)

    /// An update order that requests RealityKit update this system after it
    /// updates another specified system.
    ///
    /// - Parameters:
    ///   - System: A system that this system updates after.
    case after(any System.Type)

    /// Returns a Boolean value that indicates whether two dependencies are
    /// equal.
    ///
    /// - Parameters:
    ///   - lhs: The first dependency to compare.
    ///
    ///   - rhs: The second dependency to compare.
    ///
    /// - Returns: A Boolean value set to `true` if the two dependencies are
    /// equal.
    public static func == (lhs: SystemDependency, rhs: SystemDependency) -> Bool
}

/// A condition which causes a system to update.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct SystemUpdateCondition {

    /// A condition that is active whenever an update for rendering may be needed,
    /// usually matching the refresh rate of the display.
    public static var rendering: SystemUpdateCondition { get }
}

/// A component that draws 2D text at an entity's location.
///
/// `TextComponent` renders two-dimensional text in a RealityKit scene.
/// It creates a rounded rectangle mesh to serve as a canvas and draws an attributed string on the mesh. This component handles
/// everything required to render the text, including updating the plane transform, setting material parameters, and creating mesh components.
///
/// Set the component's ``size`` to define the area of the canvas in points. This setting also affects the size at which RealityKit
/// renders the text. The world-size of the canvas may be different than the value you specify because the component's entity inherits its
/// parent's transform, which may include scale changes that affect the final rendered size.
///
/// Text components use the CoreGraphics coordinate space: The origin is at the upper left of the canvas and positive
/// values extend down and to the right. You can't specify an explicit backing-buffer size. RealityKit dynamically adjusts
/// the backing size to a value that results in high-fidelity text at its current location.
///
/// RealityKit lays out text using default ``Foundation/AttributedString`` behaviors and wraps text instead of
/// truncating it. It keeps the text a constant font size: It doesn't stretch or scale the text to fit tha canvas. Use
/// Core Text to determine the required canvas size for a particular string or layout.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct TextComponent : Component {

    /// The size of the canvas in points.
    ///
    /// This defines both how large the canvas is for text layout, as well as how large it is in world-space. The
    /// canvas coordinate system uses the standard CoreGraphics / CoreText coordinate space. There is no
    /// explicit backing-buffer size, as it might be dynamic to generate high-fidelity text. The canvas size uses
    /// points as 1/72nd of an inch (about 0.352 mm) in world-space. World-size might change as a function of
    /// any peer or parent transform component.
    ///
    /// This component lays out text using default `AttributedString` behaviors, but respecting
    /// the `edgeInsets` property. Text will wrap-around, rather than truncate. It will stay at the
    /// given fixed font size, and will not stretch or scale to fit.  CoreText can determine the
    /// required canvas size for a particular string or layout. The canvas size is clamped to a maximum
    /// of 2048 points in width and height.
    public var size: CGSize

    /// The attributed string this component renders.
    ///
    /// RealityKit renders text centered vertically. Neither the length of the string nor the specified attributes affect
    /// the size of the canvas mesh.
    public var text: AttributedString?

    /// The canvas's background color.
    ///
    /// Specify a color to have RealityKit render the entire canvas in a color. The specified value may include an alpha component.
    /// By default, the canvas is transparent.
    public var backgroundColor: CGColor?

    /// The corner radius of the text mesh.
    ///
    /// The corner geometry is based on a circular shape and is not a continuous corner. Text components use the CoreGraphics
    /// coordinate space: The origin is at the upper left of the canvas and positive values extend down and to the right.
    public var cornerRadius: Float

    /// Creates a new text component.
    public init()
}

/// A representation of a texture.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class TextureResource : Resource {

    /// An object used to specify the intended usage of a texture.
    ///
    /// RealityKit uses image textures to transmit different types of data Metal
    /// shaders. For example, it uses textures to send RGB images with the base
    /// color of the entity, to send grayscale images holding roughness and
    /// metallic information, and to send surface normals for doing lighting
    /// calculations.
    ///
    /// This object specifies the intended use of the texture by an individual
    /// property.
    @available(macOS 12.0, iOS 15.0, *)
    public enum Semantic {

        /// Use the texture unmodified.
        ///
        /// For texture properties that use the `raw` semantic, the number of
        /// channels and values is the same as the source image. If the source
        /// image contains color space information, RealityKit ignores it. For
        /// `raw` textures, each individual pixel contains one floating-point
        /// value between `0.0` and `1.0` for each channel in the source image.
        /// For example, a grayscale source image results in a texture that
        /// contains one value per pixel, and an RGB source image results in
        /// three values per pixel.
        case raw

        /// Use the texture to store a single value in each pixel.
        ///
        /// Properties that specify a semantic of `scalar` use the texture to
        /// store a single floating point value in each pixel. If the texture’s
        /// source is an RGB image, the property uses only the red channel
        /// value.
        case scalar

        /// Use the texture to store colors data.
        ///
        /// Properties that specify a semantic of `color` use the RGB color data
        /// from the texture. If the source image contains color space
        /// information, RealityKit modifies the individual pixels to fit the
        /// color space. If the source image is grayscale, RealityKit converts
        /// it to an RGB image first.
        case color

        /// Use the texture to store a high-dynamic range image.
        ///
        /// Properties that specify a semantic of `hdrColor` use the texture to
        /// store high-dynamic range RGB color data. If the source image
        /// contains color space information, RealityKit modifies the individual
        /// pixels to fit the color space. If the source image is grayscale,
        /// RealityKit converts it to an RGB image first.
        case hdrColor

        /// Use the texture to store surface normals.
        ///
        /// Properties that specify a semantic of `normal` use the texture to
        /// store tangent-space surface normal vectors for use in lighting
        /// calculations. Each pixel’s `R` channel stores the `X` value from the
        /// vector. The `G` channel stores the `Y` value from the vector, and
        /// the `B` channel stores the `Z` value from the vector. All values are
        /// between `-1.0` and `1.0`.
        case normal

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: TextureResource.Semantic, b: TextureResource.Semantic) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An enumeration used to specify how mipmaps are allocated and generated
    /// for this texture.
    @available(macOS 12.0, iOS 15.0, *)
    public enum MipmapsMode {

        /// Do not allocate mipmaps for the texture resource.
        case none

        /// Allocate memory for all mipmaps, but don’t generate them.
        case allocateAll

        /// Allocate and generate all mipmaps for the texture resource.
        case allocateAndGenerateAll

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: TextureResource.MipmapsMode, b: TextureResource.MipmapsMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An object that holds texture resource creation options.
    @available(macOS 12.0, iOS 15.0, *)
    public struct CreateOptions {

        /// The intended use of the texture.
        public var semantic: TextureResource.Semantic?

        /// Whether the texture resource automatically generates mipmaps.
        public var mipmapsMode: TextureResource.MipmapsMode

        @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
        public var compression: TextureResource.Compression

        /// Creates a new texture creation options structure.
        ///
        /// The `semantic` value you pass tells RealityKit how you plan to use the texture data from this resource. For example, passing
        ///    ``RealityKit/TextureResource/Semantic-swift.enum/color`` lets RealityKit know you're
        ///    using the texture to pass perceptual color information to the shaders, such as for providing a UV-mapped base color for physically
        ///    based rendering materials. Passing ``RealityKit/TextureResource/Semantic-swift.enum/raw`` tells RealityKit to pass the pixel
        ///    values with as little processing as possible.
        ///
        /// If semantic is `nil`, RealityKit tries to infer a semantic from the texture's source data. If it's unable to determine a semantic from the texture source
        ///    data, it will infer a semantic from the texture's usage. Providing a value for `semantic` ensures that RealityKit passes the texture resource exactly as you intend.
        ///
        /// - Note: RealityKit only takes embedded color space data into account when rendering a texture if you pass
        ///   ``RealityKit/TextureResource/Semantic-swift.enum/color`` for `semantic`.
        ///
        /// - Parameters:
        ///   - semantic: The intended use of the texture resource.
        ///   - mipmapsMode: Whether to automatically allocate or generate mipmaps.
        public init(semantic: TextureResource.Semantic?, mipmapsMode: TextureResource.MipmapsMode = .allocateAndGenerateAll)

        /// Creates a new texture creation options structure.
        ///
        /// The `semantic` value you pass tells RealityKit how you plan to use the texture data from this resource. For example, passing
        ///    ``RealityKit/TextureResource/Semantic-swift.enum/color`` lets RealityKit know you're
        ///    using the texture to pass perceptual color information to the shaders, such as for providing a UV-mapped base color for physically
        ///    based rendering materials. Passing ``RealityKit/TextureResource/Semantic-swift.enum/raw`` tells RealityKit to pass the pixel
        ///    values with as little processing as possible.
        ///
        /// If semantic is `nil`, RealityKit tries to infer a semantic from the texture's source data. If it's unable to determine a semantic from the texture source
        ///    data, it will infer a semantic from the texture's usage. Providing a value for `semantic` ensures that RealityKit passes the texture resource exactly as you intend.
        ///
        /// - Note: RealityKit only takes embedded color space data into account when rendering a texture if you pass
        ///   ``RealityKit/TextureResource/Semantic-swift.enum/color`` for `semantic`.
        ///
        /// - Parameters:
        ///   - semantic: The intended use of the texture resource.
        ///   - mipmapsMode: Whether to automatically allocate or generate mipmaps.
        ///   - compression:Compression to be applied to the texture.
        @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
        public init(semantic: TextureResource.Semantic?, compression: TextureResource.Compression, mipmapsMode: TextureResource.MipmapsMode = .allocateAndGenerateAll)
    }

    /// The intended usage of the texture resource.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public var semantic: TextureResource.Semantic? { get }

    /// The width of the texture image in pixels.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public var width: Int { get }

    /// The height of the texture image in pixels.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public var height: Int { get }

    /// The depth of the texture image in pixels.
    ///
    /// The value is `0` if the texture is not a 3D texture.
    @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public var depth: Int { get }

    /// The number of mipmaps contained in this texture.
    ///
    /// Mipmaps are additional copies of the same texture at different
    /// resolutions. This property contains the number of different versions of
    /// this texture, including the original-size version.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public var mipmapLevelCount: Int { get }

    /// The texture's pixel format.
    @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public var pixelFormat: MTLPixelFormat { get }

    /// The dimension and arrangement of the texture image data.
    @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public var textureType: MTLTextureType { get }

    /// The number of slices in the texture array.
    ///
    /// The value is `0` if it is not a texture array.
    @available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
    @MainActor @preconcurrency public var arrayLength: Int { get }

    /// Synchronously loads a texture resource from a URL.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// This method loads the image specified by `URL` and creates a texture
    /// resource from it. The method blocks until it has loaded the image and
    /// created the texture resource. RealityKit uses the resource name to
    /// distinguish resources locally, and to match texture resources between networked
    /// peers. Specify a unique name for each texture resource you load or
    /// generate.
    ///
    /// - Parameters:
    ///   - url: The path or address of the file to load.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    /// - Returns: The loaded resource.
    @available(*, noasync, message: "Synchronous loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func load(contentsOf url: URL, withName resourceName: String? = nil) throws -> TextureResource

    /// Asynchronously loads a texture resource from a URL.
    ///
    /// RealityKit uses the resource name to distinguish resources locally, and to match
    /// texture resources between networked peers. Specify a unique name for
    /// each texture resource you load or generate.
    ///
    /// - Parameters:
    ///   - url: The path or address of the file to load.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    /// - Returns: A load operation that publishes the resource.
    @available(macOS, introduced: 10.15, deprecated: 15.0, renamed: "init(contentsOf:withName:)")
    @available(iOS, introduced: 13.0, deprecated: 18.0, renamed: "init(contentsOf:withName:)")
    @available(macCatalyst, introduced: 13.0, deprecated: 18.0, renamed: "init(contentsOf:withName:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "init(contentsOf:withName:)")
    @MainActor @preconcurrency public static func loadAsync(contentsOf url: URL, withName resourceName: String? = nil) -> LoadRequest<TextureResource>

    /// Synchronously loads a texture resource from a URL with options.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// This method loads the image specified by the `URL` and creates a texture
    /// resource from it. This method blocks until it has loaded the image and
    /// created the texture resource.
    ///
    /// RealityKit uses the resource name to identify resources, and to match
    /// texture resources between networked peers. Specify a unique name for
    /// each texture resource you load or generate.
    ///
    /// - Parameters:
    ///   - url: The URL of the resource.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    ///   - options: A configuration for generating the texture.
    ///
    /// - Returns: The loaded resource.
    @available(macOS 12.0, iOS 15.0, *)
    @available(*, noasync, message: "Synchronous loading APIs block the main actor and should not be used in async contexts.  Use init(...) async instead")
    @MainActor @preconcurrency public static func load(contentsOf url: URL, withName resourceName: String? = nil, options: TextureResource.CreateOptions) throws -> TextureResource

    /// Asynchronously loads a texture resource from a URL with options.
    ///
    /// RealityKit uses the resource name to distinguish resources locally, and to match
    /// texture resources between networked peers. Specify a unique name for
    /// each texture resource you load or generate.
    ///
    /// - Parameters:
    ///   - url: The path or address of the file to load.
    ///
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///
    ///   - options: A configuration for generating the texture.
    ///
    /// - Returns: A load operation that publishes the resource.
    @available(macOS, introduced: 12.0, deprecated: 15.0, renamed: "init(contentsOf:withName:options:)")
    @available(iOS, introduced: 15.0, deprecated: 18.0, renamed: "init(contentsOf:withName:options:)")
    @available(macCatalyst, introduced: 15.0, deprecated: 18.0, renamed: "init(contentsOf:withName:options:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "init(contentsOf:withName:options:)")
    @MainActor @preconcurrency public static func loadAsync(contentsOf url: URL, withName resourceName: String? = nil, options: TextureResource.CreateOptions) -> LoadRequest<TextureResource>

    /// Synchronously creates a texture resource from an in-memory Core Graphics image.
    ///
    /// This method creates a texture resource from an existing
    /// <doc://com.apple.documentation/documentation/coregraphics/cgimage> with
    /// specific options. RealityKit uses the resource name to identify
    /// resources, and to match texture resources between networked peers.
    /// Specify a unique name for each texture resource you load or generate.
    ///
    /// - Parameters:
    ///   - cgImage: The source image.
    ///
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///
    ///   - options: A configuration for generating the texture.
    ///
    /// - Returns: A texture resource.
    @available(macOS, introduced: 12.0, deprecated: 15.0, renamed: "init(image:withName:options:)")
    @available(iOS, introduced: 15.0, deprecated: 18.0, renamed: "init(image:withName:options:)")
    @available(macCatalyst, introduced: 15.0, deprecated: 18.0, renamed: "init(image:withName:options:)")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(image:withName:options:)")
    @MainActor @preconcurrency public static func generate(from cgImage: CGImage, withName resourceName: String? = nil, options: TextureResource.CreateOptions) throws -> TextureResource

    /// Generates a texture resource from an in-memory Core
    /// Graphics image asynchronously.
    ///
    /// This method creates a texture resource from an existing
    /// <doc://com.apple.documentation/documentation/coregraphics/cgimage> with
    /// specific options. RealityKit uses the resource name to identify
    /// resources, and to match texture resources between networked peers.
    /// Specify a unique name for each texture resource you load or generate.
    ///
    /// - Parameters:
    ///   - cgImage: The source image.
    ///
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///
    ///   - options: A configuration for generating the texture.
    ///
    /// - Returns: A texture resource.
    @available(macOS 12.0, iOS 15.0, *)
    @available(macOS, introduced: 12.0, deprecated: 15.0, renamed: "init(image:withName:options:)")
    @available(iOS, introduced: 15.0, deprecated: 18.0, renamed: "init(image:withName:options:)")
    @available(macCatalyst, introduced: 15.0, deprecated: 18.0, renamed: "init(image:withName:options:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "init(image:withName:options:)")
    @MainActor @preconcurrency public static func generateAsync(from cgImage: CGImage, withName resourceName: String? = nil, options: TextureResource.CreateOptions) -> LoadRequest<TextureResource>

    /// Dynamically replaces the texture with a CoreGraphics image.
    ///
    /// This method blocks until the resource updates. Do not use this method for updates at frame rate frequency. For frequent
    /// texture changes, see ``replace(withDrawables:)``.  If a ``TextureResource/DrawableQueue``   has been attached
    /// to this resource, this function detaches it.
    ///
    /// To  ensure consistent usage of this texture resource, pass the same semantic in `options` that you used
    /// to create the resource.
    ///
    /// - Note: The contents of a modified texture resource are not synced between network clients.
    ///
    /// - Parameters:
    ///   - cgImage:      The source image.
    ///   - options:      Options that specify the type of texture to create.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public func replace(withImage cgImage: CGImage, options: TextureResource.CreateOptions) throws

    /// Replaces the texture with a CoreGraphics image asynchronously.
    ///
    /// Do not use this method for updates at frame rate frequency. For frequent texture changes, see ``replace(withDrawables:)``. To ensure
    /// consistent usage of this texture resource, pass the same semantic in `options` that you used to create the resource.
    ///
    /// - Note: The contents of a modified texture resource are not synced between network clients.
    ///
    /// - Parameters:
    ///   - cgImage:      Source image.
    ///   - options:      Options that specify the type of texture to create. To preserve TextureResource's usage, specify the same semantic.
    @available(macOS, introduced: 12.0, deprecated: 15.0, renamed: "replace(using:options:)")
    @available(iOS, introduced: 15.0, deprecated: 18.0, renamed: "replace(using:options:)")
    @available(macCatalyst, introduced: 15.0, deprecated: 18.0, renamed: "replace(using:options:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "replace(using:options:)")
    @MainActor @preconcurrency public func replaceAsync(withImage cgImage: CGImage, options: TextureResource.CreateOptions) -> LoadRequest<TextureResource>

    /// Copies texture data to another texture.
    ///
    /// This method blocks until the data is copied.  If a ``TextureResource/DrawableQueue``  has been attached
    /// to this resource, this function detaches it. This method copies all available mipmap sizes
    /// to `texture`.
    ///
    /// It is recommended that you provide a value for `CreateOptions.semantic` when creating this resource. Specifying a
    /// semantic for this texture resource enables RealityKit to select an appropriate pixel format for the target texture.
    ///
    /// Here is an example of using ``copy(to:)`` to get a texture resource's raw pixel data:
    /// ```swift
    /// let device: MTLDevice = ...
    /// let resource: TextureResource = ...
    /// let descriptor = MTLTextureDescriptor.texture2DDescriptor(
    ///     pixelFormat: .rgba8Unorm,
    ///     width: resource.width, // Needs to match
    ///     height: resource.height, // Needs to match
    ///     mipmapped: false)
    /// descriptor.usage = .shaderWrite // Required for copy
    ///
    /// guard let texture = device.makeTexture(descriptor: descriptor)
    /// else { throw ... }
    /// try resource.copy(to: texture)
    ///
    /// #if os(OSX) // Managed mode exists only in OSX
    /// if texture.storageMode == .managed {
    ///     // Managed textures need to be synchronized before accessing their data
    ///     guard let commandBuffer = device.makeCommandQueue()?.makeCommandBuffer(),
    ///           let blitEncoder = commandBuffer.makeBlitCommandEncoder()
    ///     else { throw ... }
    ///
    ///     blitEncoder.synchronize(resource: texture)
    ///     blitEncoder.endEncoding()
    ///     commandBuffer.commit()
    ///     commandBuffer.waitUntilCompleted()
    /// }
    /// #endif
    ///
    /// // Getting raw pixel bytes
    /// let bytesPerRow = 4 * texture.width
    /// var bytes = [UInt8](repeating: 0, count: texture.height * bytesPerRow)
    /// bytes.withUnsafeMutableBytes { bytesPtr in
    ///     texture.getBytes(
    ///         bytesPtr.baseAddress!,
    ///         bytesPerRow: bytesPerRow,
    ///         from: .init(origin: .init(), size: .init(width: texture.width, height: texture.height, depth: 1)),
    ///         mipmapLevel: 0
    ///     )
    /// }
    /// ```
    ///
    /// - Parameters:
    ///    - texture: Target texture for copying the data. It needs to have the same width and height as the TextureResource, and .shaderWrite usage.
    ///
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public func copy(to texture: any MTLTexture) throws

    /// Copies texture data to another texture asynchronously.
    ///
    /// This function is asynchronous. It returns immediately and runs in the background, calling `completionHandler` when it finishes or errors.
    /// This method copies all available mipmap sizes to `texture`.
    ///
    /// It is recommended that you provide a value for `CreateOptions.semantic` when creating this resource. Specifying a
    /// semantic for this texture resource enables RealityKit to select an appropriate pixel format for the target texture.
    ///
    /// - Parameters:
    ///   - texture:           Target texture for copying the data. It needs to have the same width and height as the TextureResource, and .shaderWrite usage.
    ///   - completionHandler: A closure called after once copy has completed, with nil error if succeeded.
    @available(macOS, introduced: 12.0, deprecated: 15.0, renamed: "copy(to:)")
    @available(iOS, introduced: 15.0, deprecated: 18.0, renamed: "copy(to:)")
    @available(macCatalyst, introduced: 15.0, deprecated: 18.0, renamed: "copy(to:)")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, renamed: "copy(to:)")
    @MainActor @preconcurrency public func copyAsync(to texture: any MTLTexture, completionHandler: @escaping @MainActor ((any Error)?) -> Void)

    /// A drawable associated with a drawable queue
    @available(macOS 12.0, iOS 15.0, *)
    public class Drawable {

        /// The DrawableQueue that this Drawable is owned by
        public var drawableQueue: TextureResource.DrawableQueue { get }

        /// A Metal texture object that contains the drawable’s contents.
        public var texture: any MTLTexture { get }

        /// Presents the updated texture to the renderer as soon as possible.
        ///
        /// Needs to be called after all commands in the command buffer have been executed (e.g.
        /// after `MTLCommandBuffer.waitUntilCompleted()`). When you call this method, the drawable
        /// will make the new texture content available to the renderer immediately.
        ///
        /// Alternatively, instead of waiting for completion you can call
        /// `MTLCommandBuffer.present(_:)` to signal in the command buffer that the texture is ready
        /// to use.
        public func present()

        /// Presents the updated texture to the renderer atomically with the current scene update.
        ///
        /// Needs to be called after all commands in the command buffer have been executed (e.g.
        /// after `MTLCommandBuffer.waitUntilCompleted()`). When you call this method, the drawable
        /// will make the new texture content available to the renderer at the same time as all other entity component
        /// changes made during the same scene update.
        @available(visionOS 1.0, *)
        @MainActor public func presentOnSceneUpdate()
    }

    /// A drawable queue that may be used to update a texture resource dynamically
    ///
    /// Each drawable queue can work with at most one consumer,
    /// such as a ``RealityRenderer`` instance or a render server.
    @available(macOS 12.0, iOS 15.0, *)
    public class DrawableQueue {

        /// Describes the texture managed by the drawable queue
        public struct Descriptor {

            /// The size and bit layout of all pixels in each drawable's texture.
            public var pixelFormat: MTLPixelFormat

            /// The width of each drawable's texture in pixels.
            public var width: Int

            /// The height of each drawable's texture in pixels.
            public var height: Int

            /// Options that determine how you can use each drawable's textures.
            public var usage: MTLTextureUsage

            /// A Boolean value that determines whether the resource should generate mipmaps for each drawable's texture after it was updated.
            public var mipmapsMode: TextureResource.MipmapsMode

            public init(pixelFormat: MTLPixelFormat, width: Int, height: Int, usage: MTLTextureUsage, mipmapsMode: TextureResource.MipmapsMode)
        }

        /// The size and bit layout of all pixels in each drawable's texture.
        public var pixelFormat: MTLPixelFormat { get }

        /// The width of each drawable's texture in pixels.
        public var width: Int { get }

        /// The height of each drawable's texture in pixels.
        public var height: Int { get }

        /// Options that determine how you can use each drawable's textures.
        public var usage: MTLTextureUsage { get }

        /// Options that determine how mipmaps are handled for each drawable's textures.
        public var mipmapsMode: TextureResource.MipmapsMode { get }

        /// Create a new drawable queue.
        ///
        /// - Parameter descriptor: A descriptor object that describes the texture to be created.
        @MainActor @preconcurrency public init(_ descriptor: TextureResource.DrawableQueue.Descriptor) throws

        /// Returns drawable when one is available, blocking the caller in the meantime.
        ///
        /// The method can block the caller for a duration up to
        /// the ``DrawableQueue-swift.class/Descriptor/timeout`` period.
        ///
        /// - Note: The method returns `nil` without blocking
        ///   when the drawable queue isn't bound to a material in the scene,
        ///   or when the render server is currently loading and initializing it.
        public func nextDrawable() throws -> TextureResource.Drawable

        /// A Boolean value that determines whether requests for a new drawable expire if the system can’t satisfy them.
        public var allowsNextDrawableTimeout: Bool
    }

    /// Dynamically replaces the texture with a drawable queue.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public func replace(withDrawables drawableQueue: TextureResource.DrawableQueue)

    /// The drawable queue that was used to replace the texture.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public var drawableQueue: TextureResource.DrawableQueue? { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Creates a new texture resource from a file URL.
    ///
    /// - Parameters:
    ///   - url: The path or address of the file to load into the texture resource.
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    @MainActor @preconcurrency public convenience init(contentsOf url: URL, withName resourceName: String? = nil) async throws

    /// Creates a new texture resource from a file URL with creation options.
    ///
    /// - Parameters:
    ///   - url: The path or address of the file to load into the texture resource.
    ///   - resourceName: A unique name the method assigns to the resource it loads,
    ///     for use in network synchronization.
    ///   - options: The options to use when loading the resource.
    @MainActor @preconcurrency public convenience init(contentsOf url: URL, withName resourceName: String? = nil, options: TextureResource.CreateOptions) async throws
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @MainActor @preconcurrency public static func == (lhs: TextureResource, rhs: TextureResource) -> Bool
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Generates a texture resource from an in-memory Core
    /// Graphics image asynchronously.
    ///
    /// This method creates a texture resource from an existing
    /// <doc://com.apple.documentation/documentation/coregraphics/cgimage> with
    /// specific options. RealityKit uses the resource name to identify
    /// resources, and to match texture resources between networked peers.
    /// Specify a unique name for each texture resource you load or generate.
    ///
    /// - Parameters:
    ///   - cgImage: The source image.
    ///
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///
    ///   - options: A configuration for generating the texture.
    ///
    /// - Returns: A texture resource.
    @available(macOS, unavailable, introduced: 15.0, renamed: "init(image:withName:options:)")
    @available(iOS, unavailable, introduced: 18.0, renamed: "init(image:withName:options:)")
    @available(macCatalyst, unavailable, introduced: 18.0, renamed: "init(image:withName:options:)")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(image:withName:options:)")
    @MainActor @preconcurrency public static func generate(from cgImage: CGImage, named resourceName: String? = nil, options: TextureResource.CreateOptions) async throws -> TextureResource

    /// Replaces the texture with a CoreGraphics image asynchronously.
    ///
    /// Do not use this method for updates at frame rate frequency. For frequent texture changes, see ``replace(withDrawables:)``. To ensure
    /// consistent usage of this texture resource, pass the same semantic in `options` that you used to create the resource.
    ///
    /// - Note: The contents of a modified texture resource are not synced between network clients.
    ///
    /// - Parameters:
    ///   - cgImage:      Source image.
    ///   - options:      Options that specify the type of texture to create. To preserve TextureResource's usage, specify the same semantic.
    @MainActor @preconcurrency public func replace(using cgImage: CGImage, options: TextureResource.CreateOptions) async throws

    /// Copies texture data to another texture asynchronously.
    ///
    /// This method copies all available mipmap sizes to `texture`.
    ///
    /// It is recommended that you provide a value for `CreateOptions.semantic` when creating this resource. Specifying a
    /// semantic for this texture resource enables RealityKit to select an appropriate pixel format for the target texture.
    ///
    /// - Parameters:
    ///   - texture:    Target texture for copying the data. It needs to have the same width and height as the TextureResource, and .shaderWrite usage.
    @MainActor @preconcurrency public func copy(to texture: any MTLTexture) async throws
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Creates a 2D texture array by generating it from images synchronously.
    ///
    /// Creates a `.type2DArray` texture with`'arrayLength == slices.count` from an array of images.
    ///
    /// You can assign the resulting texture to a material created in Reality Composer Pro that expects a 2D texture array.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///    ///
    /// ```swift
    /// // Create a 2D array texture from image slices.
    /// let texture2DArray = try await TextureResource.texture2DArray(
    ///     slices: [image0, image1, image2],
    ///     options: TextureResource.CreateOptions(semantic: .color))
    ///
    /// // Assign to a Shader Graph material parameter taking a 2D array texture.
    /// var material = try await ShaderGraphMaterial(
    ///     named: "/Root/Spaceship/MaterialWith2DArray", from: url)
    ///
    /// try material.setParameter(
    ///     name: "input2DArray", value: .textureResource(texture2DArray))
    /// ```
    ///
    /// - Parameters:
    ///   - slices: The source images, one per 2D array index. Images need to all have the same size and format.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public static func texture2DArray(slices: [CGImage], named resourceName: String? = nil, options: TextureResource.CreateOptions) throws -> TextureResource

    /// Creates a 2D texture array by generating it from images asynchronously.
    ///
    /// Creates a `.type2DArray` texture with `arrayLength == slices.count` from an array of images.
    ///
    /// You can assign the resulting texture to a material created in Reality Composer Pro that expects a 2D texture array.
    ///
    /// ```swift
    /// // Create a 2D array texture from image slices.
    /// let texture2DArray = try TextureResource.texture2DArray(
    ///     slices: [image0, image1, image2],
    ///     options: TextureResource.CreateOptions(semantic: .color))
    ///
    /// Task {
    ///     // Assign to a Shader Graph material parameter taking a 2D array texture.
    ///     var material = try await ShaderGraphMaterial(
    ///         named: "/Root/Spaceship/MaterialWith2DArray", from: url)
    ///
    ///     try material.setParameter(
    ///         name: "input2DArray", value: .textureResource(texture2DArray))
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - slices: The source images, one per 2D array index. Images need to all have the same size and format.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public static func texture2DArray(slices: [CGImage], named resourceName: String? = nil, options: TextureResource.CreateOptions) async throws -> TextureResource

    /// Creates a cube texture resource from face images synchronously.
    ///
    /// Provide the cube faces in the following order: [+X, -X, +Y, -Y, +Z, -Z].
    /// See ``cubemap(slices:named:options:)-7k9y6`` for more details.
    ///
    /// ```swift
    /// // Create a cube texture from image slices.
    /// let cube = try TextureResource.cube(
    ///     slices: [posXImage, negXImage, posYImage, negYImage, posZImage, negZImage],
    ///     options: TextureResource.CreateOptions(semantic: .hdrColor)
    /// )
    ///
    /// // Create an environment resource from the cube texture.
    /// let environment = try EnvironmentResource(
    ///     cube: cube,
    ///     options: EnvironmentResource.CreateOptions()
    /// )
    ///
    /// // Assign the environment to an image based light component.
    /// let lightEntity = Entity()
    /// lightEntity.components.set(ImageBasedLightComponent(source: .single(environment)))
    /// ...
    /// ```
    ///
    /// - Parameters:
    ///   - slices: The source images for each cube face, in [+X, -X, +Y, -Y, +Z, -Z] order. All images need to be square, and of equal size and format.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public static func cube(slices: [CGImage], named resourceName: String? = nil, options: TextureResource.CreateOptions) throws -> TextureResource

    /// Creates a cube texture resource from face images asynchronously.
    ///
    /// Provide the cube faces in the following order: [+X, -X, +Y, -Y, +Z, -Z].
    ///
    /// |![An illustration of the +X cube face orientation.](textureresource-cube-x-orientation)|![An illustration of the -X cube face orientation.](textureresource-cube-negx-orientation)|![An illustration of the +Y cube face orientation.](textureresource-cube-y-orientation)|![An illustration of the -Y cube face orientation.](textureresource-cube-negy-orientation)|![An illustration of the +Z cube face orientation.](textureresource-cube-z-orientation)|![An illustration of the -Z cube face orientation.](textureresource-cube-negz-orientation)|
    /// |-|-|-|-|-|-|
    ///
    /// Use the resulting texture to create an ``EnvironmentResource``,
    /// or assign it to a material in Reality Composer Pro that requires
    /// a cube texture type.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// ```swift
    /// // Create a cube texture from image slices.
    /// let cube = try await TextureResource.cube(
    ///     slices: [posXImage, negXImage, posYImage, negYImage, posZImage, negZImage],
    ///     options: TextureResource.CreateOptions(semantic: .hdrColor)
    /// )
    ///
    /// // Create an environment resource from the cube texture.
    /// let environment = try await EnvironmentResource(
    ///     cube: cube,
    ///     options: EnvironmentResource.CreateOptions()
    /// )
    ///
    /// await MainActor.run {
    ///     // Assign the environment to an image based light component.
    ///     let lightEntity = Entity()
    ///     lightEntity.components.set(ImageBasedLightComponent(
    ///         source: .single(environment)))
    ///     ...
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - slices: The source images for each cube face, in [+X, -X, +Y, -Y, +Z, -Z] order.
    ///     All images need to be square, and of equal size.
    ///   - resourceName: A unique name for syncing the texture resource across the network.
    ///     Name is empty if omitted.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public static func cube(slices: [CGImage], named resourceName: String? = nil, options: TextureResource.CreateOptions) async throws -> TextureResource

    /// Creates a 3D texture by generating it from images synchronously.
    ///
    /// From an array of images, creates a `.type3D` texture with `depth == slices.count`.
    ///
    /// You can assign the resulting texture to a material created in Reality Composer Pro that expects a 3D texture.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// ```swift
    /// // Create a 3D texture from image slices.
    /// let texture3D = try TextureResource.texture3D(
    ///     slices: [image0, image1, image2, image3],
    ///     options: TextureResource.CreateOptions(semantic: .color))
    ///
    /// Task {
    ///     // Assign to a Shader Graph material parameter taking a 3D texture.
    ///     var material = try await ShaderGraphMaterial(
    ///         named: "/Root/Alien/MaterialWith3DTexture", from: url)
    ///
    ///     try material.setParameter(
    ///         name: "input3DTexture",
    ///         value: .textureResource(texture3D))
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - slices: The source images, one per depth index.
    ///     All images need to be square, and of equal size and format.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name is empty if omitted.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public static func texture3D(slices: [CGImage], named resourceName: String? = nil, options: TextureResource.CreateOptions) throws -> TextureResource

    /// Creates a 3D texture by generating it from images asynchronously.
    ///
    /// From an array of images, creates a `.type3D` texture with `depth == slices.count`.
    ///
    /// You can assign the resulting texture to a material created in Reality Composer Pro that expects a 3D texture.
    ///
    /// ```swift
    /// // Create a 3D texture from image slices.
    /// let texture3D = try await TextureResource.texture3D(
    ///     slices: [image0, image1, image2, image3],
    ///     options: TextureResource.CreateOptions(semantic: .color))
    ///
    /// // Assign to a Shader Graph material parameter taking a 3D texture.
    /// var material = try await ShaderGraphMaterial(
    ///     named: "/Root/Alien/MaterialWith3DTexture", from: url)
    ///
    /// try material.setParameter(
    /// name: "input3DTexture",
    /// value: .textureResource(texture3D))
    /// ```
    ///
    /// - Parameters:
    ///   - slices: The source images, one per depth index.
    ///     All images need to be square, and of equal size and format.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public static func texture3D(slices: [CGImage], named resourceName: String? = nil, options: TextureResource.CreateOptions) async throws -> TextureResource
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Compression to be applied when importing an image as a texture.
    ///
    /// Allows varying levels of memory usage gains at the cost of image quality reduction.
    public struct Compression : Hashable, Sendable {

        /// Texture created with no or lossless compression.
        ///
        /// If exported to a `.reality` file (`Entity.write(to:)`), the texture will
        /// remain uncompressed.
        public static var none: TextureResource.Compression { get }

        /// Texture can be created and/or exported with lossy compression.
        ///
        /// The selected compression will preserve perceptual texture details
        /// (no aggressive compression).
        public static var `default`: TextureResource.Compression { get }

        /// Compressed block size.
        /// - Note: Block pixel data is stored in groups of 128 bits.
        ///         For instance, a block4x4's bits per pixel is:
        ///         128/(4*4) = 8 bit per pixel.
        public enum ASTCBlockSize : Hashable, Sendable {

            case block4x4

            case block5x4

            case block5x5

            case block6x5

            case block6x6

            case block8x5

            case block8x6

            case block8x8

            case block10x5

            case block10x6

            case block10x8

            case block10x10

            case block12x10

            case block12x12

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: TextureResource.Compression.ASTCBlockSize, b: TextureResource.Compression.ASTCBlockSize) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Selects the level of processing time allocated to achieve compression.
        /// - Important: Given its processing cost, runtime compression is not recommended for interactive applications,
        ///              as opposed to loading `.reality` files or `.ktx` pre-compressed textures.
        ///              Higher quality levels are recommended for pipelines assembling scenes meant to be exported to
        ///              `.reality` files.
        public enum ASTCQuality : Hashable, Sendable {

            /// Compresses as fast as possible.
            case fast

            /// Compresses with a good balance between quality and processing time.
            case normal

            /// Compresses with a focus on quality, reaching close to optimal quality
            /// while still spending much less time than `.exhaustive`.
            case high

            /// Compresses optimally, achieving minor gains over `.high` at the
            /// cost of much longer processing times.
            case exhaustive

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: TextureResource.Compression.ASTCQuality, b: TextureResource.Compression.ASTCQuality) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: TextureResource.Compression, b: TextureResource.Compression) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    public typealias SamplingQuality = EnvironmentResource.CreateOptions.SamplingQuality

    /// Synchronously creates a cube texture resource from an equirectangular image.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// RealityKit samples the source equirectangular image at the specified quality level to generate
    /// the cube texture. See ``init(cubeFromEquirectangular:named:quality:faceSize:options:)-bqd7``
    /// for equirectangular image requirements.
    ///
    /// ```swift
    /// if let source = CGImageSourceCreateWithURL(url as CFURL, nil),
    ///     let image = CGImageSourceCreateImageAtIndex(source, 0, nil) {
    ///
    ///     // Create a cube texture from the image.
    ///     let cube = try TextureResource(
    ///         cubeFromEquirectangular: image, quality: .normal,
    ///         options: TextureResource.CreateOptions(semantic: .hdrColor))
    ///
    ///     // Create an environment resource from the cube texture.
    ///     let environment = try EnvironmentResource(
    ///         cube: cube, options: EnvironmentResource.CreateOptions())
    ///
    ///     // Assign the environment to an image based light component.
    ///     let lightEntity = Entity()
    ///     lightEntity.components.set(ImageBasedLightComponent(
    ///         source: .single(environment)))
    ///     ...
    /// }
    /// ```
    ///    
    /// - Parameters:
    ///   - cgImage: The source image.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///   - quality: The sampling quality the initializer applies as it generates the cube texture.
    ///   - faceSize: The length of the cube's sides, in pixels.
    ///               When `faceSize` is `nil`, RealityKit computes the size based on the equirectangular image's dimensions.
    ///               RealityKit clamps the value to the source image's height.
    ///               For best results, pass values that are one third of the cubeʻs width or less.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public convenience init(cubeFromEquirectangular cgImage: CGImage, named resourceName: String? = nil, quality: TextureResource.SamplingQuality = .fast, faceSize: Int? = nil, options: TextureResource.CreateOptions) throws

    /// Creates a cube texture resource from an equirectangular image asynchronously.
    ///
    /// RealityKit samples the source equirectangular image at the specified quality level to generate
    /// the cube texture.
    ///
    /// The equirectangular image, also known as a latitude-longitude image, contains a flattened
    /// map of the surroundings where:
    /// - the width is a 360° clockwise scan along the horizon, starting from behind (+z-axis)
    /// - the height is a -90° (bottom) to +90° (top) vertical scan
    /// Equirectangular images should have a 2:1 aspect ratio to preserve all details.
    ///
    /// ![Equirectangular image illustrating axis orientation mapping to a
    /// cube.](textureresource-cube-equirectangular-orientation)
    ///
    /// Use the resulting texture to create an ``EnvironmentResource``,
    /// or assign it to a material in Reality Composer Pro that requires
    /// a cube texture type.
    ///
    /// ```swift
    /// if let source = CGImageSourceCreateWithURL(url as CFURL, nil),
    ///     let image = CGImageSourceCreateImageAtIndex(source, 0, nil) {
    ///
    ///     // Create a cube texture from the image.
    ///     let cube = try await TextureResource(
    ///         cubeFromEquirectangular: image, quality: .normal,
    ///         options: TextureResource.CreateOptions(semantic: .hdrColor))
    ///
    ///     // Create an environment resource from the cube texture.
    ///     let environment = try await EnvironmentResource(
    ///         cube: cube, options: EnvironmentResource.CreateOptions())
    ///
    ///     await MainActor.run {
    ///         // Assign the environment to an image based light component.
    ///         let lightEntity = Entity()
    ///         lightEntity.components.set(
    ///             ImageBasedLightComponent(source: .single(environment)))
    ///         ...
    ///     }
    /// }
    /// ```
    ///
    /// - Note: ``EnvironmentResource/CreateOptions/SamplingQuality-swift.enum/high`` and ``EnvironmentResource/CreateOptions/SamplingQuality-swift.enum/veryHigh`` quality, along with ``Compression/astc(blockSize:quality:)`` compression options, are only available on macOS.
    ///         Use these options to write optimized scenes for all target platforms when exporting from macOS with ``Entity/write(to:)``.
    ///         Compression options also significantly reduce cube's memory and disk usage.
    ///
    /// - Parameters:
    ///   - cgImage: The source image.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///   - quality: The sampling quality for generating the cube texture.
    ///   - faceSize: The dimension of a cube face.
    ///               When `faceSize` is `nil`, RealityKit computes the size based on the equirectangular image's dimensions.
    ///               RealityKit clamps the value to the source image's height.
    ///               It is not recommended for this value to exceed 1/3 of its width.
    ///   - options: A configuration for generating the texture.
    ///
    /// - Note: `faceSize` will be clamped to source equirectangular's height,
    ///       and is not recommended to exceed 1/3 of its width.
    @MainActor @preconcurrency public convenience init(cubeFromEquirectangular cgImage: CGImage, named resourceName: String? = nil, quality: TextureResource.SamplingQuality = .fast, faceSize: Int? = nil, options: TextureResource.CreateOptions) async throws

    /// Creates a cube texture resource from a 2D image of cube faces synchronously.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// The cube faces will be extracted from the source 2D image using a convention based on
    /// its aspect ratio. See ``init(cubefromimage:named:options:)-9dcus``  for more details.
    ///
    /// ```swift
    /// if let source = CGImageSourceCreateWithURL(url as CFURL, nil),
    ///     let image = CGImageSourceCreateImageAtIndex(source, 0, nil) {
    ///
    ///     // Create a cube texture from the image.
    ///     let cube = try TextureResource(
    ///         cubeFromImage: image,
    ///         options: TextureResource.CreateOptions(semantic: .hdrColor))
    ///
    ///     // Create an environment resource from the cube texture.
    ///     let environment = try EnvironmentResource(
    ///         cube: cube, options: EnvironmentResource.CreateOptions())
    ///
    ///     // Assign the environment to an image based light component.
    ///     let lightEntity = Entity()
    ///     lightEntity.components.set(ImageBasedLightComponent(source: .single(environment)))
    ///     ...
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - cgImage: The source image.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public convenience init(cubeFromImage cgImage: CGImage, named resourceName: String? = nil, options: TextureResource.CreateOptions) throws

    /// Creates a cube texture resource from a 2D image of cube faces asynchronously.
    ///
    /// The cube faces are extracted from the source 2D image using a convention based on
    /// its aspect ratio, which needs to be one of the following:
    ///
    /// If `height == 6 * width`, RealityKit assumes the source image contains a vertical strip of the cube faces, containing from top to bottom: [+X, -X, +Y, -Y, +Z, -Z].
    ///
    /// ![A cube source image showing expected cube face's orientation for a vertical strip
    /// layout.](textureresource-cube-vstrip-orientation)
    ///
    /// If `6 * height == width`, RealityKit assumes the source image contains an horizontal strip of the cube faces, containing from left to right: [+X, -X, +Y, -Y, +Z, -Z].
    ///
    /// ![A cube source image showing expected cube face's orientation for a vertical strip
    /// layout.](textureresource-cube-hstrip-orientation)
    ///
    /// If `height / 3 == width / 4`, RealityKit assumes the source image contains the following cross layout of the cube faces:
    /// ```
    ///     [+Y]
    /// [+X][-Z][-X][+Z]
    ///     [-Y]
    /// ```
    ///
    /// ![A cube source image showing expected cube face's orientation and layout for a cross
    /// layout.](textureresource-cube-cross-orientation)
    ///
    /// Use the resulting texture to create an ``EnvironmentResource``,
    /// or assign it to a material in Reality Composer Pro that requires
    /// a cube texture type.    ///
    ///
    /// ```swift
    /// if let source = CGImageSourceCreateWithURL(url as CFURL, nil),
    ///     let image = CGImageSourceCreateImageAtIndex(source, 0, nil) {
    ///
    ///     // Create a cube texture from the image.
    ///     let cube = try await TextureResource(
    ///         cubeFromImage: image, options: TextureResource.CreateOptions(semantic: .hdrColor))
    ///
    ///     // Create an environment resource from the cube texture.
    ///     let environment = try await EnvironmentResource(
    ///         cube: cube, options: EnvironmentResource.CreateOptions())
    ///
    ///     await MainActor.run {
    ///         // Assign the environment to an image based light component.
    ///         let lightEntity = Entity()
    ///         lightEntity.components.set(
    ///             ImageBasedLightComponent(source: .single(environment)))
    ///         ...
    ///     }
    /// }
    ///```
    ///
    /// - Parameters:
    ///   - cgImage: The source image.
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///   - options: A configuration for generating the texture.
    ///
    @MainActor @preconcurrency public convenience init(cubeFromImage cgImage: CGImage, named resourceName: String? = nil, options: TextureResource.CreateOptions) async throws
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Creates a texture resource from an in-memory Core Graphics image.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// This method creates a texture resource from an existing
    /// <doc://com.apple.documentation/documentation/coregraphics/cgimage> with
    /// specific options. RealityKit uses the resource name to identify
    /// resources, and to match texture resources between networked peers.
    /// Specify a unique name for each texture resource you load or generate.
    ///
    /// - Parameters:
    ///   - cgImage: The source image.
    ///
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///
    ///   - options: A configuration for generating the texture.
    ///
    /// - Returns: A texture resource.
    @MainActor @preconcurrency public convenience init(image cgImage: CGImage, withName resourceName: String? = nil, options: TextureResource.CreateOptions) throws

    /// Creates a texture resource from an in-memory Core
    /// Graphics image asynchronously.
    ///
    /// This method creates a texture resource from an existing
    /// <doc://com.apple.documentation/documentation/coregraphics/cgimage> with
    /// specific options. RealityKit uses the resource name to identify
    /// resources, and to match texture resources between networked peers.
    /// Specify a unique name for each texture resource you load or generate.
    ///
    /// - Parameters:
    ///   - cgImage: The source image.
    ///
    ///   - resourceName: A unique name for syncing the texture resource across the network. Name will be empty if omitted.
    ///
    ///   - options: A configuration for generating the texture.
    ///
    /// - Returns: A texture resource.
    @MainActor @preconcurrency public convenience init(image cgImage: CGImage, withName resourceName: String? = nil, options: TextureResource.CreateOptions) async throws
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// The dimensions of the 2D array texture.
    public struct Dimensions2DArray {
    }

    /// The dimensions of the cube texture.
    public struct DimensionsCube {
    }

    /// The dimensions of the 3D texture.
    public struct Dimensions3D {
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Specifies the width and height of a 2D texture.
    public struct Dimensions2D {
    }

    /// Specifies the pixel format and encoding of a texture.
    ///
    /// The texture's format controls the sampling and conversions (if any) used when rendering with that texture.
    public struct Format {
    }

    /// An object which references the pixel data for each mipmap level of a texture.
    ///
    /// Mipmaps are progressively smaller versions of the same texture image. Each level is half the size of the
    /// previous level, with a minimum size of 1 pixel in each dimension.
    public struct Contents {

        /// An object which references the pixel data for a single mipmap of a texture.
        public struct MipmapLevel {
        }

        /// Creates a texture contents object from an array of mipmaps.
        ///
        /// - Parameters:
        ///   - mipmapLevels: Pixel data for each mipmap level, starting with mipmap level 0.
        ///                   Supply at least one mipmap level.
        ///
        /// - Note: Creating 3D textures require MipmapLevel to be built with mip() methods that have a bytesPerImage paramater
        public init(mipmapLevels: [TextureResource.Contents.MipmapLevel])
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Asynchronously creates a 2D texture resource from a pixel metal buffer or data.
    ///
    /// Efficiently creates a 2D texture from raw pixel bytes, with full control over values and pixel format.
    ///
    /// ```swift
    /// var mips: [TextureResource.Contents.MipmapLevel] = []
    ///
    /// // Create the various mip levels.
    /// // A `bufferMipsInfo` structure describes how mips are packed in the source `MTLBuffer`.
    /// for mipInfo in bufferMipsInfo {
    ///     mips.append(.mip(
    ///         unsafeBuffer: buffer,
    ///         offset: mipInfo.offset,
    ///         size: mipInfo.size,
    ///         bytesPerRow: mipInfo.width * bytesPerPixel
    ///     ))
    /// }
    ///
    /// let texture = try await TextureResource(
    ///     dimensions: .dimensions(width: width, height: height),
    ///     format: .color(.displayP3, pixelFormat: .rgba8Unorm),
    ///     contents: TextureResource.Contents(mipmapLevels: mips)
    /// )
    ///```
    ///
    /// See ``init(named:in:)`` for an example of optimally loading textures with
    /// other content.
    ///
    /// - Parameters:
    ///   - dimensions: The width and height of the texture to create.
    ///   - format: The semantic interpretation of the pixel data.
    ///   - contents: Pixel data that will be copied into the created texture.
    ///
    @MainActor @preconcurrency public convenience init(dimensions: TextureResource.Dimensions2D, format: TextureResource.Format, contents: TextureResource.Contents) async throws

    /// Synchronously creates a 2D texture resource from a pixel metal buffer or data.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// Efficiently creates a 2D texture from raw pixel bytes, with full control over values and pixel format.
    /// See ``textureResource/init(dimensions:format:contents:)-5wn8m`` for more details.
    ///
    /// - Parameters:
    ///   - dimensions: The width and height of the texture to create.
    ///   - format: The semantic interpretation of the pixel data.
    ///   - contents: Pixel data that will be copied into the created texture.
    ///
    @MainActor @preconcurrency public convenience init(dimensions: TextureResource.Dimensions2D, format: TextureResource.Format, contents: TextureResource.Contents) throws
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Asynchronously creates a 2D array texture resource from a pixel metal buffer or data.
    ///
    /// Efficiently creates a 2D array texture from raw pixel bytes, with full control over values and pixel format.
    /// You can assign the resulting texture to a material created in Reality Composer Pro that expects a 2D texture array.
    ///
    /// ```swift
    /// var mips: [TextureResource.Contents.MipmapLevel] = []
    ///
    /// // Create the various mip levels.
    /// // A `bufferMipsInfo` structure describes how mips are packed in the source `MTLBuffer`.
    /// for mipInfo in bufferMipsInfo {
    ///     var slices = [TextureResource.Contents.Slice]()
    ///     for sliceInfo in mipInfo {
    ///         slices.append(.slice(
    ///             unsafeBuffer: buffer,
    ///             offset: sliceInfo.offset,
    ///             size: sliceInfo.size,
    ///             bytesPerRow: sliceInfo.width * bytesPerPixel
    ///         ))
    ///     }
    ///     mips.append(.mip(slices: slices))
    /// }
    ///
    /// let texture = try TextureResource(
    ///     dimensions: .dimensions(width: width, height: height, length: arrayLength),
    ///     format: .color(.displayP3, pixelFormat: .rgba8Unorm),
    ///     contents: TextureResource.Contents(mipmapLevels: mips)
    /// )
    /// ```
    ///
    /// See ``init(named:in:)`` for an example of optimally loading textures with
    /// other content.
    ///
    /// - Parameters:
    ///   - dimensions: The dimensions of the 2D array texture to create.
    ///   - format: The semantic interpretation of the pixel data.
    ///   - contents: Pixel data that will be copied into the created texture.
    ///
    @MainActor @preconcurrency public convenience init(dimensions: TextureResource.Dimensions2DArray, format: TextureResource.Format, contents: TextureResource.Contents) async throws

    /// Synchronously creates a 2D array texture resource from a pixel metal buffer or data.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// Efficiently creates a 2D array texture from raw pixel bytes, with full control over values and pixel format.
    /// See ``textureResource/init(dimensions:format:contents:)-324ls`` for more details.
    ///
    /// - Parameters:
    ///   - dimensions: The dimensions of the 2D array texture to create.
    ///   - format: The semantic interpretation of the pixel data.
    ///   - contents: Pixel data that will be copied into the created texture.
    ///
    @MainActor @preconcurrency public convenience init(dimensions: TextureResource.Dimensions2DArray, format: TextureResource.Format, contents: TextureResource.Contents) throws

    /// Asynchronously creates a cube texture resource from a pixel metal buffer or data.
    ///
    /// Efficiently creates a cube texture from raw pixel bytes, with full control over values and pixel format.
    /// Use the resulting texture to create an ``EnvironmentResource``,
    /// or assign it to a material in Reality Composer Pro that requires
    /// a cube texture type.
    ///
    /// ```swift
    /// var mips: [TextureResource.Contents.MipmapLevel] = []
    ///
    /// // Create the various mip levels.
    /// // A `bufferMipsInfo` structure describes how mips are packed in the source `MTLBuffer`.
    /// for mipInfo in bufferMipsInfo {
    ///     var faceSlices = [TextureResource.Contents.Slice]()
    ///     for faceInfo in mipInfo {
    ///         faceSlices.append(.slice(
    ///             unsafeBuffer: buffer,
    ///             offset: faceInfo.offset,
    ///             size: faceInfo.size,
    ///             bytesPerRow: faceInfo.width * bytesPerPixel
    ///         ))
    ///     }
    ///     mips.append(.mip(slices: faceSlices))
    /// }
    ///
    /// let texture = try TextureResource(
    ///     dimensions: .dimensions(faceSize: faceSize),
    ///     format: .color(.displayP3, pixelFormat: .rgba8Unorm),
    ///     contents: TextureResource.Contents(mipmapLevels: mips)
    /// )
    /// ```
    ///
    /// See ``init(named:in:)`` for an example of optimally loading textures with
    /// other content.
    ///
    /// - Parameters:
    ///   - dimensions: The dimensions of cube texture to create.
    ///   - format: The semantic interpretation of the pixel data.
    ///   - contents: Pixel data that will be copied into the created texture.
    @MainActor @preconcurrency public convenience init(dimensions: TextureResource.DimensionsCube, format: TextureResource.Format, contents: TextureResource.Contents) async throws

    /// Synchronously creates a cube texture resource from a pixel metal buffer or data.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// Efficiently creates a cube texture from raw pixel bytes, with full control over values and pixel format.
    /// See ``textureResource/init(dimensions:format:contents:)-28vgd`` for more details.
    ///
    /// - Parameters:
    ///   - dimensions: The dimensions of cube texture to create.
    ///   - format: The semantic interpretation of the pixel data.
    ///   - contents: Pixel data that will be copied into the created texture.
    @MainActor @preconcurrency public convenience init(dimensions: TextureResource.DimensionsCube, format: TextureResource.Format, contents: TextureResource.Contents) throws

    /// Asynchronously creates a 3D texture resource from a pixel metal buffer or data.
    ///
    /// Efficiently creates a 3D texture from raw pixel bytes, with full control over values and pixel format.
    /// You can assign the resulting texture to a material created in Reality Composer Pro that expects a 3D texture.
    ///
    /// ```swift
    /// var mips: [TextureResource.Contents.MipmapLevel] = []
    ///
    /// // Create the various mip levels.
    /// // A `bufferMipsInfo` structure describes how mips are packed in the source `MTLBuffer`.
    /// for mipInfo in bufferMipsInfo {
    ///     // A mip contains all of the depth slices,
    ///     // each with a stride specified by `bytesPerImage`.
    ///     mips.append(.mip(
    ///         unsafeBuffer: buffer,
    ///         offset: mipInfo.offset,
    ///         size: mipInfo.size,
    ///         bytesPerRow: mipInfo.width * bytesPerPixel,
    ///         bytesPerImage: mipInfo.width * mipInfo.height * bytesPerPixel
    ///     ))
    /// }
    ///
    /// let texture = try TextureResource(
    ///     dimensions: .dimensions(width: width, height: height, depth: depth),
    ///     format: .color(.displayP3, pixelFormat: .rgba8Unorm),
    ///     contents: TextureResource.Contents(mipmapLevels: mips)
    /// )
    /// ```
    ///
    /// See ``init(named:in:)`` for an example of optimally loading textures with
    /// other content.
    ///
    /// - Parameters:
    ///   - dimensions: The dimensions of the 3D texture to create.
    ///   - format: The semantic interpretation of the pixel data.
    ///   - contents: Pixel data that will be copied into the created texture.
    ///
    @MainActor @preconcurrency public convenience init(dimensions: TextureResource.Dimensions3D, format: TextureResource.Format, contents: TextureResource.Contents) async throws

    /// Synchronously creates a 3D texture resource from a pixel metal buffer or data.
    ///
    /// Efficiently creates a 3D texture from raw pixel bytes, with full control over values and pixel format.
    /// See ``textureResource/init(dimensions:format:contents:)-64sua`` for more details.
    ///
    /// Loading a ``TextureResource`` with this method blocks the main actor because it’s synchronous, so only call it from a command line application.
    /// The method can stall a regular app which makes it visibly hitch, and the system terminates an app if its UI becomes unresponsive.
    /// See ``init(named:in:)`` for an example that demonstrates how to safely load content.
    ///
    /// - Parameters:
    ///   - dimensions: The dimensions of the 3D texture to create.
    ///   - format: The semantic interpretation of the pixel data.
    ///   - contents: Pixel data that will be copied into the created texture.
    ///
    @MainActor @preconcurrency public convenience init(dimensions: TextureResource.Dimensions3D, format: TextureResource.Format, contents: TextureResource.Contents) throws
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource {

    /// Asynchronously create a texture resource from a ``LowLevelTexture``.
    ///
    /// - Parameter texture: The texture data that defines the resource.
    @MainActor @preconcurrency public convenience init(from texture: LowLevelTexture) async throws

    /// Synchronously create a texture resource from a ``LowLevelTexture``.
    ///
    /// - Parameter texture: The texture data that defines the resource.
    @MainActor @preconcurrency public convenience init(from texture: LowLevelTexture) throws

    /// Replace a texture resource with a ``LowLevelTexture``.
    ///
    /// - Warning: It is more efficient to use ``LowLevelTexture/replace(using:)`` 
    ///   to update a ``LowLevelTexture`` on the GPU than it is to update the `TextureResource`.
    ///   Prefer to update the ``LowLevelTexture`` directly instead.
    ///
    /// - Parameter texture: The texture data that defines the resource.
    @MainActor @preconcurrency public func replace(with texture: LowLevelTexture)
}

@available(macOS 12.0, iOS 15.0, *)
extension TextureResource.Semantic : Sendable {
}

@available(macOS 12.0, iOS 15.0, *)
extension TextureResource.Semantic : Equatable {
}

@available(macOS 12.0, iOS 15.0, *)
extension TextureResource.Semantic : Hashable {
}

@available(macOS 12.0, iOS 15.0, *)
extension TextureResource.MipmapsMode : Sendable {
}

@available(macOS 12.0, iOS 15.0, *)
extension TextureResource.MipmapsMode : Equatable {
}

@available(macOS 12.0, iOS 15.0, *)
extension TextureResource.MipmapsMode : Hashable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions2DArray {

    /// The dimensions of the 2D array texture. The number of mipmap levels is inferred from the contents.
    public static func dimensions(width: Int, height: Int, length: Int) -> TextureResource.Dimensions2DArray
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions2DArray : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextureResource.Dimensions2DArray, b: TextureResource.Dimensions2DArray) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions2DArray : Sendable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.DimensionsCube {

    /// The dimensions of the cube texture. The number of mipmap levels is inferred from the contents.
    public static func dimensions(faceSize: Int) -> TextureResource.DimensionsCube
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.DimensionsCube : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextureResource.DimensionsCube, b: TextureResource.DimensionsCube) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.DimensionsCube : Sendable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions3D {

    /// The dimensions of the 3D texture. The number of mipmap levels is inferred from the contents.
    public static func dimensions(width: Int, height: Int, depth: Int) -> TextureResource.Dimensions3D
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions3D : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextureResource.Dimensions3D, b: TextureResource.Dimensions3D) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions3D : Sendable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions2D {

    /// Specifies the width and height of a texture. The number of mipmap levels is inferred from the contents.
    public static func dimensions(width: Int, height: Int) -> TextureResource.Dimensions2D
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions2D : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextureResource.Dimensions2D, b: TextureResource.Dimensions2D) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Dimensions2D : Sendable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format {

    /// A profile that specifies the interpretation of pixel values as a color.
    ///
    /// The color primaries and white point are specified by this color space, but the transfer function is specified by the pixel format.
    public enum ColorSpace {

        /// DCI P3 primaries with a D65 white point.
        case displayP3
    }

    /// Indicates that a texture contains color data that should be interpreted in a specific color space.
    ///
    /// The created texture will use the ``RealityKit/TextureResource/Semantic-swift.enum/color`` or
    /// ``RealityKit/TextureResource/Semantic-swift.enum/hdrColor`` semantic.
    public static func color(_ colorSpace: TextureResource.Format.ColorSpace, pixelFormat: MTLPixelFormat) -> TextureResource.Format
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format {

    public enum NormalEncoding {

        /// A normal map with the X and Y components of a surface normal in the tangent space of the surface
        /// encoded in the red and green channels of a texture, with each component between 0.0 and 1.0.
        case xy

        /// A normal map with the X and Y components of a surface normal in the tangent space of the surface
        /// encoded in the alpha and green channels of a texture, with each component between 0.0 and 1.0.
        case wy
    }

    /// Indicates that a texture is a normal map.
    ///
    /// The created texture will use the ``RealityKit/TextureResource/Semantic-swift.enum/normal`` semantic.
    public static func normal(_ encoding: TextureResource.Format.NormalEncoding, pixelFormat: MTLPixelFormat) -> TextureResource.Format
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format {

    /// Indicates that a texture is intended for unmodified use by a shader.
    ///
    /// The created texture will use the ``RealityKit/TextureResource/Semantic-swift.enum/raw`` semantic.
    public static func raw(pixelFormat: MTLPixelFormat) -> TextureResource.Format
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextureResource.Format, b: TextureResource.Format) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format : Sendable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Contents {

    /// An object which references the pixel data for a single slice of a mipmap.
    public struct Slice : Sendable {

        /// Specifies a single mipmap level slice of a texture resource with pixel data copied from a byte buffer.
        /// - note 2D array textures have `arrayLength` slices per mipmap, and cube textures have 6 slices
        ///       per mipmap. 2D and 3D textures have a single slice per mipmap.
        ///
        /// - Parameters:
        ///   - data: The source buffer.
        ///   - bytesPerRow: The stride in bytes between rows of texture data stored in the source buffer.
        ///                  The value needs to be a multiple of the destination texture's pixel size, in bytes.
        public static func slice(data: Data, bytesPerRow: Int) -> TextureResource.Contents.Slice

        /// Specifies a single mipmap level slice of a texture resource with pixel data copied from a Metal buffer.
        /// - note 2D array textures have `arrayLength` slices per mipmap, and cube textures have 6 slices
        ///       per mipmap. 2D and 3D textures have a single slice per mipmap.
        ///
        /// - Parameters:
        ///   - buffer: The source buffer.
        ///     Do not modify this buffer while using it as the source of a copy operation.
        ///   - offset: The byte position in the source buffer where the copying starts.
        ///             The offset needs to be a multiple of the destination texture's pixel size, in bytes.
        ///   - size: The number of bytes in the source buffer (starting from `offset`) available for copying.
        ///   - bytesPerRow: The stride in bytes between rows of texture data stored in the source buffer.
        ///                  The value needs to be a multiple of the destination texture's pixel size, in bytes.
        ///
        /// > Important: A ``Slice`` created with this function and used to create a ``TextureResource``
        /// will copy from the source buffer. That copy occurs when the ``TextureResource`` is initialized. The caller
        /// is responsible for ensuring that the source Metal buffer is not modified while it is being copied to a texture.
        public static func slice(unsafeBuffer buffer: any MTLBuffer, offset: Int = 0, size: Int, bytesPerRow: Int) -> TextureResource.Contents.Slice
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Contents : Sendable {
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.DrawableQueue.Descriptor {

    /// Specifies a timeout value in seconds when querying nextDrawable().
    /// nextDrawable() will be blocked for up to the specified timeout period for a drawable to become available else throws `NextDrawableError.timeoutReached`.
    /// By default this is set to 1 second. Note that if `allowsNextDrawableTimeout` is false, then the timeout parameter will be ignored.
    public var timeout: Duration

    public init(pixelFormat: MTLPixelFormat, width: Int, height: Int, usage: MTLTextureUsage, mipmapsMode: TextureResource.MipmapsMode, timeout: Duration)
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format.ColorSpace : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextureResource.Format.ColorSpace, b: TextureResource.Format.ColorSpace) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format.ColorSpace : Sendable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format.NormalEncoding : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextureResource.Format.NormalEncoding, b: TextureResource.Format.NormalEncoding) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Format.NormalEncoding : Sendable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Contents.MipmapLevel {

    /// Specifies a single mipmap level of a 2D or 3D texture resource with pixel data copied from a byte buffer.
    ///
    /// - Parameters:
    ///   - data: The source buffer.
    ///   - bytesPerRow: The stride in bytes between rows of texture data stored in the source buffer.
    ///                  The value needs to be a multiple of the destination texture's pixel size, in bytes.
    public static func mip(data: Data, bytesPerRow: Int) -> TextureResource.Contents.MipmapLevel

    /// Specifies a single mipmap level of a 2D or 3D texture resource with pixel data copied from a Metal buffer.
    ///
    /// - Parameters:
    ///   - buffer: The source buffer.
    ///     Do not modify this buffer while using it as the source of a copy operation.
    ///   - offset: The byte position in the source buffer where the copying starts.
    ///             The offset needs to be a multiple of the destination texture's pixel size, in bytes.
    ///   - size: The number of bytes in the source buffer (starting from `offset`) available for copying.
    ///   - bytesPerRow: The stride in bytes between rows of texture data stored in the source buffer.
    ///                  The value needs to be a multiple of the destination texture's pixel size, in bytes.
    ///
    /// > Important: A ``MipmapLevel`` created with this function and used to create a ``TextureResource``
    /// will copy from the source buffer. That copy occurs when the ``TextureResource`` is initialized. The caller
    /// is responsible for ensuring that the source Metal buffer is not modified while it is being copied to a texture.
    public static func mip(unsafeBuffer buffer: any MTLBuffer, offset: Int = 0, size: Int, bytesPerRow: Int) -> TextureResource.Contents.MipmapLevel
}

@available(visionOS 2.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Contents.MipmapLevel {

    /// Specifies a single mipmap level of a 2D or 3D texture resource provided by slices.
    ///
    /// - Parameters:
    ///   - slices: The source slices.
    ///             A 2D array texture requires one slice per `arrayLength`.
    ///             For a cube texture requires 6 slices, containing faces `[+X, -X, +Y, -Y, +Z, -Z]`.
    ///             2D and 3D texture need a single slice, and their MipmapLevel can also be built with
    ///             `mip(buffer:offset:size:bytesPerRow:)` or `mip(data:bytesPerRow)`.
    public static func mip(slices: [TextureResource.Contents.Slice]) -> TextureResource.Contents.MipmapLevel

    /// Specifies a single mipmap level of a 2D or 3D texture resource with pixel data copied from a byte buffer.
    ///
    /// - Parameters:
    ///   - data: The source buffer.
    ///   - bytesPerRow: The stride in bytes between rows of texture data stored in the source buffer.
    ///                  The value needs to be a multiple of the destination texture's pixel size, in bytes.
    ///   - bytesPerImage: The stride in bytes between image planes of texture data stored in the source buffer,
    ///                    needed for 3D texture mips.
    ///                    The value needs to be a multiple of the destination texture's
    ///                    pixel size, in bytes.
    public static func mip(data: Data, bytesPerRow: Int, bytesPerImage: Int) -> TextureResource.Contents.MipmapLevel

    /// Specifies a single mipmap level of a 2D or 3D texture resource with pixel data copied from a Metal buffer.
    ///
    /// - Parameters:
    ///   - buffer: The source buffer.
    ///     Do not modify this buffer while using it as the source of a copy operation.
    ///   - offset: The byte position in the source buffer where the copying starts.
    ///             The offset needs to be a multiple of the destination texture's pixel size, in bytes.
    ///   - size: The number of bytes in the source buffer (starting from `offset`) available for copying.
    ///   - bytesPerRow: The stride in bytes between rows of texture data stored in the source buffer.
    ///                  The value needs to be a multiple of the destination texture's pixel size, in bytes.
    ///   - bytesPerImage: The stride in bytes between image planes of texture data stored in the source buffer,
    ///                    needed for 3D texture mips.
    ///                    The value needs to be a multiple of the destination texture's pixel size, in bytes.
    ///
    /// > Important: A ``MipmapLevel`` created with this function and used to create a ``TextureResource``
    /// will copy from the source buffer. That copy occurs when the ``TextureResource`` is initialized. The caller
    /// is responsible for ensuring that the source Metal buffer is not modified while it is being copied to a texture.
    public static func mip(unsafeBuffer buffer: any MTLBuffer, offset: Int = 0, size: Int, bytesPerRow: Int, bytesPerImage: Int) -> TextureResource.Contents.MipmapLevel
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension TextureResource.Contents.MipmapLevel : Sendable {
}

/// A type that modulates the force strength based on how long the force effect has run.
///
/// Forces have the largest strength when the force effect starts to play and gradually decay to zero when approaching
/// the given duration. The effect also stops playing when reaching the duration.
///
/// Similar to ``SpatialForceFalloff``, ``TimedForceFalloff/rate`` controls how fast the force strength decays.
/// You can set the rate to zero to have a force effect with no temporal falloff.
///
///```swift
/// let noTimedFalloff = TimedFalloff(duration: 1, rate: 0)
///```
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct TimedForceFalloff {

    /// Creates a timed force falloff.
    ///
    /// - Parameters:
    ///    - duration: The lifetime of the effect in seconds.
    ///    - rate: Controls how fast or slow falloff occurs.
    ///
    /// * When the rate is **0**, no falloff occurs. (Rigid bodies outside the bounds are culled.)
    /// * When the rate is **greater than 0 and less than 1.0**, falloff occurs slower and is sublinear.
    /// * When the rate is **1.0**, falloff is linear.
    /// * When the rate is **greater than 1**, falloff occurs faster and is nonlinear.
    public init(duration: TimeInterval, rate: Double = 1.0)

    /// The lifetime of the effect in seconds.
    ///
    /// This value needs to be non-negative.
    public var duration: TimeInterval

    /// The temporal falloff / attenuation rate.
    ///
    /// An exponent that determines how the effect's strength diminishes over time.
    /// Use a non-negative rate.
    /// * When the rate is **0**, no falloff occurs.
    /// * When the rate is **greater than 0 and less than 1.0**, falloff occurs slower and is sublinear.
    /// * When the rate is **1.0**, falloff is linear.
    /// * When the rate is **greater than 1**, falloff occurs faster and is nonlinear.
    public var rate: Double
}

/// A component that defines the scale, rotation, and translation of an entity.
///
/// An entity acquires a ``Transform`` component, as well as a set of methods
/// for manipulating the transform, by adopting the ``HasTransform`` protocol.
/// This is true for all entities, because the ``Entity`` base class adopts the
/// protocol.
@available(macOS 10.15, iOS 13.0, *)
@frozen public struct Transform : Component, Hashable {

    /// The identity transform.
    ///
    /// The identity transform is defined as `scale = (1, 1, 1)`, `rotation =
    /// (0, 0, 0, 1)`, and `translation = (0, 0, 0)`.
    public static let identity: Transform

    /// The scaling factor applied to the entity.
    public var scale: SIMD3<Float>

    /// The rotation of the entity specified as a unit quaternion.
    public var rotation: simd_quatf

    /// The position of the entity along the x, y, and z axes.
    public var translation: SIMD3<Float>

    /// The transform represented as a 4x4 matrix.
    ///
    /// The ``Transform`` component can’t represent all transforms that a
    /// general 4x4 matrix can represent. Using a 4x4 matrix to set the
    /// transform is therefore a lossy event that might result in certain
    /// transformations, like shear, being dropped.
    @inlinable public var matrix: float4x4

    /// Creates a transform with the values of the identity transform.
    public init()

    /// Creates a new transformation using the given values.
    ///
    /// - Parameters:
    ///   - scale: A scale factor.
    ///
    ///   - rotation: The rotation given as a unit quaternion.
    ///
    ///   - translation: The translation, or position along the x, y, and z axes.
    @inlinable public init(scale: SIMD3<Float> = SIMD3<Float>(x: 1, y: 1, z: 1), rotation: simd_quatf = simd_quaternion(0, 0, 0, 1), translation: SIMD3<Float> = SIMD3<Float>(x: 0, y: 0, z: 0))

    /// Creates a new transform from the specified Euler angles.
    ///
    /// The rotation order using intrinsic rotation order is defined as:
    ///
    /// 1. Rotate around y-axis (yaw). 2. Rotate around the body-fixed x-axis
    /// (pitch). 3. Rotate around the body-fixed z-axis (roll).
    ///
    /// The rotation order using extrinsic rotation order is defined as:
    ///
    /// 1. Rotate around the z-axis (roll). 2. Rotate around the world space
    /// x-axis (pitch). 3. Rotate around the world space y-axis (yaw).
    ///
    /// - Parameters:
    ///   - x: The rotation around the x-axis in radians.
    ///
    ///   - y: The rotation around the y-axis in radians.
    ///
    ///   - z: The rotation around the z-axis in radians.
    @inlinable public init(pitch x: Float = 0, yaw y: Float = 0, roll z: Float = 0)

    /// Creates a new transform represented as a 4x4 matrix.
    ///
    /// A ``RealityKit/Transform`` component can’t represent every transform that a
    /// general 4x4 matrix can . Using a 4x4 matrix during
    /// initialization might result in certain transformations, such as shear, being lost.
    ///
    /// - Parameters:
    ///   - matrix: A transformation matrix.
    ///   
    public init(matrix: float4x4)

    /// Hashes the essential components of the transform by feeding them into
    /// the given hash function.
    ///
    /// - Parameters:
    ///   - hasher: The hash function to use when combining the components of the
    ///     scene.
    @inlinable public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Transform, b: Transform) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, *)
extension Transform : BindableData {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Transform {

    public init(_ transform: AffineTransform3D)
}

@available(macOS 12.0, iOS 15.0, *)
extension Transform : AnimatableData {
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension Transform : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.15, iOS 13.0, *)
extension Transform : Sendable {
}

@available(macOS 10.15, iOS 13.0, *)
extension Transform : BitwiseCopyable {
}

/// An interface for components that aren’t saved to file or cloned.
///
/// Components that conform to the ``TransientComponent`` protocol aren’t
/// included when RealityKit serializes its owning entity to save it to a file.
/// Similarly, when you clone an entity, any transient components on that entity
/// aren’t copied to the clone.
///
/// To ensure that cloned entities, or entities saved to file get a copy of the
/// transient component with default values, create and initialize the component
/// in your entity’s `init()` method:
///
/// ```swift
/// class MyEntity: Entity {
///     required init() {
///         let newComponent = MyComponent()
///         components[MyComponent.self] = newComponent
///         return newComponent
///     }
/// }
/// ```
///
/// Alternatively, you can create a computed
/// property for your component that initializes it to default values the first
/// time your code accesses it.
///
/// ```swift
/// class MyEntity: Entity {
///     var myComponent: MyComponent {
///         // If the component exists, return it.
///         if let component = components[MyComponent.self] {
///             return component
///         }
///
///         // Create a new component and return it.
///         components[MyComponent.self] = MyComponent()
///         return newComponent
///     }
/// }
/// ```
///
/// Use transient components to represent runtime state for an entity. For
/// example, an entity representing a fish in a virtual aquarium might store
/// attributes such as hunger in a transient component.
///
/// In networked AR experiences, RealityKit sends transient components to peers
/// when it sends the entity, if the component also conforms to
/// <doc://com.apple.documentation/documentation/swift/codable>. If transient
/// components don’t conform, ReaityKit still sends the entity to network peers,
/// but it excludes the transient component.
@available(macOS 12.0, iOS 15.0, *)
public protocol TransientComponent : Component {
}

/// An invisible 3D shape that detects when objects enter or exit a given region
/// of space.
///
/// A trigger volume is an entity that can participate in collisions because it
/// has a ``CollisionComponent``. You use a trigger volume as a sensor that
/// indicates when another collision-capable entity, like a ``ModelEntity``,
/// enters the region of space occupied by the trigger volume. You can use the
/// generated ``CollisionEvents`` between the trigger volume and the other
/// entity to trigger an action, like indicating to the user that a projectile
/// hit its target.
///
/// ![Diagram showing the components present in the trigger volume
/// entity.](TriggerVolume-1)
///
/// The trigger volume itself is very simple. It lacks any physical appearance,
/// and doesn’t participate in physics simulations. This makes it very efficient
/// for tasks that require only collision detection.
@available(macOS 10.15, iOS 13.0, *)
@MainActor @preconcurrency public class TriggerVolume : Entity, HasCollision {

    /// Creates a trigger volume.
    @MainActor @preconcurrency required public init()

    /// Creates a trigger volume with the given shape and collision filter.
    ///
    /// - Parameters:
    ///   - shape: The shape of the trigger volume.
    ///
    ///   - filter: A collision filter that lets you differentiate among collision
    ///     groups.
    @MainActor @preconcurrency public convenience init(shape: ShapeResource, filter: CollisionFilter = .sensor)

    /// Creates a trigger volume with the given composite shape and collision
    /// filter.
    ///
    /// - Parameters:
    ///    - shapes: A collection of shapes which taken together define the
    ///  composite shape of the trigger volume.
    ///    - filter: A collision filter that lets you differentiate among collision groups.
    @MainActor @preconcurrency public init(shapes: [ShapeResource], filter: CollisionFilter = .sensor)
}

/// A force effect that applies random forces
/// with magnitudes proportional to each body's velocity.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct TurbulenceForceEffect : ForceEffectProtocol, Codable {

    /// Creates a turbulence force effect.
    ///  - Parameters:
    ///     - strength: The magnitude of the force.
    ///     - smoothness:  The amount of randomness used in the turbulence effect.
    public init(strength: Double, smoothness: Double, speed: Double)

    /// Calculates the turbulence forces for rigid bodies from the force effect.
    ///
    /// - Parameter parameters: On input, the parameters that calculate forces to the affected physics bodies; on output, the updates to those forces.
    ///
    /// The framework automatically calls this method for you at each physics simulation step,
    /// so you don't need to call it yourself.
    public func update(parameters: inout ForceEffectParameters)

    /// The magnitude of the force.
    public let strength: Float

    /// A smoothing factor that applies to the force, reducing randomness.
    ///
    /// A value of `0.0` specifies maximum noise, and a value of `1.0` specifies no noise at all.
    public let smoothness: Float

    /// The effect’s variation over time.
    ///
    /// Specify `0.0` for a static force field.
    public let speed: Float

    /// The input rigid body parameters.
    public var parameterTypes: PhysicsBodyParameterTypes { get }

    /// The type of force this effect applies.
    public var forceMode: ForceMode

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// Options that determine whether an animation switches between frames
/// gradually or abruptly.
///
/// This enumeration declares the options for a sampled animation's
/// ``SampledAnimation/tweenMode``. The gradual or abrupt change, or
/// _interpolation_, refers to the visual behavior that occurs between adjacent
/// values in a sampled animation's ``SampledAnimation/frames-2hobp``.
@available(macOS 12.0, iOS 15.0, *)
public enum TweenMode {

    /// An option that indicates a keyframe changes to the next abruptly.
    case hold

    /// An option that indicates that a keyframe changes to the next gradually.
    case linear

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TweenMode, b: TweenMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, *)
extension TweenMode : Equatable {
}

@available(macOS 12.0, iOS 15.0, *)
extension TweenMode : Hashable {
}

/// A material that doesn’t respond to lights in the scene.
///
/// `UnlitMaterial` materials do not respond
/// to virtual or real lighting.
///
/// Add an `UnlitMaterial` to a model by setting it as one of the
/// ``ModelComponent/materials`` in a ``ModelComponent``.
///
/// ```swift
/// let unlitMaterial = UnlitMaterial(color: .red)
/// let model = ModelComponent(
///     mesh: .generateBox(size: 1),
///     materials: [unlitMaterial]
/// )
/// redBoxEntity.components.set(model)
/// ```
///
/// For example, a ``SimpleMaterial`` on the left, and an `UnlitMaterial` on the right:
///
/// | ``SimpleMaterial`` | `UnlitMaterial` |
/// |:-:|:-:|
/// | ![A screenshot of a red cube in a living room scene. The cube is rounded on the edges, and appears to be made of a reflective plastic material.](simplematerial-not-metallic) | ![A screenshot of a red cube in a living room scene. The shape is of a cube observed from an angle above and to the right of it, and has no discernible edges as it has no response to lighting.](unlitmaterial-red) |
///
/// - Note: The blending mode of `UnlitMaterial` materials should be configured explicitly with the
/// ``UnlitMaterial/blending-swift.property`` property for transparent or translucent surfaces.  The
/// `opaque` mode is used when unset.
@available(macOS 10.15, iOS 13.0, *)
public struct UnlitMaterial : Material {

    /// The material's base color.
    ///
    /// - Note: The blending mode of `UnlitMaterial` materials should be configured explicitly with the
    /// ``UnlitMaterial/blending-swift.property`` property for transparent or translucent surfaces.  The
    /// `opaque` mode is used when unset.
    @available(macOS 12.0, iOS 15.0, *)
    public var color: UnlitMaterial.BaseColor

    /// Creates an unlit material.
    public init()

    /// A threshold below which RealityKit ignores opacity.
    ///
    /// When `opacityThreshold` is set, RealityKit discards pixels with opacity values less
    /// than the `opacityThreshold`, and renders opacity values greater than or equal to
    /// `opacityThreshold` fully opaque.
    ///
    /// - Note: When the `opacityThreshold` property is set, the blend mode of the
    /// ``UnlitMaterial/blending-swift.property`` property is ignored and the renderer
    /// applies the masking behavior.
    @available(macOS 12.0, iOS 15.0, *)
    public var opacityThreshold: Float?

    /// The transparency options for the material.
    @available(macOS 12.0, iOS 15.0, *)
    public var blending: UnlitMaterial.Blending
}

@available(macOS 12.0, iOS 15.0, *)
extension UnlitMaterial {

    /// The type used to represent base color.
    @available(macOS 12.0, iOS 15.0, *)
    public typealias BaseColor = PhysicallyBasedMaterial.BaseColor

    /// The type used to represent textures.
    @available(macOS 12.0, iOS 15.0, *)
    public typealias Texture = PhysicallyBasedMaterial.Texture

    /// The type used to represent opacity information.
    @available(macOS 12.0, iOS 15.0, *)
    public typealias Blending = PhysicallyBasedMaterial.Blending
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension UnlitMaterial {

    public typealias TriangleFillMode = MaterialParameterTypes.TriangleFillMode

    /// The object that controls how RealityKit draws triangles.
    ///
    /// A value of ``MaterialParameterTypes/TriangleFillMode/fill`` causes RealityKit
    /// to draw triangles normally, while a value of  ``MaterialParameterTypes/TriangleFillMode/lines``
    /// turns on wireframe rendering.
    public var triangleFillMode: UnlitMaterial.TriangleFillMode

    public init(applyPostProcessToneMap: Bool)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension UnlitMaterial {

    /// A boolean value that determines whether this material writes its depth into RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will occlude objects behind them by writing their depth
    /// into RealityKit's depth buffer. 
    ///
    /// If false, meshes with this material will not write their depth into
    /// RealityKit's depth buffer, and may be overwritten by objects drawn behind them, depending on
    /// draw order.
    ///
    /// The default value is true.
    public var writesDepth: Bool

    /// A boolean value that determines whether this material performs the depth test by reading RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will depth test each of their fragments when being rendered.
    /// If an object that writes depth is in front of this material, this material will be hidden.
    ///
    /// If false, meshes with this material will ignore the depth test, and always render all of their
    /// fragments during their draw call, regardless of the positioning of other objects in the scene.
    /// Note that other objects may still render on top of this material, depending on draw order.
    ///
    /// The default value is true.
    public var readsDepth: Bool
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension UnlitMaterial {

    /// An object that represents the backing shader compilation required for
    /// unlit materials.
    ///
    /// You can use this type to control when RealityKit compiles shaders,
    /// and to initialize `UnlitMaterial` objects with more predicitable loading performance.
    ///
    /// When initializing an `UnlitMaterial` this way, a `Program` object is
    /// created first asynchronously, which is used to cache the material's shader program so
    /// the `UnlitMaterial` can be loaded immediately later.
    ///
    /// For example:
    ///
    /// ```swift
    /// // Initialize descriptor with desired properties
    /// var descriptor = UnlitMaterial.Descriptor()
    /// descriptor.applyPostProcessToneMap = false
    ///
    /// // Create program object
    /// let program = await UnlitMaterial.Program(descriptor: descriptor)
    ///
    /// // Create material (returns immediately)
    /// let material = UnlitMaterial(program: program)
    /// ```
    final public class Program : Equatable, Hashable, Sendable {

        final public let descriptor: UnlitMaterial.Program.Descriptor

        /// An object that specifies all parameters necessary to initialize `UnlitMaterial` programs
        public struct Descriptor : Equatable, Hashable, Sendable {

            /// A Boolean value that determines whether RealityKit will tonemap the output of this material.
            ///
            /// If true, the created `UnlitMaterial.Program` will tonemap its color output to better
            /// match the rest of the scene; if false, the created `UnlitMaterial.Program` will output
            /// its color without modification.
            ///
            /// Default value is true.
            public var applyPostProcessToneMap: Bool

            /// Modes that describe how materials using the created `UnlitMaterial.Program` will be blended with content behind them.
            ///
            /// Default value is nil, which will cause this material to render opaque, and not blend with background content.
            public var blendMode: MaterialParameterTypes.BlendMode?

            public init()

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: UnlitMaterial.Program.Descriptor, b: UnlitMaterial.Program.Descriptor) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: UnlitMaterial.Program, rhs: UnlitMaterial.Program) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        final public func hash(into hasher: inout Hasher)

        public init(descriptor: UnlitMaterial.Program.Descriptor) async

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        final public var hashValue: Int { get }
    }

    public var program: UnlitMaterial.Program

    public init(program: UnlitMaterial.Program)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension UnlitMaterial {

    /// Creates a new unlit material with the provided color texture.
    public init(texture: TextureResource)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension UnlitMaterial {

    /// An alias for the cull mode object that’s appropriate for this material class.
    public typealias FaceCulling = MaterialParameterTypes.FaceCulling

    public var faceCulling: UnlitMaterial.FaceCulling
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension UnlitMaterial {

    /// An alias for the texture coordinate transform that’s appropriate for this material class.
    public typealias TextureCoordinateTransform = MaterialParameterTypes.TextureCoordinateTransform

    /// A two-dimensional transformation to apply to the entity’s primary
    /// texture coordinates.
    ///
    /// An entity’s UV texture coordinates control how RealityKit materials map
    /// image textures onto an entity. This property allows you to transform the
    /// texture coordinates to change the way this material maps its textures.
    /// You might, for example, change the scale of a property to apply a tiled,
    /// repeating pattern, or continuously rotate or translate the texture
    /// coordinates to animate materials to create special effects, such as fire
    /// or flowing liquids.
    ///
    /// The following example shows how to set a material’s UV transformation:
    ///
    /// ```swift
    /// let rotationRadians = Float(45.0) * .pi / 180 // 45 degrees converted to radians.
    /// material.textureCoordinateTransform = .init(offset: SIMD2<Float>(x:0.5, y: 0.5),
    ///                                             scale: SIMD2<Float>(x:0.5, y: 0.5),
    ///                                             rotation: rotationRadians)
    /// ```
    ///
    /// Some entities imported from USDZ files have more than one set of UV
    /// coordinates. This property affects the primary UV set (sometimes called
    /// “UV1”). To transform the secondary UV coordinates (”UV2”), use
    /// ``UnlitMaterial/secondaryTextureCoordinateTransform``.
    public var textureCoordinateTransform: UnlitMaterial.TextureCoordinateTransform

    /// A two-dimensional transformation to apply to the entity’s secondary
    /// texture coordinates.
    ///
    /// This property transforms the secondary set. To transform
    /// the primary UV coordinates in a material, see
    /// ``UnlitMaterial/textureCoordinateTransform-swift.property``.
    public var secondaryTextureCoordinateTransform: UnlitMaterial.TextureCoordinateTransform
}

/// Provides access to physics body parameters from the effect's update function or event handler.
///
/// This struct is a transient buffer view of underlying data, and is only available in effect's update function or update closure.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct UnsafeForceEffectBuffer<T> : Sequence {

    /// Returns an element by index.
    ///
    /// The index should be in the range [0, ``ForceEffectParameters/physicsBodyCount``].
    public subscript(index: Int) -> T { get }

    /// Iterates over all elements of the `UnsafeForceEffectBuffer`.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> T?

        /// The type of element traversed by the iterator.
        @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
        public typealias Element = T
    }

    /// Returns an iterator for the sequence.
    public func makeIterator() -> UnsafeForceEffectBuffer<T>.Iterator

    /// Returns the number of elements in the buffer.
    public var count: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = T
}

/// A material that supports animated textures.
///
/// In RealityKit, a _material_ is an object that defines the surface properties
/// of a rendered 3D object. A `VideoMaterial` is a material that maps a movie
/// file on to the surface of an entity. Video materials are _unlit_, which
/// means that scene lighting doesn’t affect them. Video materials support
/// transparency if the source video’s file format also supports transparency.
///
/// Video materials use an
/// <doc://com.apple.documentation/documentation/avfoundation/avplayer> instance
/// to control movie playback. You can use any movie file format that
/// <doc://com.apple.documentation/documentation/avfoundation/avplayer> supports
/// to create a video material. To control playback of the material’s video, use
/// the ``VideoMaterial/avPlayer`` property, which offers methods like
/// <doc://com.apple.documentation/documentation/avfoundation/avplayer/1386726-play>
/// and
/// <doc://com.apple.documentation/documentation/avfoundation/avplayer/1387895-pause>.
///
/// The following code demonstrates how to create and start playing a video
/// material using a movie file from your application bundle.
///
/// ```swift
/// // Create a URL that points to the movie file.
/// if let url = Bundle.main.url(forResource: "MyMovie", withExtension: "mp4") {
///
///     // Create an AVPlayer instance to control playback of that movie.
///     let player = AVPlayer(url: url)
///
///     // Instantiate and configure the video material.
///     let material = VideoMaterial(avPlayer: player)
///
///     // Configure audio playback mode.
///     material.controller.audioInputMode = .spatial
///
///     // Create a new model entity using the video material.
///     let modelEntity = ModelEntity(mesh: cube, materials: [material])
///
///     // Start playing the video.
///     player.play()
/// }
/// ```
///
/// To see an example of using a video texture in RealityKit, see
/// <doc://com.apple.documentation/documentation/realitykit/creating_a_game_with_scene_understanding>.
@available(macOS 11.0, iOS 14.0, *)
public struct VideoMaterial : Material {

    /// Creates a new video material.
    ///
    /// To create a video material, first create an
    /// <doc://com.apple.documentation/documentation/avfoundation/avplayer>
    /// instance initialized with a URL that points to the movie file you want
    /// the video material to play, then pass that to this initializer. The
    /// following code demonstrates this process.
    ///
    /// ```swift
    /// // Create a URL that points to the movie file.
    /// if let url = Bundle.main.url(forResource: "MyMovie", withExtension: "mp4") {
    ///
    ///     // Create an AVPlayer instance to control playback of that movie.
    ///     let player = AVPlayer(url: url)
    ///
    ///     // Instantiate and configure the video material.
    ///     let material = VideoMaterial(avPlayer: player)
    ///
    ///     // Configure audio playback mode. This is optional for movie
    ///     // files that contain sound.
    ///     material.controller.audioInputMode = .spatial
    ///
    ///     // Create a new model entity using the video material.
    ///     let modelEntity = ModelEntity(mesh: cube, materials: [material])
    ///
    ///     // Start playing the video.
    ///     player.play()
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - avPlayer: An
    ///     <doc://com.apple.documentation/documentation/avfoundation/avplayer>
    ///     instance.
    @MainActor @preconcurrency public init(avPlayer: AVPlayer)

    /// The material’s video playback controller.
    ///
    /// Use this property to control animation playback for a video texture.
    /// This property allows you to play or pause the movie, _seek to_ (in other
    /// words, skip to) a specific part of the movie, or to change the movie’s
    /// playback rate. The following code demonstrates pausing the texture’s
    /// video and restarting it from the beginning of the movie file:
    ///
    /// ```swift
    /// myMaterial.avPlayer.pause()
    /// myMaterial.avPlayer.seek(to: .zero)
    /// myMaterial.avPlayer.play()
    /// ```
    @MainActor @preconcurrency public var avPlayer: AVPlayer?

    /// An object that configures framework-specific video options.
    ///
    /// Use this property to configure AR-specific properties of the texture’s
    /// video, such as whether the material should use spatial audio.
    ///
    /// The following example demonstrates enabling spatial audio for a video
    /// material:
    ///
    /// ```swift
    /// material.controller.audioInputMode = .spatial
    /// ```
    public var controller: VideoPlaybackController { get }

    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public typealias TriangleFillMode = MaterialParameterTypes.TriangleFillMode

    /// The object that controls how RealityKit draws triangles.
    ///
    /// A value of ``MaterialParameterTypes/TriangleFillMode/fill`` causes RealityKit
    /// to draw triangles normally, while a value of  ``MaterialParameterTypes/TriangleFillMode/lines``
    /// turns on wireframe rendering.
    @available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
    public var triangleFillMode: VideoMaterial.TriangleFillMode
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension VideoMaterial {

    /// A boolean value that determines whether this material writes its depth into RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will occlude objects behind them by writing their depth
    /// into RealityKit's depth buffer.
    ///
    /// If false, meshes with this material will not write their depth into
    /// RealityKit's depth buffer, and may be overwritten by objects drawn behind them, depending on
    /// draw order.
    ///
    /// The default value is true.
    public var writesDepth: Bool

    /// A boolean value that determines whether this material performs the depth test by reading RealityKit's depth buffer.
    ///
    /// If true, meshes with this material will depth test each of their fragments when being rendered.
    /// If an object that writes depth is in front of this material, this material will be hidden.
    ///
    /// If false, meshes with this material will ignore the depth test, and always render all of their
    /// fragments during their draw call, regardless of the positioning of other objects in the scene.
    /// Note that other objects may still render on top of this material, depending on draw order.
    ///
    /// The default value is true.
    public var readsDepth: Bool
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension VideoMaterial {

    /// An alias for the cull mode object that’s appropriate for this material class.
    public typealias FaceCulling = MaterialParameterTypes.FaceCulling

    /// A process in which the system specifies polygons to remove before
    /// rendering a mesh using this material.
    ///
    /// To improve performance, RealityKit culls polygons, or faces, that it
    /// determines won’t be visible. Discarding faces that aren’t part of the
    /// final render eliminates the need to do any calculations for those
    /// faces.
    ///
    /// RealityKit recognizes when a face aims toward the camera (a front face)
    /// or away from the camera (a back face). This value controls the type of
    /// faces RealityKit culls.
    ///
    /// This value defaults to ``MaterialParameterTypes/FaceCulling/back``,
    /// which means RealityKit removes faces that point away from the camera.
    /// Most of the time, this is the correct behavior, because back faces are
    /// usually obscured by other front-facing polygons.
    ///
    /// You can change the culling behavior to cull front faces instead or to
    /// turn off face culling altogether, but be aware that turning off face
    /// culling results in less efficient rendering and may negatively impact
    /// your app’s frame rate.
    public var faceCulling: VideoMaterial.FaceCulling
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension VideoMaterial {

    /// The material’s video renderer.
    ///
    /// Pass this renderer to the material as a parameter
    /// in the initializer; you can't replace it afterward.
    /// You can't use the same `AVSampleBufferVideoRenderer`
    /// object with more than one `VideoMaterial`.
    public var videoRenderer: AVSampleBufferVideoRenderer? { get }

    /// Creates and initializes a video material for a sample buffer video renderer object.
    ///
    /// To create a `VideoMaterial`, first create an <doc://com.apple.documentation/documentation/avfoundation/avsamplebuffervideorenderer>
    /// instance with no parameters and then pass that to the `VideoMaterial` initializer. After creating the `VideoMaterial`,
    /// create a <doc://com.apple.documentation/documentation/avfoundation/avassetreader> with
    /// the <doc://com.apple.documentation/documentation/avfoundation/avurlasset> and
    /// load the media (video), which you need to track as the <doc://com.apple.documentation/documentation/avfoundation/avassettrack>.
    /// Feed this `AVAssetTrack` to the doc://com.apple.documentation/documentation/avfoundation/avassetreadertrackoutput>  and
    /// add this output tracker to the `AVAssetReader` you created before. Wait for setup to finish and start reading.
    /// Read the sample buffers from the reader and enqueue it into the `AVSampleBufferVideoRenderer` object.
    /// `AVSampleBufferVideoRenderer` uses a push model, so feed the video sample buffers until the queue is full and then resume feeding it when it's ready for more.
    /// You can use `isReadyForMoreMediaData` on the `AVSampleBufferVideoRenderer` object in a while-loop to check if you need to enqueue more sample buffers.
    /// You can't use the same `AVSampleBufferVideoRenderer` object with more than one `VideoMaterial`.
    ///
    /// You need to synchronize the audio, captions, and playback rate separately in your application.
    ///
    /// The following code demonstrates this process.
    ///
    /// ```swift
    /// // Create an `AVSampleBufferVideoRenderer` instance to control playback of a movie.
    /// let videoRenderer = AVSampleBufferVideoRenderer()
    ///
    /// // Create an entity for display.
    /// let entity = ModalEntity()
    ///
    /// // Create a `VideoMaterial` object that supplies the `AVSampleBufferVideoRenderer` object.
    /// entity.model = .init(mesh: plane, materials: [VideoMaterial(videoRenderer: videoRenderer)])
    ///
    /// // Create a URL that points to the movie file.
    /// if let url = Bundle.main.url(forResource: "MyMovie", withExtension: "mp4") {
    ///
    ///     let sourceAsset = AVURLAsset(url: url)
    ///     let sourceAssetReader = AVAssetReader(asset: sourceAsset)
    ///     let sourceAssetVideoTrack = sourceAsset.loadTracks(withMediaType: .video).first
    ///     let sourceAssetReaderVideoTrackOutput = AVAssetReaderTrackOutput(track: sourceAssetVideoTrack!, outputSettings: nil)
    ///     sourceAssetReader.add(sourceAssetReaderVideoTrackOutput!)
    ///
    ///     sourceAssetReader.startReading()
    ///     videoRenderer.requestMediaDataWhenReady(on: DispatchQueue.global()) {
    ///       while videoRenderer.isReadyForMoreMediaData {
    ///           if let sampleBuffer = sourceAssetReaderVideoTrackOutput!.copyNextSampleBuffer() {
    ///               videoRenderer.enqueue(sampleBuffer)
    ///           } else {
    ///               videoRenderer.stopRequestingMediaData()
    ///               return
    ///           }
    ///       }
    ///   }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///    - videoRenderer: The sample buffer video renderer whose visual contents the material presents.
    ///
    public init(videoRenderer: AVSampleBufferVideoRenderer)
}

/// An object that controls the playback of video for a video material.
@available(macOS 11.0, iOS 14.0, *)
@MainActor @preconcurrency public class VideoPlaybackController {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension VideoPlaybackController {

    /// Options for viewing video playback.
    public enum ViewingMode {

        /// A viewing mode that presents video in monoscopic mode.
        case mono

        /// A viewing mode that presents video in stereoscopic mode, if it's available.
        @available(visionOS 1.0, *)
        @available(macOS, unavailable)
        @available(iOS, unavailable)
        @available(tvOS, unavailable)
        case stereo

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: VideoPlaybackController.ViewingMode, b: VideoPlaybackController.ViewingMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Do we want to play stereo video in mono or stereo?
    /// Default is to play in stereo.
    @MainActor @preconcurrency public var preferredViewingMode: VideoPlaybackController.ViewingMode

    /// Is the currently playing video in mono or stereo?
    /// This is optional because the video may not currently be playing, or the mode is otherwise not available.
    @MainActor @preconcurrency public var currentViewingMode: VideoPlaybackController.ViewingMode? { get }

    /// What is the width and height of currently playing video (for stereo, the width and height of each eye)?
    /// This is optional because the video may not currently be playing, or the size is otherwise not available.
    @MainActor @preconcurrency public var currentImageSize: CGSize? { get }
}

@available(macOS 11.0, iOS 14.0, *)
extension VideoPlaybackController : Sendable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension VideoPlaybackController.ViewingMode : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension VideoPlaybackController.ViewingMode : Hashable {
}

/// A component that supports general video-playback experience with an AV player.
///
/// To streamline and enhance video playback controls, a video player component empowers an app to support
/// captions, subtitles, light spill, and passthrough tinting (visionOS only). Attach a `VideoPlayerComponent`
/// to an entity to start configuring playback controls.
///
/// The example below shows an entity with a ``VideoPlayerComponent`` attached:
/// @Video(
///     source: videoplayercomponent-videoplaying,
///     alt: "A screen recording of an entity with a video player component playing in a living room scene.",
///     poster: videoplayercomponent-videoplaying-poster
/// )
///
/// The following code example shows the basic setup for initializing a `VideoPlayerComponent` with an
/// <doc://com.apple.documentation/documentation/avfoundation/avplayer>:
///
/// ```swift
/// // Create an entity for display.
/// let videoEntity = Entity()
///
/// // Create an AV player with a URL.
/// let player = AVPlayer(url: "PLACEMENT_URL")
///
/// // Create a video player component with the AV player.
/// let videoPlayerComponent = VideoPlayerComponent(avPlayer: player)
///
/// // Attach the video player component to the entity.
/// videoEntity.components.set(videoPlayerComponent)
/// ```
///
/// Here are some common usage scenarios before attaching the video player component to the entity:
///
///```swift
/// // Set the desired viewing mode to stereo to enable 
/// // stereoscopic playback of the video, if available.
/// videoPlayerComponent.desiredViewingMode = VideoPlaybackController.ViewingMode.stereo
///
/// // Enable passthrough tinting during video playback.
/// videoPlayerComponent.isPassthroughTintingEnabled = true
///```
///
/// Here are a few event subscription examples for ``VideoPlayerEvents``:
///
/// ```swift
/// RealityView { content in
///     // Set up a video player component with an AV player.
///     let entity = Entity()
///     let player = AVPlayer(url: "PLACEMENT_URL")
///     let videoPlayerComponent = VideoPlayerComponent(avPlayer: player)
///     player.play()
///     entity.components.set(videoPlayerComponent)
///
///     var subscription: EventSubscription?
///
///     // Subscribe to the video screen size change event.
///     subscription = content.subscribe(to:
///         VideoPlayerEvents.VideoSizeDidChange.self) { event in
///         print("video size did change: \(event.videoDimension)")
///     }
///
///    // Subscribe to the current viewing mode change event.
///     subscription = content.subscribe(to:
///         VideoPlayerEvents.ViewingModeDidChange.self) { event in
///         print("viewing mode did change: \(event.currentViewingMode)")
///     }
///
///     // Subscribe to the content type change event.
///     subscription = content.subscribe(to:
///         VideoPlayerEvents.ContentTypeDidChange.self) { event in
///         print("content type did change: \(event.contentType.rawValue)")
///     }
///
///     content.add(entity)
/// }
/// ```
///
///
/// ### Playing immersive video
///
/// In visionOS, you can also use `VideoPlayerComponent` to play immersive media with RealityKit.
/// Watch videos in a window alongside other Shared Space apps, or watch immersive video
/// with a 180-degree field of view in a fully immersive space.
///
/// ### Playing immersive video with a 180-degree field of view
///
/// To play the immersive media with a 180-degree field of view, first set up a fully immersive space,
/// and then set ``desiredImmersiveViewingMode`` to ``ImmersiveViewingMode-swift.enum/full``.
///
/// If you want to switch the immersive-viewing mode to `full` while immersive-media playback
/// is in ``ImmersiveViewingMode-swift.enum/portal`` mode,
/// wait for the scene event named ``VideoPlayerEvents/ImmersiveViewingModeDidChange``
/// to trigger after you set ``desiredImmersiveViewingMode`` to `full`.
/// Then, dismiss the window scene and open up a fully immersive space scene.
///
/// ### Playing immersive video in a portal window
///
/// To play the immersive video in a portal window, set up a window scene in the Shared Space,
/// and then set ``desiredImmersiveViewingMode`` to ``ImmersiveViewingMode-swift.enum/portal``.
///
/// If you want to switch the immersive-viewing mode to `portal` while immersive-media playback
/// is in `full` mode, wait for the scene event named
/// ``VideoPlayerEvents/ImmersiveViewingModeDidChange`` to trigger
/// after you set ``desiredImmersiveViewingMode`` to `portal`.
/// Then, dismiss the fully immersive space and open up a window scene.
///
/// ### Updating the UI during transitions
///
/// The system triggers scene events named
/// ``VideoPlayerEvents/ImmersiveViewingModeWillTransition`` and
/// ``VideoPlayerEvents/ImmersiveViewingModeDidTransition``
/// at the start and end of the immersive-viewing mode transitions, respectively.
/// Apps can listen to these scene events to turn playback controls or other UI items on or off during transitions.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct VideoPlayerComponent : Component {

    /// The viewer's selected content-viewing mode.
    ///
    /// This is the content-viewing mode that the current content-viewing mode transitions to.
    @available(macOS 15.0, iOS 18.0, visionOS 1.0, *)
    public var desiredViewingMode: VideoPlaybackController.ViewingMode

    /// The current content-viewing mode for video playback.
    @available(macOS 15.0, iOS 18.0, visionOS 1.0, *)
    public var viewingMode: VideoPlaybackController.ViewingMode? { get }

    /// Options for viewing the video during immersive-media playback.
    ///
    /// This applies only to immersive media types.
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(macCatalyst, unavailable)
    public enum ImmersiveViewingMode {

        /// A viewing mode that renders immersive video as a portal window matching the
        /// containing entity's transform. 
        case portal

        /// A viewing mode that renders immersive video covering the viewer's entire
        /// field of view.
        case full

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: VideoPlayerComponent.ImmersiveViewingMode, b: VideoPlayerComponent.ImmersiveViewingMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The viewer's selected immersive-viewing mode.
    ///
    /// This is the immersive-viewing mode that the current immersive-viewing mode transitions to.
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(macCatalyst, unavailable)
    public var desiredImmersiveViewingMode: VideoPlayerComponent.ImmersiveViewingMode

    /// The current immersive-viewing mode.
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(macCatalyst, unavailable)
    public var immersiveViewingMode: VideoPlayerComponent.ImmersiveViewingMode? { get }

    /// The screen entity size of the current video player in meters.
    ///
    /// This property has the format `[width, height]`.
    public var playerScreenSize: SIMD2<Float> { get }

    /// The video resolution size.
    ///
    /// This property has the format `[width, height]`, for example, `[1920, 1080]`.
    public var screenVideoDimension: SIMD2<Float> { get }

    /// A Boolean value that indicates whether the passthrough camera feed is tinted, emphasizing the video content.
    @available(visionOS 1.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    public var isPassthroughTintingEnabled: Bool

    /// The AV player that the component plays.
    ///
    /// Pass this player to the component as a parameter
    /// in the initializer; you can't replace it afterward.
    public var avPlayer: AVPlayer? { get }

    /// Creates a video player component from an AV player object.
    ///
    /// - Note: You can't use the same `AVPlayer` object with more than one `VideoPlayerComponent`.
    ///
    /// Here's an example of setting up a video player component:
    ///
    /// ```swift
    /// // Create an entity for display.
    /// let videoEntity = Entity()
    ///
    /// // Create an AV player with a URL.
    /// let player = AVPlayer(url: "PLACEMENT_URL")
    ///
    /// // Create a video player component with the AV player.
    /// let videoPlayerComponent = VideoPlayerComponent(avPlayer: player)
    ///
    /// // Attach the video player component to the entity.
    /// videoEntity.components.set(videoPlayerComponent)
    /// ```
    ///
    /// - Parameters:
    ///   - avPlayer: An
    /// <doc://com.apple.documentation/documentation/avfoundation/avplayer>
    /// instance.
    public init(avPlayer: AVPlayer)
}

@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
extension VideoPlayerComponent {

    /// The component's video renderer.
    ///
    /// Pass this renderer to the component as a parameter
    /// in the initializer; you can't replace it afterward.
    /// You can't use the same `AVSampleBufferVideoRenderer`
    /// object with more than one `VideoPlayerComponent`.
    public var videoRenderer: AVSampleBufferVideoRenderer? { get }

    /// Creates a video player component from a sample buffer video renderer object.
    ///
    /// To create a `VideoPlayerComponent`, first create an 
    /// <doc://com.apple.documentation/documentation/avfoundation/avsamplebuffervideorenderer>
    /// instance with no parameters and then pass that to the `VideoPlayerComponent` initializer.
    /// After creating the `VideoPlayerComponent`, create an
    /// <doc://com.apple.documentation/documentation/avfoundation/avassetreader> 
    /// with the <doc://com.apple.documentation/documentation/avfoundation/avurlasset>
    /// and load the media (video), which you need to track as the
    /// <doc://com.apple.documentation/documentation/avfoundation/avassettrack>.
    /// Feed this `AVAssetTrack` to the
    /// <doc://com.apple.documentation/documentation/avfoundation/avassetreadertrackoutput>  
    /// and add this output tracker to the `AVAssetReader`.
    ///
    /// Wait for setup to finish and start reading.
    /// Read the sample buffers from the reader and enqueue it into the 
    /// `AVSampleBufferVideoRenderer` object.
    /// `AVSampleBufferVideoRenderer` uses a push model, so feed the video sample buffers until 
    /// the queue is full, and then resume feeding it when it's ready for more.
    /// You can use `isReadyForMoreMediaData` on the `AVSampleBufferVideoRenderer`
    /// object in a while-loop to check whether you need to enqueue more sample buffers.
    /// You can't use the same `AVSampleBufferVideoRenderer` object with more than one
    /// `VideoPlayerComponent`.
    ///
    /// You need to synchronize the audio, captions, and playback rate separately in your app.
    ///
    /// The following code example demonstrates this process:
    ///
    /// ```swift
    /// // Create an `AVSampleBufferVideoRenderer` instance to control playback of a movie.
    /// let videoRenderer = AVSampleBufferVideoRenderer()
    ///
    /// // Create an entity for display.
    /// let videoEntity = Entity()
    ///
    /// // Create a `VideoPlayerComponent` object that supplies the `AVSampleBufferVideoRenderer` object.
    /// let videoPlayerComponent = VideoPlayerComponent(videoRenderer: videoRenderer)
    /// videoEntity.components[VideoPlayerComponent.self] = videoPlayerComponent
    ///
    /// // Create a URL that points to the movie file.
    /// if let url = Bundle.main.url(forResource: "MyMovie", withExtension: "mp4") {
    ///
    ///     let sourceAsset = AVURLAsset(url: url)
    ///     let sourceAssetReader = AVAssetReader(asset: sourceAsset)
    ///     let sourceAssetVideoTrack = sourceAsset.loadTracks(withMediaType: .video).first
    ///     let sourceAssetReaderVideoTrackOutput = AVAssetReaderTrackOutput(track: sourceAssetVideoTrack!, outputSettings: nil)
    ///     sourceAssetReader.add(sourceAssetReaderVideoTrackOutput!)
    ///
    ///     sourceAssetReader.startReading()
    ///     videoRenderer.requestMediaDataWhenReady(on: DispatchQueue.global()) {
    ///       while videoRenderer.isReadyForMoreMediaData {
    ///           if let sampleBuffer = sourceAssetReaderVideoTrackOutput!.copyNextSampleBuffer() {
    ///               videoRenderer.enqueue(sampleBuffer)
    ///           } else {
    ///               videoRenderer.stopRequestingMediaData()
    ///               return
    ///           }
    ///       }
    ///   }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///    - videoRenderer: The sample buffer video renderer with the visual contents the component
    ///    presents.
    ///
    public init(videoRenderer: AVSampleBufferVideoRenderer)
}

@available(visionOS 2.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(macCatalyst, unavailable)
extension VideoPlayerComponent.ImmersiveViewingMode : Equatable {
}

@available(visionOS 2.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(macCatalyst, unavailable)
extension VideoPlayerComponent.ImmersiveViewingMode : Hashable {
}

/// Events associated with video playback for VideoPlayerComponent.
///
/// For more information on subscribing to scene events, see ``RealityKit/Scene/Event``.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public enum VideoPlayerEvents {

    /// Content type changed event
    public struct ContentTypeDidChange : Event {

        public enum ContentType : UInt8, Sendable {

            case invalid

            case mono

            case stereo

            case immersive

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional("PaperSize.Legal")"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: UInt8)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 18.0, visionOS 1.0, macOS 15.0, *)
            public typealias RawValue = UInt8

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: UInt8 { get }
        }

        /// contentType type, can be same as previousType
        public let contentType: VideoPlayerEvents.ContentTypeDidChange.ContentType

        /// previous content type
        public let previousType: VideoPlayerEvents.ContentTypeDidChange.ContentType
    }

    public struct ViewingModeDidChange : Event {

        public let currentViewingMode: VideoPlaybackController.ViewingMode?

        public let previousViewingMode: VideoPlaybackController.ViewingMode?
    }

    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(macCatalyst, unavailable)
    public struct ImmersiveViewingModeDidChange : Event {

        /// Previous immersive viewing mode
        public let previousMode: VideoPlayerComponent.ImmersiveViewingMode?

        /// Current immersive viewing mode
        public let currentMode: VideoPlayerComponent.ImmersiveViewingMode?
    }

    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(macCatalyst, unavailable)
    public struct ImmersiveViewingModeWillTransition : Event {

        /// Previous immersive viewing mode
        public let previousMode: VideoPlayerComponent.ImmersiveViewingMode?

        /// Current immersive viewing mode
        public let currentMode: VideoPlayerComponent.ImmersiveViewingMode?
    }

    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(iOS, unavailable)
    @available(macCatalyst, unavailable)
    public struct ImmersiveViewingModeDidTransition : Event {

        /// Previous immersive viewing mode
        public let previousMode: VideoPlayerComponent.ImmersiveViewingMode?

        /// Current immersive viewing mode
        public let currentMode: VideoPlayerComponent.ImmersiveViewingMode?
    }

    public struct VideoSizeDidChange : Event {

        /// video screen mesh size in meters
        public let screenMeshSize: SIMD2<Float>

        /// Video resolution
        public let videoDimension: SIMD2<Float>
    }
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension VideoPlayerEvents.ContentTypeDidChange.ContentType : Equatable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension VideoPlayerEvents.ContentTypeDidChange.ContentType : Hashable {
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension VideoPlayerEvents.ContentTypeDidChange.ContentType : RawRepresentable {
}

/// A component that provides environment lighting for entities you place within the same virtual world.
///
/// In a fully virtual environment, you can configure the `VirtualEnvironmentProbeComponent` with an
/// ``EnvironmentResource`` to provide precalculated indirect lighting from the environment. RealityKit
/// combines this lighting with other lights in the scene to calculate the final lighting of an entity.
/// The example below shows how you can set up a `VirtualEnvironmentProbeComponent` from
/// a single probe:
///
/// ```swift
/// let environment = try await Entity(named: "environment")
/// let resource = try await EnvironmentResource(named: "MyEnvironment", in: bundle)
/// let probe = VirtualEnvironmentProbeComponent.Probe(environment: resource)
/// let probeComponent = VirtualEnvironmentProbeComponent(source: .single(probe))
/// environment.components.set(probeComponent)
/// ```
///
/// - Note: In visionOS, ARKit automatically provides the environment lighting for the shared space.
@available(visionOS 2.0, iOS 18.0, macOS 15.0, *)
public struct VirtualEnvironmentProbeComponent : Component {

    /// Options that define the source of diffuse and specular lighting for environment lighting calculations.
    public enum Source {

        /// A source without any lighting.
        case none

        /// A source representing a single pregenerated probe.
        case single(VirtualEnvironmentProbeComponent.Probe)

        /// A source that blends between two pregenerated probes based on the provided blend factor.
        ///
        /// The blend factor is in the range `[0.0, 1.0]` where a value of `0.0` uses only the
        /// first probe, and `1.0` uses only the second probe.
        case blend(from: VirtualEnvironmentProbeComponent.Probe, to: VirtualEnvironmentProbeComponent.Probe, t: Float)
    }

    /// A sample of the environment around a point in a scene the system uses for environment-based lighting.
    public struct Probe {

        /// The resource that stores a representation of diffuse and specular environment lighting.
        public var environment: EnvironmentResource

        /// The intensity value for the resource, which RealityKit defines on a logarithmic scale.
        ///
        /// RealityKit multiplies the intensity of the probe by `2^intensityExponent`.
        /// An `intensityExponent` of `0.0` means using the diffuse and specular intensities as-is.
        public var intensityExponent: Float

        /// Creates a virtual-environment probe from an environment resource and intensity value.
        /// - Parameters:
        ///   - environment: An environment resource.
        ///   - intensityExponent: An intensity value for the resource.
        public init(environment: EnvironmentResource, intensityExponent: Float = 0)
    }

    /// The source of diffuse and specular lighting for environment lighting calculations.
    public var source: VirtualEnvironmentProbeComponent.Source

    /// Creates a virtual-environment probe component.
    ///
    /// - Parameter source: An enumeration describing the source of environment lighting.
    public init(source: VirtualEnvironmentProbeComponent.Source = .none)
}

/// A force effect whose forces circulate around an axis centered at the origin of the effect.
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
public struct VortexForceEffect : ForceEffectProtocol, Codable {

    /// Creates a vortex force effect.
    ///  - Parameters:
    ///     - strength: The magnitude of the force.
    ///     - axis: The vortex's rotational axis centered at the effect origin.
    public init(strength: Double, axis: SIMD3<Float>)

    /// Calculates the vortex forces for rigid bodies from the force effect.
    ///
    /// - Parameter parameters: On input, the parameters that calculate forces to the affected physics bodies; on output, the updates to those forces.
    ///
    /// The framework automatically calls this method for you at each physics simulation step,
    /// so you don't need to call it yourself.
    public func update(parameters: inout ForceEffectParameters)

    /// The magnitude of the force.
    public let strength: Float

    /// The vortex's rotational axis centered at the origin of the effect.
    public let axis: SIMD3<Float>

    /// The input rigid body parameters.
    public var parameterTypes: PhysicsBodyParameterTypes { get }

    /// The type of force this effect applies.
    public var forceMode: ForceMode

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A component that defines a portal world.
///
/// This component separates an entity and its descendants from the default world,
/// allowing it to only be visible through a portal.
///
/// Use a ``PortalComponent`` and point its ``PortalComponent/targetEntity`` to this
/// entity to render this world.
///
/// See ``PortalComponent`` for information about example usage, clipping, crossing,
/// and lighting.
@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
public struct WorldComponent : Component {

    public init()
}

/// Combines the animations that result from two blend-tree nodes into a single
/// blend-tree node.
///
/// - Parameters:
///   - x: A blend-tree node whose animation combines with the second animation
/// argument.
///
///   - y:  A blend-tree node whose animation combines with the first animation
/// argument.
///
///   - name: A unique name for the combined node.
///
///   - isAdditive: A Boolean value that indicates whether the animation builds on
/// the current state of the target entity, or resets the state before running.
///
/// - Returns: A blend-tree node that combines the given animations.
@available(macOS 12.0, iOS 15.0, *)
public func blend(_ x: any BlendTreeNode, _ y: any BlendTreeNode, name: String = "", isAdditive: Bool = false) -> any BlendTreeNode

/// Combines the animations that result from the individual blend-tree nodes of
/// the given array to a single blend-tree node.
///
/// - Parameters:
///   - sources: The blend-tree nodes to combine.
///
///   - name: A unique name for the combined node.
///
///   - isAdditive: A Boolean value that indicates whether the animation builds on
/// the current state of the target entity, or resets the state before running.
///
/// - Returns: A blend-tree node that combines the given animations.
@available(macOS 12.0, iOS 15.0, *)
public func blend(sources: [any BlendTreeNode], name: String = "", isAdditive: Bool = false) -> any BlendTreeNode

/// Returns a predicate which evaluates to `true` if `left` OR `right` evaluates to `true`.
@available(macOS 12.0, iOS 15.0, *)
public func || <Value>(left: QueryPredicate<Value>, right: QueryPredicate<Value>) -> QueryPredicate<Value>

@available(macOS 12.0, iOS 15.0, *)
extension Float : BindableData {
}

@available(macOS 12.0, iOS 15.0, *)
extension Double : BindableData {
}

@available(macOS 12.0, iOS 15.0, *)
extension SIMD2 : BindableData where Scalar == Float {
}

@available(macOS 12.0, iOS 15.0, *)
extension SIMD3 : BindableData where Scalar == Float {
}

@available(macOS 12.0, iOS 15.0, *)
extension SIMD4 : BindableData where Scalar == Float {
}

@available(macOS 12.0, iOS 15.0, *)
extension simd_quatf : BindableData {
}

@available(macOS 12.0, iOS 15.0, *)
extension Bool : BindableData {
}

@available(macOS 12.0, iOS 15.0, *)
extension Int : BindableData {
}

@available(macOS 12.0, iOS 15.0, *)
extension String : BindableData {
}

@available(macOS 10.15, iOS 13.0, *)
extension UInt64 : SynchronizationPeerID {
}

@available(macOS 12.0, iOS 15.0, *)
extension MTLCommandBuffer {

    /// Registers a drawable presentation to occur as soon as possible
    ///    - drawable: The drawable that you want to present.
    public func present(_ drawable: TextureResource.Drawable)
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension AffineTransform3D {

    public init(_ transform: Transform)
}

@available(visionOS 1.0, macOS 15.0, iOS 18.0, *)
extension Rect3D {

    public init(_ bounds: BoundingBox)
}

@available(macOS 12.0, iOS 15.0, *)
extension Float : AnimatableData {
}

@available(macOS 12.0, iOS 15.0, *)
extension Double : AnimatableData {
}

@available(macOS 12.0, iOS 15.0, *)
extension SIMD2 : AnimatableData where Scalar == Float {
}

@available(macOS 12.0, iOS 15.0, *)
extension SIMD3 : AnimatableData where Scalar == Float {
}

@available(macOS 12.0, iOS 15.0, *)
extension SIMD4 : AnimatableData where Scalar == Float {
}

@available(macOS 12.0, iOS 15.0, *)
extension simd_quatf : AnimatableData {
}

extension Cancellable {

    /// Retains the `Cancellable` as long as the entity is active (see `Entity.isActive`). If the
    /// entity is deactivated, the `Cancellable` is released.
    ///
    /// This method does nothing if the entity is already inactive.
    ///
    /// Internally, this method stores an `AnyCancellable` in a transient component of the entity.
    /// The component is removed when the *deactivate* event for this entity is received.
    @available(macOS 12.0, iOS 15.0, *)
    @MainActor @preconcurrency public func storeWhileEntityActive(_ entity: Entity)
}

